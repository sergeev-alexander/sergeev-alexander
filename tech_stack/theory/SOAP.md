# SOAP (Simple Object Access Protocol)

## Основные понятия

- `SOAP` (Simple Object Access Protocol) — протокол обмена структурированными сообщениями, основанный на XML. Несмотря
  на название, **не предназначен для прямого вызова объектов**, а служит нейтральным, транспортно-независимым форматом
  для передачи данных между системами.
- `Message` (сообщение) — неделимая единица данных в SOAP. Каждое сообщение является самодостаточным XML-документом с
  фиксированной структурой и строгими правилами well-formedness и validity.
- `Protocol independence` (независимость от протокола) — SOAP не привязан к HTTP; может использоваться поверх SMTP, JMS,
  TCP и других транспортов. Однако на практике почти всегда применяется с HTTP(S).
- `Extensibility` (расширяемость) — механизм заголовков (`Header`) позволяет добавлять метаданные (безопасность,
  маршрутизация, транзакции) без изменения тела сообщения.
- Стандартизирован W3C (SOAP 1.2 — рекомендация с 2003 г.).
- Широко используется в enterprise-интеграциях, банковских системах, государственных сервисах — где важны строгий
  контракт, типизация и надёжность.

## Сравнение с REST: архитектурные различия

| Аспект                   | SOAP                                                                    | REST (в типичной реализации)                                   |
|--------------------------|-------------------------------------------------------------------------|----------------------------------------------------------------|
| **Стиль взаимодействия** | RPC-подобный (вызов операций)                                           | Ресурс-ориентированный (манипуляция ресурсами)                 |
| **Определение операции** | Указывается **внутри тела** (`Body`), например `<GetUser>...</GetUser>` | Определяется **HTTP-методом + URL**: `GET /users/123`          |
| **Endpoint**             | Один URL для всех операций сервиса                                      | Много URL, каждый — для конкретного ресурса или коллекции      |
| **Контракт**             | Обязательный, машинно-читаемый (WSDL + XSD)                             | Часто неформальный (OpenAPI/Swagger — опционален)              |
| **Формат ошибок**        | Стандартизированный элемент `<Fault>` внутри `Body`                     | HTTP-статус-код + тело (структура — по соглашению)             |
| **Транспорт**            | Независим от транспорта (HTTP, JMS, SMTP и др.)                         | Жёстко привязан к HTTP (или HTTPS)                             |
| **Метаданные**           | Передаются в `<Header>` (например, токен безопасности)                  | Передаются в HTTP-заголовках (`Authorization`, `Content-Type`) |

## Производственные характеристики

- **Формальность и надёжность**:  
  SOAP требует явного описания структуры сообщений (через XSD) и контракта (через WSDL). Это исключает двусмысленности и
  обеспечивает compile-time безопасность при генерации кода. В отличие от REST, где «что пришло — то и парсим», SOAP
  гарантирует соответствие схеме до обработки бизнес-логики.

- **Объём и производительность**:  
  Из-за XML-разметки, пространств имён и обязательных обёрток (`Envelope`, `Body`) сообщения SOAP значительно больше по
  размеру, чем эквивалентные JSON-сообщения в REST. Это увеличивает сетевую нагрузку и время
  сериализации/десериализации.

- **Отладка и инструменты**:  
  REST легко тестировать через `curl` или Postman. SOAP требует специализированных инструментов (SoapUI, IntelliJ HTTP
  Client с поддержкой SOAP) или ручного формирования XML. Однако при наличии WSDL клиент можно сгенерировать
  автоматически — что снижает вероятность ошибок.

- **Безопасность и стандарты**:  
  Хотя базовая безопасность (HTTPS, отключение XXE) аналогична REST, SOAP имеет развитую экосистему стандартов:
  WS-Security (подписи, шифрование), WS-ReliableMessaging (гарантированная доставка), WS-Transaction. Эти стандарты
  редко используются в REST.

- **Подходящие сценарии**:  
  SOAP предпочтителен в доменах с высокими требованиями к:
    - Целостности данных (финансы, здравоохранение),
    - Аудиту и регулированию (госсектор),
    - Сложным workflow (многошаговые транзакции, компенсирующие операции).

  REST лучше подходит для:
    - Публичных API,
    - Микросервисов внутри доверенной среды,
    - Сценариев с высокой нагрузкой и низкой задержкой.

## Практические последствия для разработчика

- При работе с SOAP ты **не выбираешь HTTP-метод** — всё идёт через POST.
- Ты **не проектируешь URL** — endpoint один, а операция определяется содержимым.
- Ты **не пишешь JSON-схемы** — структуру определяет XSD, вложенная в WSDL.
- Ты **не обрабатываешь 4xx/5xx** напрямую — все ошибки приходят как успешный HTTP 200 с телом `<Fault>`.
- Ты **полагаешься на генерацию кода** (`wsimport`) гораздо чаще, чем в REST.

Это делает SOAP более «тяжёлым», но и более предсказуемым в enterprise-средах.

---

<details>
  <summary>
    <b>SOAP Message Structure (Структура SOAP-сообщения)</b>
  </summary>

## Основные понятия

- `Message` (сообщение) — неделимая единица передачи в протоколе SOAP. Каждое сообщение является **корректным
  XML-документом**, соответствующим спецификации SOAP и, как правило, дополнительной XSD-схеме для содержимого тела.
- Сообщение всегда имеет **фиксированную иерархическую структуру**: корневой элемент `<Envelope>`, содержащий
  необязательный `<Header>` и обязательный `<Body>`.
- Все элементы SOAP определены в **специальном пространстве имён**, зависящем от версии протокола.

## Обязательные компоненты

### Envelope

- Корневой элемент любого SOAP-сообщения.
- Пространство имён:
    - SOAP 1.1: `http://schemas.xmlsoap.org/soap/envelope/`
    - SOAP 1.2: `http://www.w3.org/2003/05/soap-envelope`
- Должен содержать ровно один `<Body>` и не более одного `<Header>`.

Пример (SOAP 1.1):

```xml

<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
    <!-- Header (опционально) -->
    <soap:Body>
        <!-- Полезная нагрузка или Fault -->
    </soap:Body>
</soap:Envelope>
```

### Body

- Обязательный дочерний элемент `<Envelope>`.
- Содержит либо **полезную нагрузку** (результат операции или её параметры), либо элемент `<Fault>` в случае ошибки.
- Содержимое `<Body>` описывается **пользовательской XSD-схемой**, а не спецификацией SOAP.

## Необязательные компоненты

### Header

- Может отсутствовать.
- Содержит **метаданные**, не относящиеся к бизнес-логике: учётные данные, идентификаторы транзакций, маршрутизация,
  квоты.
- Каждый дочерний элемент `<Header>` называется **header block**.
- Поддерживает атрибуты `mustUnderstand` и `role` (в SOAP 1.2 — `relay`), управляющие обработкой.

Атрибут `mustUnderstand`:

- Если `"1"` (или `"true"` в SOAP 1.2), получатель **обязан** понять и обработать этот header block.
- Если не поддерживается — должен вернуть SOAP Fault с кодом `MustUnderstand`.

Пример: SOAP-запрос с обязательным заголовком аутентификации
SOAP 1.1:

```xml

<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"
               xmlns:auth="http://example.com/auth">
    <soap:Header>
        <auth:SecurityToken mustUnderstand="1">
            abc123xyz456
        </auth:SecurityToken>
    </soap:Header>
    <soap:Body>
        <GetUserData>
            <userId>789</userId>
        </GetUserData>
    </soap:Body>
</soap:Envelope>
```

- Сервис ожидает, что клиент передаст токен в заголовке `<auth:SecurityToken>`.
- Атрибут `mustUnderstand="1"` говорит: «Если ты (сервис) не знаешь, как обработать этот заголовок — не пытайся
  выполнить операцию, а сразу верни ошибку».
- Если сервис не поддерживает `auth:SecurityToken`, он обязан ответить:

```xml

<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
    <soap:Body>
        <soap:Fault>
            <faultcode>soap:MustUnderstand</faultcode>
            <faultstring>Header SecurityToken not understood</faultstring>
        </soap:Fault>
    </soap:Body>
</soap:Envelope>
```

- Если бы `mustUnderstand` не было, промежуточное звено (например, шлюз или прокси), которое должно проверять
  безопасность до того, как запрос попадёт в бизнес-логику могло бы проигнорировать заголовок, и запрос дошёл бы до
  сервиса без аутентификации — критическая уязвимость.
- Атрибут `mustUnderstand` гарантирует, что любой участник цепочки, который не может обработать обязательный заголовок,
  остановит обработку.

В SOAP 1.2 синтаксис немного другой (но смысл тот же):

```xml

<auth:SecurityToken soap:mustUnderstand="true" ...>
```

## Fault (ошибки)

- Специальный элемент внутри `<Body>`, используемый для стандартизированного представления ошибок.
- Имеет фиксированную структуру:
    - `<faultcode>` — категория ошибки (SOAP 1.1) или `<Code>` (SOAP 1.2).
    - `<faultstring>` / `<Reason>` — человекочитаемое описание.
    - `<detail>` / `<Detail>` — опциональные технические детали (например, стек-трейс или код приложения).

Пример (SOAP 1.1):

```xml

<soap:Fault>
    <faultcode>soap:Client</faultcode>
    <faultstring>Invalid user ID</faultstring>
    <detail>
        <app:ErrorCode xmlns:app="http://example.com">USR-001</app:ErrorCode>
    </detail>
</soap:Fault>
```

## Правила well-formedness и validity

- Сообщение должно быть well-formed XML.
- Все элементы SOAP должны находиться в правильном пространстве имён.
- Нельзя добавлять произвольные элементы на уровне `<Envelope>` — только `<Header>` и `<Body>`.
- Содержимое `<Body>` должно соответствовать XSD, определённой в контракте (WSDL).

## Производственные рекомендации

- Всегда проверяйте наличие `<Fault>` в ответе перед извлечением полезной нагрузки.
- Не храните чувствительные данные (пароли, токены) в открытом виде в `<Header>` — используйте WS-Security или HTTPS.
- При логировании исключайте `<Header>`, если он может содержать PII или секреты.
- Убедитесь, что парсер настроен на безопасную обработку XML (отключение DTD, XXE), даже если сообщение «пришло по
  доверенному каналу».

</details>

---

<details>
  <summary>
    <b>SOAP Transport Binding (Привязка SOAP к транспорту)</b>
  </summary>

## Основные понятия

- `Transport binding` (привязка к транспорту) — механизм интеграции SOAP-сообщений с конкретным протоколом передачи
  данных (HTTP, JMS, SMTP и др.).
- SOAP сам по себе **не определяет транспорт** — он лишь задаёт формат сообщения. Привязка описывает, как это сообщение
  упаковывается и передаётся.
- Несмотря на поддержку множества транспортов, **HTTP(S) является де-факто стандартом** в подавляющем большинстве
  реализаций.

## HTTP/HTTPS (основной транспорт)

### Особенности

- Все операции передаются через **HTTP POST**.
- Запрос и ответ — два независимых SOAP-сообщения.
- Используются стандартные HTTP-заголовки для метаданных транспорта:
    - `Content-Type`:
        - SOAP 1.1: `text/xml; charset=utf-8`
        - SOAP 1.2: `application/soap+xml; charset=utf-8`
    - `SOAPAction` (только в SOAP 1.1): строка, идентифицирующая операцию (часто URI); в SOAP 1.2 упразднён — операция
      определяется содержимым `Body`.

### Пример запроса (SOAP 1.1)

```text
POST /UserService HTTP/1.1  
Host: api.example.com  
Content-Type: text/xml; charset=utf-8  
SOAPAction: "http://example.com/GetUser"

<soap:Envelope>...</soap:Envelope>
```

### Преимущества

- Совместимость с веб-инфраструктурой (прокси, балансировщики, firewalls).
- Поддержка HTTPS для шифрования и аутентификации.
- Простота отладки через инструменты вроде Wireshark, Postman, curl.

## Другие транспорты (редкие случаи)

### JMS (Java Message Service)

- Используется в enterprise-системах для асинхронной, надёжной доставки.
- SOAP-сообщение помещается в тело JMS-сообщения как текст или байты.
- Поддерживает очереди, темы, транзакции, гарантированную доставку.
- Требует совместимости между отправителем и получателем на уровне JMS-провайдера.

### SMTP (электронная почта)

- Исторически использовался для асинхронного обмена (например, в B2B).
- SOAP-сообщение вкладывается в MIME-тело письма.
- На практике почти не применяется из-за задержек, отсутствия гарантий и сложности обработки ошибок.

## Влияние на разработку и тестирование

- При использовании HTTP логика сервиса может быть развёрнута как веб-приложение (Servlet в Java).
- При других транспортах требуется специфическая инфраструктура (JMS-брокер, почтовый сервер).
- В тестах важно эмулировать именно тот транспорт, который используется в production — поведение при ошибке сети,
  тайм-аутах и повторных попытках сильно различается.

## Производственные рекомендации

- По умолчанию используйте **HTTPS** даже во внутренних сетях — предотвращает сниффинг и MITM.
- Не полагайтесь на заголовок `SOAPAction` для авторизации или маршрутизации — он может быть пустым или подделан.
- Если требуется асинхронность — рассмотрите JMS поверх SOAP, но оцените сложность против современных альтернатив (AMQP,
  Kafka + REST).
- Убедитесь, что ваша реализация (JAX-WS, CXF) корректно обрабатывает кодировки и MIME-типы, особенно при переходе между
  SOAP 1.1 и 1.2.

</details>

---

<details>
  <summary>
    <b>SOAP Namespaces and Versions (Пространства имён и версии SOAP)</b>
  </summary>

## Основные понятия

- `SOAP namespace` (пространство имён SOAP) — URI, однозначно идентифицирующий версию протокола и определяющий
  интерпретацию элементов `Envelope`, `Header`, `Body`, `Fault`.
- Несовпадение пространства имён и ожидаемой версии приводит к ошибке парсинга на уровне транспорта.
- Все элементы SOAP **обязаны** находиться в правильном пространстве имён — даже если XML well-formed.

## Пространства имён по версиям

### SOAP 1.1

- Спецификация: консорциум (Microsoft, IBM и др.), не является стандартом W3C.
- Пространство имён:  
  `http://schemas.xmlsoap.org/soap/envelope/`
- Дополнительные NS:
    - Encoding: `http://schemas.xmlsoap.org/soap/encoding/` (устаревшее)
    - Actor (в `Header`): `http://schemas.xmlsoap.org/soap/actor/`

### SOAP 1.2

- Спецификация: рекомендация W3C (Part 1: Messaging Framework).
- Пространство имён:  
  `http://www.w3.org/2003/05/soap-envelope`
- Дополнительные NS:
    - Encoding: `http://www.w3.org/2003/05/soap-encoding` (редко используется)
    - Role/Relay: часть основного NS

## Ключевые различия между SOAP 1.1 и 1.2

| Аспект                   | SOAP 1.1                                        | SOAP 1.2                                                 |
|--------------------------|-------------------------------------------------|----------------------------------------------------------|
| **MIME Type**            | `text/xml`                                      | `application/soap+xml`                                   |
| **SOAPAction**           | Обязательный HTTP-заголовок (может быть пустым) | Удалён; операция определяется содержимым `Body`          |
| **Fault structure**      | `<faultcode>`, `<faultstring>`, `<detail>`      | `<Code>`, `<Reason>`, `<Detail>` (более гибкая иерархия) |
| **mustUnderstand**       | Значение `"1"` или `"0"`                        | Булево: `"true"` / `"false"`                             |
| **HTTP Status on Fault** | Часто 200 OK                                    | Рекомендуется 500 Internal Server Error                  |
| **Extensibility model**  | Проще, но менее строгий                         | Более формализованная модель расширений                  |

## Примеры корректных Envelope

### SOAP 1.1

```xml

<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
    <soap:Body>
        <GetUser/>
    </soap:Body>
</soap:Envelope>
```

### SOAP 1.2

```xml

<soap:Envelope xmlns:soap="http://www.w3.org/2003/05/soap-envelope">
    <soap:Body>
        <GetUser/>
    </soap:Body>
</soap:Envelope>
```

## Последствия несоответствия

- Если клиент отправляет SOAP 1.2-сообщение с NS 1.1 — сервер отклонит его как недопустимое.
- Неправильный `Content-Type` может привести к тому, что сервер вообще не распознает запрос как SOAP.
- Инструменты (`wsimport`, SoapUI) привязаны к конкретной версии — смешивание вызывает ошибки генерации кода.

## Как определить версию сервиса?

- Из WSDL: атрибут `transport` в `binding` и пространства имён в `message`.
- По HTTP-ответу: `Content-Type` заголовка.
- По структуре `Fault`.

## Производственные рекомендации

- **Предпочитайте SOAP 1.2**, если нет требования совместимости с устаревшими системами (особенно Microsoft .NET до
  3.0).
- Всегда явно указывайте правильное пространство имён — не полагайтесь на «похожие» URI.
- При разработке клиента используйте WSDL для генерации кода — это гарантирует соответствие версии.
- В логах фиксируйте версию SOAP и `Content-Type` — это критично для диагностики межсистемных ошибок.
- Не смешивайте SOAP 1.1 и 1.2 в одном интеграционном контуре без шлюза преобразования.

</details>

---

<details>
  <summary>
    <b>Protocol vs Application Namespaces in SOAP (Протокольные и пользовательские пространства имён)</b>
  </summary>

## Основные понятия

- `Protocol namespace` — пространство имён, определяемое спецификацией SOAP (`Envelope`, `Header`, `Body`, `Fault`).
- `Application namespace` — пространство имён, определяемое разработчиком или контрактом (WSDL/XSD) для бизнес-данных
  внутри `Body`.

## Разделение ответственности

| Уровень    | Пространство имён                                       | Ответственный      |
|------------|---------------------------------------------------------|--------------------|
| Протокол   | `http://schemas.xmlsoap.org/soap/envelope/` (1.1)       | Спецификация SOAP  |
|            | `http://www.w3.org/2003/05/soap-envelope` (1.2)         |                    |
| Приложение | Произвольный URI (например, `http://example.com/order`) | Разработчик / WSDL |

## Правила использования

- Элементы `Envelope`, `Header`, `Body`, `Fault` **обязаны** находиться в протокольном NS.
- Все элементы внутри `Body` (операции, параметры, результаты) **должны** находиться в пользовательском NS.
- Нельзя смешивать протокольный и пользовательский NS в одном элементе.
- Префикс для пользовательского NS выбирается произвольно (`ns`, `tns`, `user` и т.д.), но должен быть объявлен.

## Пример корректного разделения

```xml

<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"
               xmlns:order="http://example.com/order">
    <soap:Body>
        <order:GetOrder>
            <order:id>789</order:id>
        </order:GetOrder>
    </soap:Body>
</soap:Envelope>
```

Здесь:

- `soap:` — протокольное пространство (фиксировано),
- `order:` — пользовательское (определено в XSD/WSDL).

## Последствия нарушения

- Если элемент `GetOrder` окажется в протокольном NS — парсер не найдёт его определения → ошибка валидации.
- Если `Body` окажется в пользовательском NS — сообщение не распознается как SOAP → ошибка парсинга.

## Производственные рекомендации

- Всегда используйте явные префиксы для пользовательских элементов — не полагайтесь на default namespace.
- Убедитесь, что URI пользовательского NS совпадает с `targetNamespace` в XSD и `namespace` в WSDL.
- Не используйте одинаковые URI для разных контрактов — это вызывает конфликты при композиции.
- При генерации кода (`wsimport`) проверяйте, что сгенерированные классы аннотированы правильным
  `@XmlType(namespace = "...")`.

</details>

---

<details>
  <summary>
    <b>SOAP Request-Response Exchange (Типичный обмен запрос-ответ в SOAP)</b>
  </summary>

## Основные понятия

- `Request-Response` — наиболее распространённая модель взаимодействия в SOAP, при которой клиент отправляет запрос, а
  сервер возвращает ответ.
- Оба сообщения — **независимые SOAP-документы**, каждый со своей структурой `Envelope`/`Header`/`Body`.
- Операция определяется **именем корневого элемента внутри `Body` запроса**.
- Результат операции возвращается как **корневой элемент внутри `Body` ответа**.

## Структура запроса

- HTTP-метод: `POST`
- URL: единый endpoint сервиса (например, `/UserService`)
- Заголовки:
    - `Content-Type`: `text/xml` (SOAP 1.1) или `application/soap+xml` (SOAP 1.2)
    - `SOAPAction` (только SOAP 1.1): строка, идентифицирующая операцию (часто URI)
- Тело: SOAP-сообщение с операцией в `Body`.

Пример запроса (SOAP 1.1):

```text
POST /UserService HTTP/1.1
Host: api.example.com
Content-Type: text/xml; charset=utf-8
SOAPAction: "http://example.com/GetUser"
```

```xml

<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"
               xmlns:ns="http://example.com/user">
    <soap:Body>
        <ns:GetUser>
            <ns:userId>123</ns:userId>
        </ns:GetUser>
    </soap:Body>
</soap:Envelope>
```

## Структура ответа

- HTTP-статус: обычно `200 OK`, даже при логической ошибке (если используется `Fault`)
- Тело: SOAP-сообщение с результатом или `Fault` в `Body`.

Пример успешного ответа:

```text
HTTP/1.1 200 OK
Content-Type: text/xml; charset=utf-8
```

```xml

<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"
               xmlns:ns="http://example.com/user">
    <soap:Body>
        <ns:GetUserResponse>
            <ns:user>
                <ns:id>123</ns:id>
                <ns:name>Alexander</ns:name>
            </ns:user>
        </ns:GetUserResponse>
    </soap:Body>
</soap:Envelope>
```

Пример ошибки (Fault):

```xml

<soap:Envelope ...>
<soap:Body>
<soap:Fault>
    <faultcode>soap:Client</faultcode>
    <faultstring>Invalid userId</faultstring>
</soap:Fault>
</soap:Body>
        </soap:Envelope>
```

## Правила именования

- Имя операции в запросе: `<OperationName>`
- Имя ответа: `<OperationNameResponse>` (соглашение, но почти универсальное)
- Пространства имён для пользовательских элементов (`ns:`) должны соответствовать XSD из контракта.

## Особенности обработки

- Клиент **всегда должен проверять наличие `Fault`** перед извлечением результата.
- Сервер **не использует HTTP-статусы** для бизнес-ошибок — только для транспортных проблем (404, 500).
- Параметры операции передаются как дочерние элементы корневого элемента в `Body`.

## Производственные рекомендации

- При проектировании API придерживайтесь соглашения `<Op> → <OpResponse>`.
- Всегда используйте отдельное пространство имён для пользовательских типов (не смешивайте с SOAP NS).
- В логах сохраняйте полные запрос/ответ (при отладке) — но фильтруйте чувствительные данные из `Header` и `Body`.
- При тестировании покрывайте три случая:
    - Успешный вызов,
    - Клиентская ошибка — когда сервер возвращает `Fault` с кодом ошибки, указывающим на некорректный запрос:

        - В SOAP 1.1: `<faultcode>soap:Client</faultcode>`
        - В SOAP 1.2: `<Value>soap:Sender</Value>` внутри `<Code>`

    - Серверная ошибка — когда проблема на стороне сервиса:

        - В SOAP 1.1: `<faultcode>soap:Server</faultcode>`
        - В SOAP 1.2: `<Value>soap:Receiver</Value>` внутри `<Code>`

</details>

---

<details>
  <summary>
    <b>SOAP with XSD and WSDL (Связь SOAP с XSD и WSDL)</b>
  </summary>

## Основные понятия

- `XSD` (XML Schema Definition) — описывает структуру **бизнес-данных** внутри `<Body>` SOAP-сообщения: операции,
  параметры, ответы, ошибки.
- `WSDL` (Web Services Description Language) — XML-документ, описывающий **полный контракт SOAP-сервиса**: доступные
  операции, сообщения, типы (через XSD), транспорт, endpoint.
- `SOAP` — формат сообщения; **не зависит напрямую от WSDL**, но в enterprise-практике почти всегда используется вместе
  с ним.

## Роли компонентов

| Компонент | Ответственность                                                                                  |
|-----------|--------------------------------------------------------------------------------------------------|
| **SOAP**  | Формат обмена: Envelope, Header, Body, Fault                                                     |
| **XSD**   | Типизация содержимого Body: что такое `GetUser`, какие у него поля                               |
| **WSDL**  | Сборка всего вместе: какие операции есть, как они вызываются, где сервис, как выглядят сообщения |

## Как это работает вместе

1. **WSDL импортирует XSD** через `<xs:import>` или встраивает схему напрямую.
2. В разделе `<message>` WSDL ссылается на элементы из XSD:

```xml

<message name="GetUserRequest">
    <part name="parameters" element="tns:GetUser"/>
</message>
```

где `tns:GetUser` определён в XSD.

3. Раздел `<portType>` описывает операции и их вход/выход.
4. Раздел `<binding>` указывает, что используется SOAP (и версию).
5. Раздел `<service>` задаёт URL endpoint'а.

## Пример фрагмента WSDL (упрощённо)

```xml

<definitions xmlns:tns="http://example.com/user"
             targetNamespace="http://example.com/user">
    <types>
        <xs:schema targetNamespace="http://example.com/user">
            <xs:element name="GetUser" type="GetUserType"/>
            <xs:element name="GetUserResponse" type="GetUserResponseType"/>
            <!-- ... определения типов ... -->
        </xs:schema>
    </types>

    <message name="GetUserInput">
        <part name="body" element="tns:GetUser"/>
    </message>

    <message name="GetUserOutput">
        <part name="body" element="tns:GetUserResponse"/>
    </message>

    <portType name="UserServicePort">
        <operation name="GetUser">
            <input message="tns:GetUserInput"/>
            <output message="tns:GetUserOutput"/>
        </operation>
    </portType>

    <binding name="UserServiceBinding" type="tns:UserServicePort">
        <soap:binding transport="http://schemas.xmlsoap.org/soap/http"/>
        <operation name="GetUser">
            <soap:operation soapAction="http://example.com/GetUser"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
    </binding>

    <service name="UserService">
        <port name="UserServicePort" binding="tns:UserServiceBinding">
            <soap:address location="https://api.example.com/UserService"/>
        </port>
    </service>
</definitions>
```

## Ключевые соглашения

- `use="literal"` — означает, что тело сообщения соответствует XSD напрямую (а не закодировано по правилам SOAP
  Encoding, который устарел).
- Все элементы в `Body` должны быть **глобальными** в XSD (иметь `name` на уровне `<xs:schema>`), чтобы на них можно
  было сослаться из WSDL.
- Пространство имён в WSDL (`targetNamespace`) должно совпадать с `targetNamespace` XSD.

## Производственные рекомендации

- Используйте **contract-first подход**: сначала пишете WSDL + XSD, потом генерируете код (`wsimport`). Это гарантирует
  стабильность контракта.
- Не встраивайте XSD в WSDL — выносите в отдельные файлы для модульности и переиспользования.
- Убедитесь, что все элементы в `Body` имеют глобальные объявления в XSD — иначе `wsimport` не сможет сгенерировать
  корректные классы.
- При изменении контракта меняйте WSDL/XSD, а не Java-код — это предотвращает регрессии в интеграциях.
- Документируйте версионирование WSDL (например, через URI: `/v1/UserService?wsdl`), чтобы поддерживать обратную
  совместимость.

</details>

---

<details>
  <summary>
    <b>SOAP Security Basics (Основы безопасности SOAP)</b>
  </summary>

## Основные понятия

- `XXE` (XML External Entity) — уязвимость, возникающая при обработке внешних сущностей в DTD; актуальна для SOAP, так
  как сообщение является XML-документом.
- `Secure processing` — режим парсера, автоматически отключающий опасные функции (DTD, внешние сущности).
- `Transport security` — защита канала передачи (HTTPS), не зависящая от содержимого SOAP.
- `Message-level security` — защита самого сообщения (подпись, шифрование); реализуется через WS-Security

## Угрозы на уровне XML

### XXE через DOCTYPE

Если SOAP-парсер разрешает DTD, атакующий может внедрить:

```text
<!DOCTYPE soap [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
<GetUser>&xxe;</GetUser>
```

→ При обработке содержимое файла подставится в тело запроса.

### Внешние сущности

Аналогично: загрузка URL, SSRF, DoS через рекурсивные сущности.

## Рекомендуемые меры защиты

### 1. Отключить DTD полностью

Установите фичу парсера:
"http://apache.org/xml/features/disallow-doctype-decl" → true

Это **полностью запрещает** `<!DOCTYPE>` — самый надёжный способ.

### 2. Если DTD необходим (крайне редко)

Отключите внешние сущности:

- "http://xml.org/sax/features/external-general-entities" → false
- "http://xml.org/sax/features/external-parameter-entities" → false
- "http://apache.org/xml/features/nonvalidating/load-external-dtd" → false

### 3. Включить безопасную обработку

Для DOM/SAX/StAX:

```java
factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
```

### 4. Использовать HTTPS

Все SOAP-эндпоинты должны быть доступны только по TLS:

- Защита от сниффинга,
- Целостность сообщения на транспортном уровне,
- Аутентификация сервера (и клиента, при необходимости).

### 5. Не хранить секреты в открытом виде

- Избегайте передачи паролей, токенов в `<Header>` без шифрования.
- Даже при HTTPS — если логирование включено, такие данные попадут в логи.

## Поведение популярных библиотек

- **JAX-WS (Metro/CXF)**: по умолчанию **не отключают** DTD — требуется явная настройка.
- **Apache CXF**: предоставляет interceptor `SecureXMLStreamReader` для автоматической защиты.
- **Spring-WS**: позволяет настроить `WebServiceMessageFactory` с безопасными фичами.

## Производственные рекомендации

- **Запретите `DOCTYPE` во всех точках приёма SOAP** — это должно быть политикой по умолчанию.
- Настройте безопасные фичи **на уровне фабрики парсера**, а не в каждом обработчике.
- Проводите регулярное сканирование на XXE с помощью SAST/DAST-инструментов.
- В тестах покрывайте сценарии с вредоносным XML (например, с инжектом `<!DOCTYPE>`).
- Даже если вы «только отправляете» SOAP — убедитесь, что входящие ответы тоже проходят безопасную обработку.

</details>

---

<details>
  <summary>
    <b>Tools and Java Development (Инструменты и разработка на Java)</b>
  </summary>

## Основные понятия

- `JAX-WS` (Java API for XML Web Services) — стандартный API в Java для создания и потребления SOAP-сервисов (входит в
  Jakarta EE, ранее — часть Java SE до версии 11).
- `wsimport` — утилита командной строки, генерирующая Java-классы из WSDL (client-side artifacts).
- `wsgen` — утилита для генерации артефактов сервера из Java-класса (code-first подход; устаревает в пользу
  contract-first).
- `Apache CXF` / `Metro` — популярные реализации JAX-WS с расширенными возможностями.

## Подходы к разработке

### Contract-first (рекомендуется)

1. Пишете WSDL + XSD.
2. Генерируете клиентский и серверный код через `wsimport`.
3. Реализуете бизнес-логику в сгенерированных классах.

Преимущества:

- Контракт стабилен,
- Легко поддерживать обратную совместимость,
- Язык/платформа независимы.

### Code-first (не рекомендуется для публичных API)

1. Пишете Java-класс с аннотациями (`@WebService`, `@WebMethod`).
2. Генерируете WSDL через `wsgen` или автоматически (например, в Spring Boot).
3. Клиенты используют сгенерированный WSDL.

Риски:

- Контракт зависит от внутренней структуры кода,
- Изменения в классах могут нарушить совместимость,
- Сложнее контролировать XSD.

## Пример: генерация клиента через wsimport

Команда:

```text
wsimport -keep -s src -p com.example.client http://api.example.com/UserService?wsdl
```

Результат:

- Класс `UserService` (service),
- Класс `UserServicePortType` (port interface),
- Классы `GetUser`, `GetUserResponse` и т.д. (из XSD).

Использование:

```java
UserService service = new UserService();
UserServicePortType port = service.getUserServicePort();
GetUserResponse response = port.getUser(new GetUser().withUserId("123"));
```

## Пример: минимальный SOAP-сервис на Spring Boot (code-first)

Зависимость:

```groovy

implementation 'org.springframework.boot:spring-boot-starter-web-services'
```

Конфигурация:

```java

@Configuration
@EnableWs
public class WebServiceConfig extends WsConfigurerAdapter {

    @Bean
    public ServletRegistrationBean<MessageDispatcherServlet> messageDispatcherServlet() {
        MessageDispatcherServlet servlet = new MessageDispatcherServlet();
        servlet.setApplicationContext(applicationContext);
        return new ServletRegistrationBean<>(servlet, "/UserService/*");
    }
}
```

Сервис:

```java

@WebService(serviceName = "UserService", targetNamespace = "http://example.com/user")
public class UserServiceImpl {

    @WebMethod
    public GetUserResponse getUser(GetUser request) {
        // бизнес-логика
    }
}
```

→ WSDL будет доступен по `/UserService/UserServicePort?wsdl`.

**Важно**: этот подход генерирует WSDL динамически — сложнее контролировать контракт.

## Инструменты для отладки

- **SoapUI** — промышленный инструмент для тестирования, мокинга, нагрузки.
- **IntelliJ IDEA HTTP Client** — поддерживает отправку SOAP-запросов с подсветкой.
- **Postman** — ограниченная поддержка (требует ручного указания заголовков и тела).
- **curl** — для простых запросов:

```text
  curl -X POST -H "Content-Type: text/xml" --data @request.xml https://api.example.com/UserService
```

## Производственные рекомендации

- Используйте **contract-first** во всех enterprise-интеграциях.
- Храните WSDL и XSD в системе контроля версий — они часть контракта.
- Настройте безопасную обработку XML **в фабрике JAXB/JAX-WS**, а не в каждом эндпоинте.
- При использовании Spring Boot явно указывайте `targetNamespace` в аннотациях — не полагайтесь на дефолты.
- Тестируйте не только бизнес-логику, но и соответствие сгенерированного WSDL ожидаемому контракту.

</details>

---

<details>
  <summary>
    <b>SOAP vs REST: Key Practical Differences (Ключевые практические отличия)</b>
  </summary>

## Контракт и типизация

- **SOAP**: контракт обязателен, машинно-читаемый (WSDL + XSD). Все сообщения строго типизированы.  
  → В отличие от REST, где контракт часто неформален (OpenAPI — опционален).

## Операции и ресурсы

- **SOAP**: RPC-стиль. Все вызовы — HTTP POST на один endpoint. Операция указана внутри `Body`.  
  → В отличие от REST, где операция определяется HTTP-методом (`GET`, `POST`, `PUT`) и URL (`/users/123`).

## Обработка ошибок

- **SOAP**: все ответы — HTTP 200; ошибки передаются в `<Fault>` внутри `Body`.  
  → В отличие от REST, где ошибки выражаются через HTTP-статусы (`400 Bad Request`, `500 Internal Error`).

## Метаданные

- **SOAP**: передаются в элементе <soap:Header> (например, токен безопасности).  
  → В отличие от REST, где метаданные — в HTTP-заголовках (`Authorization: Bearer ...`).

## Формат и размер

- **SOAP**: всегда XML, с обязательными обёртками (`Envelope`, `Body`). Сообщения объёмнее.  
  → В отличие от REST, где допустимы JSON, XML, protobuf — и структура минимальна.

## Инструменты и отладка

- **SOAP**: требует специализированных инструментов (SoapUI) или генерации клиента (`wsimport`).  
  → В отличие от REST, который легко тестировать через `curl` или Postman.

## Безопасность

- **SOAP**: поддерживает как транспортную (HTTPS), так и **уровневую безопасность сообщений** (WS-Security: подпись,
  шифрование).  
  → В REST уровень сообщения почти не используется — полагаются на HTTPS и токены.

## Идемпотентность и кэширование

- **SOAP**: не использует семантику HTTP — нет встроенной поддержки кэширования или идемпотентности.  
  → В REST `GET` — идемпотентен и кэшируем по умолчанию.

## Когда что выбирать?

- **Выбирайте SOAP**, если:
    - Требуется строгий контракт (финансы, госсектор),
    - Нужны встроенные стандарты (надёжная доставка, транзакции),
    - Интеграция с legacy enterprise-системами.

- **Выбирайте REST**, если:
    - API публичный или внутренний для микросервисов,
    - Важна простота, скорость и масштабируемость,
    - Достаточно HTTPS + JSON.

</details>

---

<details>
  <summary>
    <b>Production Recommendations for SOAP (Производственные рекомендации для SOAP)</b>
  </summary>

## Проектирование и контракт

- Используйте **contract-first подход**: сначала WSDL + XSD, потом код. Это гарантирует стабильность API и независимость от реализации.
- Выносите XSD из WSDL в отдельные файлы — это упрощает переиспользование типов и модульное тестирование.
- Все элементы в `Body` должны быть **глобальными** в XSD (иметь `name` на уровне схемы), чтобы на них можно было ссылаться из WSDL.

## Безопасность

- **Запретите `DOCTYPE` во всех SOAP-эндпоинтах** через фичу `"http://apache.org/xml/features/disallow-doctype-decl"`.
- Включите `FEATURE_SECURE_PROCESSING` везде, где создаётся XML-парсер (включая JAXB и JAX-WS).
- Даже при использовании HTTPS не передавайте секреты в открытом виде в `<soap:Header>` — они могут попасть в логи.

## Разработка и инструменты

- Генерируйте клиентский код через `wsimport` — не пишите обёртки вручную.
- При использовании Spring Boot явно задавайте `targetNamespace` в аннотациях — не полагайтесь на автоматическую генерацию.
- Настройте безопасные фичи парсера **один раз** на уровне фабрики (`JAXBContext`, `DocumentBuilderFactory`), а не в каждом методе.

## Тестирование

- Покрывайте три сценария: успех, `soap:Client` (ошибка клиента), `soap:Server` (ошибка сервера).
- Валидируйте входящие и исходящие сообщения против XSD — даже если сервис «работает».
- Используйте `XMLUnit` или аналоги для сравнения XML с учётом пространств имён и порядка элементов.

## Эксплуатация

- Логируйте полные SOAP-сообщения только в debug-режиме; в production — только идентификаторы запросов.
- Версионируйте WSDL через URI endpoint'а (например, `/v1/UserService?wsdl`), а не через изменение существующего контракта.
- Мониторьте размер сообщений — большие XML могут вызывать OutOfMemoryError при использовании DOM.

## Когда избегать SOAP

- Для публичных API с высокой нагрузкой — выбирайте REST/JSON.
- Для внутренних микросервисов в доверенной среде — gRPC или REST проще в эксплуатации.
- Если нет требований к строгому контракту, WS-Security или надёжной доставке.

</details>

---