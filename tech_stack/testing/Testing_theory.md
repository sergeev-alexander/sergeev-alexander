# Testing Theory

## 7 принципов тестирования

- Exhaustive testing is impossible (Исчерпывающее тестирование невозможно).
<br>Полный перебор всех возможных сценариев невозможен из-за бесконечного числа комбинаций данных и условий.

- Testing shows the presence of defects, not their absence (Тестирование демонстрирует наличие дефектов, а не их отсутствие)
<br>Тестирование может выявить ошибки, но не гарантирует их полного отсутствия в продукте.

- Absence-of-errors fallacy (Заблуждение об отсутствии ошибок)
<br>Даже после исправления многих дефектов нельзя утверждать, что продукт идеален и готов к использованию, так как требования пользователей могут различаться.

- Early testing saves time and money (Раннее тестирование сохраняет время и деньги)
<br>Чем раньше обнаружен дефект, тем дешевле и проще его исправить, предотвращая накопление проблем на поздних этапах.

- Defect clustering (Принцип скопления или кластеризация дефектов)
<br>Большинство дефектов обычно сосредоточено в небольшом количестве модулей, что требует к ним особого внимания при тестировании.

- Testing is context dependent (Тестирование зависит от контекста)
<br>Подход к тестированию зависит от типа продукта, его целей, команды, сроков и доступных инструментов, поэтому стратегия всегда адаптируется.

- Pesticide paradox (Парадокс пестицида)
<br>Повторение одних и тех же тестов со временем становится неэффективным для поиска новых дефектов, поэтому тестовые сценарии необходимо регулярно обновлять.

## ПОДХОДЫ К ТЕСТИРОВАНИЮ (Testing Approaches)

### По уровню доступа к коду/системе

- `Black Box` (Черный ящик): Тестирование без знания внутреннего устройства системы, основанное на требованиях и спецификациях.
- `White Box` (Белый ящик): Тестирование с полным знанием исходного кода (`source code`) и внутренней структуры системы.
- `Grey Box` (Серый ящик): Тестирование с частичным знанием внутреннего устройства, часто на уровне взаимодействия модулей или `API`.

### По исполнению кода

<details>
  <summary>
    <b>Static Testing (Статическое тестирование)</b>
  </summary>

> `Static Testing` (Статическое тестирование) - это анализ артефактов (код, требования, дизайн) без запуска программы.

## Основные понятия

- `Static Testing` (Статическое тестирование) - Тестирование без выполнения кода, направленное на выявление дефектов в программном обеспечении и сопроводительной документации на ранних этапах жизненного цикла.
- `Verification` (Верификация) - Процесс оценки того, соответствует ли продукт установленным требованиям на текущем этапе разработки; статическое тестирование является частью верификации.

> Верификация в тестировании ПО – процесс просмотра документации, дизайна, кода и программы для того, чтобы проверить, было ли программное обеспечение создано в соответствии с требованиями или нет. Основная цель процесса верификации – обеспечить качество приложения, дизайна, архитектуры и т.д. Процесс верификации включает в себя такие действия, как ревью, пошаговое руководство и инспекция.

## Основные типы

<details>
  <summary>
    <b>Review (Рецензирование)</b>
  </summary>

## Основные понятия

- `Review` (Рецензирование) - Статический метод анализа рабочих продуктов (документов, кода, требований) без их выполнения, направленный на выявление дефектов, улучшение качества и повышение общей осведомленности команды.
- `Static Testing` (Статическое тестирование) - Рецензирование является ключевой частью статического тестирования и проводится до этапа динамического тестирования.

## Цели рецензирования

- Выявление дефектов на ранних этапах жизненного цикла (когда их исправление дешевле).
- Повышение качества и согласованности рабочих продуктов.
- Обмен знаниями и опытом внутри команды.
- Обучение новых участников проекта.
- Улучшение коммуникации между разработчиками, тестировщиками и аналитиками.

## Типы рецензирования

### Неформальное рецензирование (`Informal Review`)
- Отсутствие строгой структуры и документации.
- Примеры: парное чтение кода, быстрая проверка коллегой, обсуждение в чате.
- Подходит для небольших изменений, гибких проектов, быстрой обратной связи.

### Формальное рецензирование (`Formal Review`)
- Строго регламентированный процесс с четкими ролями, этапами и отчетностью.
- **Основные виды**:
  - `Walkthrough` (Сквозной просмотр) - Автор ведет презентацию продукта для аудитории с целью получения отзывов.
  - `Technical Review` (Техническая оценка) - Коллективная экспертиза продукта специалистами для выявления дефектов и несоответствий.
  - `Inspection` (Инспекция) - Наиболее формальный тип, проводимый обученным модератором по заранее определенному чек-листу с фиксацией всех найденных дефектов.

## Процесс формального рецензирования

1. **Планирование** (`Planning`) - Определение целей, участников, критериев входа/выхода.
2. **Инициирование** (`Kick-off`) - Представление продукта, целей и распределение ролей.
3. **Подготовка** (`Individual Preparation`) - Участники самостоятельно изучают материал и фиксируют замечания.
4. **Обсуждение** (`Review Meeting`) - Коллективное обсуждение найденных дефектов (в некоторых форматах, например, в инспекции, может быть пропущено).
5. **Исправление** (`Rework`) - Автор вносит исправления на основе полученной обратной связи.
6. **Подтверждение** (`Follow-up`) - Проверка того, что все замечания были корректно устранены.

## Ключевые роли

- `Author` (Автор) - Создатель рабочего продукта, отвечающий за его исправление.
- `Moderator` / `Review Leader` (Модератор) - Руководит процессом, обеспечивает его соблюдение.
- `Reviewer` (Рецензент) - Участник, который анализирует продукт и находит дефекты.
- `Scribe` / `Recorder` (Секретарь) - Фиксирует все найденные дефекты и решения.

## Что подлежит рецензированию?

- Документация по требованиям (SRS, BRS)
- Дизайн-документы и архитектурные схемы
- Исходный код
- Тестовая документация (тест-кейсы, чек-листы, планы)
- Пользовательская документация (мануалы, справка)

## Преимущества для тестировщика

- Более глубокое понимание требований и бизнес-логики.
- Возможность найти дефекты до начала динамического тестирования.
- Лучшая подготовка к написанию качественных тест-кейсов.
- Укрепление взаимодействия с командой разработки и аналитиками.

## Факторы успеха

- Четко определенные цели рецензирования.
- Подготовленные и мотивированные участники.
- Качественные и доступные материалы для анализа.
- Фокус на продукте, а не на личности автора.
- Использование чек-листов и стандартов.
- Поддержка процесса со стороны менеджмента.

</details>

- `Static Analysis` (Статический анализ) - Анализ исходного кода без его выполнения для обнаружения структурных дефектов и нарушений стандартов.
  - `Data Flow Analysis` (Анализ потока данных) - Проверка корректности использования переменных (инициализация, использование, освобождение) в ходе выполнения программы.
  - `Control Flow Analysis` (Анализ потока управления) - Исследование последовательности выполнения операторов и инструкций для выявления недостижимого кода, бесконечных циклов и других аномалий.
  - `Cyclomatic Complexity` (Цикломатическая сложность) - Метрика, измеряющая количество линейно независимых путей в графе потока управления программы; используется для оценки тестируемости и поддерживаемости кода.

## Объекты статического тестирования

- `Requirements & Design Documents` (Документы требований и проектирования) - Спецификации, архитектурные схемы, модели данных.
- `Test Artifacts` (Тестовые артефакты) - Тест-кейсы, чек-листы, стратегии тестирования.
- `Source Code` (Исходный код) - Проверяется как вручную (code review), так и автоматически (статическими анализаторами).
- `UI Prototypes & Mockups` (Прототипы интерфейсов) - Эскизы и макеты пользовательского интерфейса.
- `Environment Configuration` (Параметры среды) - Настройки окружения, переменные окружения, конфигурационные файлы.
- `Test Data` (Тестовые данные) - Подготовленные наборы данных для проверки корректности их структуры и соответствия требованиям.

## Типичные дефекты, выявляемые статическим анализом

- `Unused Variables` (Неиспользуемые переменные) - Переменные, объявленные, но нигде не используемые.
- `Dead Code` (Мертвый код) - Участки кода, которые никогда не выполняются.
- `Infinite Loops` (Бесконечные циклы) - Циклы без корректного условия завершения.
- `Uninitialized Variables` (Переменные без инициализации) - Использование переменных до присвоения им значения.
- `Resource Leaks` (Утечки ресурсов) - Невысвобождаемые память, файловые дескрипторы, соединения.
- `Buffer Overflows` (Переполнение буфера) - Запись данных за пределы выделенного буфера.
- `Incomplete Error Handling` (Неполная обработка ошибок) - Отсутствие обработки возможных исключений или кодов ошибок.

## Преимущества статического тестирования 

- `Early Defect Detection` (Раннее выявление дефектов) - Обнаружение ошибок до запуска системы, что значительно снижает стоимость их исправления.
- `Process Improvement Feedback` (Обратная связь для улучшения процессов) - Выявленные дефекты помогают команде совершенствовать практики разработки и тестирования.
- `Enhanced Team Awareness` (Повышение осведомленности команды) - Участники лучше понимают качество продукта и потенциальные риски.
- `Knowledge Sharing` (Обмен знаниями) - Способствует передаче опыта и критической информации между членами команды.
- `Reduced Rework Effort` (Снижение объема переделок) - Минимизация затрат на исправление ошибок на поздних этапах разработки.

## Недостатки статического тестирования

- Процесс статического тестирования может занимать много времени, так как в основном он выполняется вручную.
- Препятствует обнаружению уязвимостей, представленных в среде выполнения.

</details>

<details>
  <summary>
    <b>Dynamic Testing (Динамическое тестирование)</b>
  </summary>

> `Dynamic Testing` (Динамическое тестирование) - Тестирование, при котором программный код исполняется для проверки его реального поведения при заданных входных данных.
> 
> `Validation` (Валидация) - Процесс подтверждения того, что продукт удовлетворяет заявленным требованиям и ожиданиям пользователей; динамическое тестирование является частью валидации.

> Валидация в разработке ПО – динамический механизм тестирования и проверки того, действительно ли программный продукт соответствует точным потребностям заказчика или нет. Этот процесс помогает гарантировать, что ПО выполняет желаемое использование в подходящей среде. Процесс валидации включает в себя такие действия, как модульное тестирование, интеграционное тестирование, системное тестирование и пользовательское приемочное тестирование.

## Методология динамического тестирования

- `Input Execution and Output Analysis` (Выполнение с входными данными и анализ выхода) - Подача заранее определённых входных данных и сравнение фактического результата с ожидаемым.
- `Real-Time Behavior Verification` (Проверка поведения в реальном времени) - Наблюдение за реакцией системы на действия пользователя или внешние события.
- `Test Execution Modes` (Режимы выполнения тестов) - Может выполняться вручную или с использованием автоматизированных средств.

## Цели и задачи динамического тестирования

- `Functional Correctness` (Функциональная корректность) - Подтверждение, что система выполняет заявленные функции правильно.
- `Non-Functional Validation` (Валидация нефункциональных характеристик) - Проверка производительности, надёжности, масштабируемости, безопасности и других качественных атрибутов.
- `Complex Defect Detection` (Обнаружение сложных дефектов) - Выявление ошибок, которые невозможно обнаружить без выполнения кода (например, гонки условий, ошибки синхронизации, проблемы с состоянием).

## Преимущества динамического тестирования

- `Comprehensive Functionality Coverage` (Полное покрытие функциональности) - Позволяет оценить систему в целом, как её воспринимает пользователь.
- `User-Centric Perspective` (Ориентация на пользователя) - Тестирование отражает реальный опыт взаимодействия с продуктом.
- `Detection of Runtime Defects` (Обнаружение ошибок времени выполнения) - Выявляет дефекты, проявляющиеся только при исполнении (например, утечки памяти, исключения).
- `Automation Support` (Поддержка автоматизации) - Широко поддаётся автоматизации с использованием специализированных фреймворков и инструментов.

## Недостатки динамического тестирования

- `High Time Consumption` (Высокая трудоёмкость) - Требует значительных временных затрат на подготовку, выполнение и анализ результатов.
- `High Cost` (Высокая стоимость) - Связано с необходимостью поддержки тестовой инфраструктуры, данных и окружений.
- `Late Defect Discovery` (Позднее обнаружение дефектов) - Обычно проводится после завершения разработки, что увеличивает стоимость исправления найденных ошибок.

</details>

## УРОВНИ ТЕСТИРОВАНИЯ (Testing Levels)

- `Unit Testing` (Модульное / Компонентное тестирование): Тестирование отдельных изолированных модулей или компонентов (обычно методов или классов) программы.
- `Integration Testing` (Интеграционное тестирование): Тестирование взаимодействия между несколькими модулями, компонентами или системами.
- `System Testing` (Системное тестирование): Тестирование полностью интегрированной системы на соответствие всем требованиям.
- `Acceptance Testing` (Приемочное тестирование): Финальное тестирование, проводимое с целью принятия решения о готовности системы к выпуску.

## ТИПЫ ТЕСТИРОВАНИЯ (Testing Types)

### По функциональности

- [`Functional Testing Types` (Типы функционального тестирования)](https://github.com/sergeev-alexander/sergeev-alexander/blob/main/tech_stack/testing/Functional_testing_types.md "Functional_testing_types.md")
  <br>
  Проверка соответствия функциональности системы заявленным требованиям.

  - [`Change-related Testing Types` (Типы тестирования основанные на изменениях)](https://github.com/sergeev-alexander/sergeev-alexander/blob/main/tech_stack/testing/Change-Related_testing_types.md "Change-Related_testing_types.md")
    <br>
    Проверка того, что недавние изменения в коде (исправления, новые функции) работают корректно и не сломали существующий функционал.

- [`Non-functional Testing Types` (Типы нефункционального тестирования)](https://github.com/sergeev-alexander/sergeev-alexander/blob/main/tech_stack/testing/Non-functional_testing_types.md "Non-functional_testing_types.md")
  <br>
  Проверка качественных характеристик системы (производительность, безопасность, удобство использования и т.д.).



### По степени автоматизации

- `Manual Testing` (Ручное тестирование): Выполнение тестовых сценариев (`test scenarios`) человеком без использования скриптов.
- `Automated Testing` (Автоматизированное тестирование): Выполнение тестов с помощью специальных программ и скриптов.

## ПРОЦЕССЫ И ЖИЗНЕННЫЕ ЦИКЛЫ

<details>
  <summary>
    <b>Software Testing Lifecycle (STLC) (Жизненный цикл тестирования ПО)</b>
  </summary>

## Основные понятия

- `Software Testing Lifecycle` (`STLC`) (Жизненный цикл тестирования ПО) - Структурированный процесс, состоящий из последовательных фаз, каждая из которых имеет четкие цели, входные и выходные критерии для обеспечения систематического и эффективного достижения целей качества.
- `Entry Criteria` (Критерии входа) - Набор условий, которые должны быть выполнены перед началом фазы, чтобы гарантировать ее результативность и избежать потери ресурсов.
- `Exit Criteria` (Критерии выхода) - Набор условий, которые должны быть выполнены для официального завершения фазы и перехода к следующей.

## Фазы STLC

### 1. Анализ требований (`Requirement Analysis`)
- **Цель**: Понимание, интерпретация и верификация требований с точки зрения тестируемости и качества.
- **Входные критерии**:
  - Документация по требованиям (BRS, SRS)
  - Описание архитектуры приложения
  - Критерии приемки
- **Выходные артефакты**:
  - `RTM` (`Requirements Traceability Matrix`) (Матрица трассируемости требований)
  - Отчет о тестируемости требований
  - Технико-экономическое обоснование автоматизации

<details>
  <summary>
    <b>Requirements Traceability Matrix (RTM) (Матрица трассируемости требований)</b>
  </summary>

## Основные понятия

- `Traceability` (Трассируемость) - Способность идентифицировать и отслеживать взаимосвязи между связанными артефактами на всех этапах жизненного цикла ПО.
- `Requirements Traceability Matrix` (`RTM`) (Матрица трассируемости требований) - Двумерная таблица, устанавливающая связи между требованиями и другими артефактами проекта (дизайном, кодом, тестами).

## Цели и преимущества RTM

- **Обеспечение полного покрытия** - Гарантирует, что каждое требование покрыто соответствующими тестами.
- **Управление изменениями** - Позволяет быстро оценить влияние изменений в требованиях на другие компоненты системы.
- **Предотвращение "золотого покрытия"** - Выявляет функциональность, которая не была запрошена заказчиком.
- **Поддержка регуляторных требований** - Обеспечивает доказательства соответствия стандартам (ISO, CMMI, FDA).
- **Упрощение сопровождения** - Ускоряет диагностику и исправление дефектов за счет быстрой навигации по связям.

## Виды трассируемости

- `Vertical Traceability` (Вертикальная трассируемость) - Отслеживание требования через уровни разработки: от бизнес-требования к пользовательскому, системному, дизайну, коду и тестам.
- `Horizontal Traceability` (Горизонтальная трассируемость) - Связь между артефактами одного уровня, например, между требованиями и тестовой документацией.
- `Forward Traceability` (Прямая трассируемость) - Отслеживание от требований к реализации и тестам ("куда ведет это требование?").
- `Backward Traceability` (Обратная трассируемость) - Отслеживание от реализации или тестов к исходным требованиям ("откуда взялся этот код/тест?").
- `Bi-Directional Traceability` (Двунаправленная трассируемость) - Комбинация прямой и обратной трассируемости для полного контроля.

## Структура RTM

Типичная матрица включает следующие столбцы:
- Идентификатор требования
- Описание требования
- Источник требования
- Приоритет / Критичность
- Ссылка на дизайн / архитектуру
- Ссылка на модуль кода / репозиторий
- Идентификаторы связанных тест-кейсов
- Статус покрытия (Полное / Частичное / Отсутствует)
- Статус реализации

## Применение на этапах SDLC

- **Сбор требований** - Создание первоначальной структуры матрицы.
- **Проектирование** - Связывание требований с архитектурными решениями.
- **Разработка** - Привязка требований к конкретным модулям и единицам кода.
- **Тестирование** - Обеспечение покрытия каждого требования тестами и отслеживание результатов.
- **Внедрение и поддержка** - Использование матрицы для анализа инцидентов и планирования улучшений.

## Лучшие практики

- **Раннее создание** - Начинать заполнение RTM сразу после фиксации требований.
- **Живой документ** - Поддерживать матрицу в актуальном состоянии на протяжении всего проекта.
- **Использование инструментов** - Применять специализированные системы управления требованиями (Jira, IBM DOORS, ReqSuite, TestRail).
- **Интеграция с процессами** - Включать обновление RTM в стандартные рабочие процессы команды.
- **Регулярный аудит** - Проводить проверки полноты и корректности связей.

## Владение и ответственность

- **Основной владелец** - Бизнес-аналитик или менеджер продукта.
- **Участники** - Архитекторы, разработчики, тестировщики.
- **Аудиторы** - В организациях с высоким уровнем зрелости (CMMI) — команда TQM или QA.

</details>

### 2. Планирование тестирования (`Test Planning`)
- **Цель**: Определение стратегии, подхода, ресурсов, инструментов и графика для достижения целей тестирования.
- **Входные критерии**:
  - Утвержденные требования
  - Матрица RTM
  - Отчет о возможности автоматизации
- **Выходные артефакты**:
  - `Test Strategy` (Тестовая стратегия)
  - `Test Plan` (План тестирования)
  - Оценка трудозатрат на тестирование

### 3. Разработка тестовой документации (`Test Case Development`)
- **Цель**: Создание детальных инструкций (тест-кейсов и скриптов) для проверки функциональности в соответствии с требованиями.
- **Входные критерии**:
  - Обновленная документация по требованиям
  - План тестирования
  - Матрица RTM
- **Выходные артефакты**:

<details>
  <summary>
    <b>Test Case (Тест-кейс)</b>
  </summary>

## Основные понятия

> `Test Case` — структурированный документ, предназначенный для проверки соответствия функциональности системы требованиям. 
> 
> Содержит предусловия, входные данные, последовательность шагов, ожидаемый результат и постусловия.

## Цели и задачи

- Обеспечение воспроизводимости тестирования.
- Верификация реализации требований.
- Поддержка аудита и трассируемости.
- Упрощение передачи знаний внутри команды.

## Типы тест-кейсов

- **Позитивные** — проверяют корректную работу системы при вводе валидных данных.
- **Негативные** — проверяют корректную обработку невалидных или нестандартных данных, включая срабатывание механизмов валидации.

## Структура тест-кейса

1. **Предусловия** — начальное состояние системы, необходимое для выполнения теста.
2. **Входные данные** — значения, используемые в ходе выполнения теста.
3. **Шаги** — последовательность действий, выполняемых тестировщиком или автоматизированным скриптом.
4. **Ожидаемый результат** — чётко определённое поведение системы после выполнения шагов.
5. **Постусловия** — конечное состояние системы после завершения теста.

## Лучшие практики

- Атомарность: один тест-кейс — одна проверяемая логическая единица.
- Независимость: тест-кейсы не должны зависеть друг от друга.
- Ясность: формулировки должны быть однозначными и легко читаемыми.
- Поддерживаемость: тест-кейсы должны регулярно актуализироваться при изменении требований.
- Полнота покрытия: набор тест-кейсов должен включать как позитивные, так и негативные сценарии, включая граничные случаи.

</details>

  - Тестовые скрипты (для автоматизированного тестирования)
  - Подготовленные тестовые данные

### 4. Настройка тестовой среды (`Test Environment Setup`)
- **Цель**: Создание и конфигурирование стабильной и репрезентативной среды для выполнения тестов.
- **Входные критерии**:
  - План тестирования
  - Смоук-тесты
  - Тестовые данные
- **Выходные артефакты**:
  - Готовая и проверенная тестовая среда
  - Результаты смоук-тестирования
  - Документация по настройке окружения

### 5. Выполнение тестов (`Test Execution`)
- **Цель**: Проведение тестов, регистрация результатов и управление дефектами.
- **Входные критерии**:
  - Готовая тестовая среда
  - Утвержденные тест-кейсы и/или скрипты
  - Подготовленные тестовые данные
- **Выходные артефакты**:
  - Отчет о выполнении тестов
  - Дефект-репорты (баг-репорты)
  - Обновленная матрица RTM

### 6. Завершение тестового цикла (`Test Cycle Closure`)
- **Цель**: Формализация итогов тестирования, анализ эффективности процесса и выработка рекомендаций для будущих проектов.
- **Входные критерии**:
  - Завершенное тестирование
  - Все результаты тестирования собраны
  - Нет открытых критических дефектов
- **Выходные артефакты**:
  - `Test Closure Report` (Отчет о завершении тестирования)
  - Метрики тестирования (покрытие, плотность дефектов, эффективность и т.д.)
  - Отчет об уроках, извлеченных из проекта (`Lessons Learned`)

<details>
  <summary>
    <b>Test Completion Criteria (Критерии завершения тестирования)</b>
  </summary>

## Основные понятия

- `Test Completion Criteria` (Критерии завершения тестирования) - Заранее определённый набор условий, выполнение которых сигнализирует о том, что цели тестирования достигнуты и дальнейшее тестирование нецелесообразно или не требуется.

## Ключевые критерии завершения

- `Planned Test Execution` (Выполнение запланированных тестов) - Все тест-кейсы из утверждённого тестового набора (включая функциональные, нефункциональные и регрессионные) успешно пройдены.
- `Coverage Thresholds Met` (Достижение пороговых значений покрытия) - Покрытие соответствует установленным целевым показателям:
  - `Requirements Coverage` (Покрытие требований) - Все функциональные и нефункциональные требования протестированы.
  - `Code Coverage` (Покрытие кода) - Достигнут целевой процент покрытия (например, по строкам, ветвлениям, путям).
  - `Risk Coverage` (Покрытие рисков) - Протестированы все области с высоким и средним уровнем риска.
- `Defect Convergence` (Сходимость дефектов) - Количество новых найденных дефектов за единицу времени стабильно снижается, что указывает на стабилизацию качества.
- `Zero Critical/Blocker Defects` (Отсутствие критических/блокирующих дефектов) - В системе не осталось дефектов, которые делают продукт непригодным для использования или нарушают ключевые бизнес-процессы.
- `Acceptable Defect Backlog` (Приемлемый бэклог дефектов) - Все оставшиеся дефекты имеют низкий или средний приоритет, их влияние оценено, и принято осознанное решение об их отложении.
- `Stakeholder Approval` (Утверждение заинтересованными сторонами) - Заказчик, менеджмент или другие ключевые стейкхолдеры официально подтверждают готовность продукта к выпуску.
- `Exit Criteria Fulfillment` (Выполнение критериев выхода) - Все условия, определённые в тест-плане как необходимые для завершения фазы тестирования, выполнены.

## Факторы, влияющие на решение

- `Project Timeline & Deadlines` (Сроки проекта) - Достижение жёстких дедлайнов может быть весомым аргументом для завершения, даже если не все цели достигнуты.
- `Budget Constraints` (Бюджетные ограничения) - Исчерпание выделенных ресурсов при достижении приемлемого уровня качества.
- `Risk-Based Decision` (Решение на основе рисков) - Окончательное решение принимается после взвешивания оставшихся рисков против выгоды от дальнейшего тестирования.
- `Regression Stability` (Стабильность регрессии) - Новые изменения не вызывают появления новых дефектов в уже протестированных областях.

## Важные принципы

- `Defined in Test Plan` (Определены в тест-плане) - Критерии завершения должны быть чётко сформулированы и согласованы на этапе планирования, а не определяться спонтанно.
- `Quantifiable and Measurable` (Измеримы и количественны) - Критерии должны быть объективными и проверяемыми (например, «95% тестов пройдено», а не «почти все тесты пройдены»).
- `Not Just "All Tests Passed"` (Не только «все тесты пройдены») - Прохождение тестов — лишь один из факторов; важно также учитывать качество самих тестов, покрытие и контекст проекта.

</details>

## Отличие от SDLC

- `SDLC` (`Software Development Lifecycle`) (Жизненный цикл разработки ПО) фокусируется на создании продукта: сбор требований, проектирование, разработка, внедрение.
- `STLC` является неотъемлемой частью SDLC, но его фокус — на верификации и валидации: анализ требований, планирование проверки, выполнение тестов и подтверждение качества.

</details>

<details>
  <summary>
    <b>Defects and Errors (Дефекты и ошибки)</b>
  </summary>

## Основные термины (ISTQB)

- `Error` (Ошибка) - Действие человека, которое приводит к неправильному результату.
- `Defect` / `Fault` / `Bug` (Дефект / Недочет / Баг) - Изъян в компоненте или системе, который может привести к невозможности выполнить требуемую функцию. Термины используются как синонимы.
- `Failure` (Отказ / Сбой) - Отклонение компонента или системы от ожидаемого результата, наблюдаемое при выполнении.

## Классификация дефектов

### По источнику возникновения
- `Requirements Defects` (Дефекты требований) - Двусмысленность, противоречия, неполнота в спецификациях.
- `Design Defects` (Дефекты проектирования) - Ошибки в архитектуре, алгоритмах, логике взаимодействия компонентов.
- `Coding Defects` (Дефекты кодирования) - Синтаксические, логические ошибки, проблемы с обработкой данных, управлением памятью.
- `Testing Defects` (Дефекты тестирования) - Ошибки в тест-кейсах, тестовых данных или тестовой обвязке.

### По типу проявления
- `Functional Defects` (Функциональные дефекты) - Нарушение бизнес-логики или требований.
- `UI/UX Defects` (Дефекты интерфейса) - Проблемы с отображением, навигацией, удобством использования.
- `Performance Defects` (Дефекты производительности) - Медленная работа, утечки памяти, низкая пропускная способность.
- `Security Defects` (Дефекты безопасности) - Уязвимости, позволяющие несанкционированный доступ или действия.
- `Compatibility Defects` (Дефекты совместимости) - Проблемы на разных платформах, браузерах, устройствах.
- `Localization Defects` (Дефекты локализации) - Ошибки перевода, форматирования дат/валют, культурные несоответствия.

## Ключевые концепции

- `Bug Leakage` (Утечка дефектов) - Ситуация, когда дефект не был обнаружен на этапе тестирования и найден конечным пользователем в production-среде.
- `Bug Release` (Выпуск с дефектами) - Осознанное решение выпустить продукт с известными, но низкоприоритетными дефектами, которые задокументированы в release notes.
- `Defect Masking` (Маскировка дефектов) - Случай, когда один дефект скрывает другой, не позволяя ему проявиться.
- `Latent Defect` (Скрытый дефект) - Существующий в системе дефект, который еще не вызвал отказа из-за отсутствия подходящих условий для его проявления.
- `Defect Triage` (Сортировка дефектов) - Процесс приоритизации дефектов на основе их серьезности (`Severity`), срочности (`Priority`), риска и влияния на бизнес.
- `Fault Seeding` (Подсев дефектов) - Намеренное внесение известных дефектов в систему для оценки эффективности процесса тестирования.

## Severity vs Priority

- `Severity` (Серьезность) - Техническое влияние дефекта на систему:
  - `Critical` / `Blocker`: Система неработоспособна.
  - `Major` / `High`: Основная функция нарушена.
  - `Minor` / `Medium`: Второстепенная функция нарушена.
  - `Trivial` / `Low`: Косметические ошибки (опечатки, цвета).
- `Priority` (Приоритет) - Бизнес-срочность исправления:
  - `Urgent` / `High`: Исправить немедленно.
  - `Medium`: Исправить в ближайшем релизе.
  - `Low`: Исправить, когда будет время.

## Жизненный цикл дефекта (Defect Life Cycle)

- `New` (Новый) - Дефект зарегистрирован тестировщиком.
- `Assigned` (Назначен) - Дефект подтвержден и передан команде разработки.
- `Open` (Открыт) - Разработчик анализирует и работает над исправлением.
- `Fixed` (Исправлен) - Разработчик внёс изменения и проверил их.
- `Pending Retest` (Ожидает повторного тестирования) - Исправление готово к верификации.
- `Retest` (Повторное тестирование) - Тестировщик проверяет исправление.
- `Verified` (Проверен) - Дефект успешно устранён.
- `Closed` (Закрыт) - Цикл завершён.
- `Reopen` (Переоткрыт) - Дефект не устранён и возвращается на доработку.
- `Rejected` (Отклонён) - Разработчик не согласен, что это дефект.
- `Duplicate` (Дубликат) - Такой дефект уже зарегистрирован.
- `Deferred` (Отложен) - Исправление перенесено на будущий релиз.
- `Not a Bug` (Не является багом) - Поведение соответствует требованиям, даже если кажется нелогичным.

## Отладка (Debugging) vs Тестирование (Testing)

- `Testing` (Тестирование) - Процесс выявления дефектов путем выполнения программного обеспечения.
- `Debugging` (Отладка) - Процесс анализа, локализации и устранения причины дефекта, обнаруженного в ходе тестирования. Выполняется разработчиком.

</details>

## МЕТОДОЛОГИИ И ТЕХНИКИ ТЕСТИРОВАНИЯ

<details>
  <summary>
    <b>Test-Design technics (Техники тест-дизайна)</b>
  </summary>

> Тест-дизайн – это этап процесса тестирования ПО, на котором проектируются и создаются тест-кейсы, в соответствии с определёнными ранее критериями качества и целями тестирования.

## Ключевые концепции:

- Тест-аналитик: Определяет "Что тестировать?".
- Тест-дизайнер: Определяет "Как тестировать?".
- Тестовое покрытие (`Test Coverage`): Метрика, оценивающая полноту тестирования.
  - Покрытие требований (`Requirements Coverage`): Оценка по трассировке тестов к функциональным требованиям.
  - Покрытие кода (`Code Coverage`): Оценка по проценту исполненного кода в тестах.

## Классификация техник тест-дизайна (по источнику знаний)

1.  **Методы чёрного ящика (Black-box, спецификационные):** Фокусируются на поведении системы (вход -> выход) без знания внутреннего устройства.
2.  **Методы белого ящика (White-box, структурные):** Основаны на знании внутренней структуры кода, логики программы. (Требуют навыков программирования. *В вашем текущем блоке отсутствуют, стоит добавить ключевые*).
3.  **Методы, основанные на опыте (Experience-based):** Используют знания и интуицию тестировщиков, пользователей, экспертов.

## Основные техники тест-дизайна:

### Методы чёрного ящика (Black-box):

<details>
  <summary>
    <b>Equivalence Partitioning & Boundary Value Analysis (Эквивалентное разбиение и анализ граничных значений)</b>
  </summary>

## Основные понятия

- `Equivalence Partitioning` (`EP`) (Эквивалентное разбиение) - Техника чёрного ящика, при которой входные данные делятся на группы (классы эквивалентности), где все значения в группе ожидаются вызывать одинаковое поведение системы.
- `Boundary Value Analysis` (`BVA`) (Анализ граничных значений) - Техника тестирования, фокусирующаяся на проверке значений на границах классов эквивалентности, так как ошибки чаще всего возникают именно на границах.

## Принципы эквивалентного разбиения

- **Валидные классы** - Наборы входных данных, которые должны быть приняты системой.
- **Невалидные классы** - Наборы входных данных, которые должны быть отклонены системой.
- **Одно значение на класс** - Достаточно протестировать одно значение из каждого класса, так как все значения в классе считаются эквивалентными.

## Принципы анализа граничных значений

- **Минимум и максимум** - Проверяются минимальное и максимальное допустимые значения.
- **Границы +1 и -1** - Проверяются значения, непосредственно примыкающие к границам с обеих сторон (например, min-1, min, min+1, max-1, max, max+1).
- **Применимость** - Используется для любых упорядоченных типов данных: числа, даты, строки (по длине).

## Когда применять

- При наличии **ограничений на входные данные** (диапазоны, списки, форматы).
- Для **поля ввода с четкими правилами валидации**.
- На **любом уровне тестирования** (модульном, интеграционном, системном).
- В сочетании с другими техниками тест-дизайна для повышения покрытия.

## Алгоритм применения

1. **Определить все входные параметры** тестируемой функции.
2. **Выделить классы эквивалентности** для каждого параметра (валидные и невалидные).
3. **Определить граничные значения** для каждого класса.
4. **Создать тест-кейсы**:
  - По одному значению из каждого класса эквивалентности.
  - Все граничные значения и их соседи.
5. **Оптимизировать набор тестов**, удаляя дублирующиеся или избыточные проверки.

## Преимущества

- **Снижение количества тестов** - Значительно уменьшает объем тестовых данных без потери качества.
- **Фокус на рисках** - Концентрирует внимание на наиболее уязвимых местах (границах).
- **Простота и эффективность** - Легко понимается и применяется даже начинающими тестировщиками.
- **Систематический подход** - Обеспечивает структурированное и полное покрытие требований.

## Примеры классов эквивалентности

- **Числовые диапазоны**: [1-10] → валидный, [≤0], [11-99], [≥100] → невалидные.
- **Длина строки**: [6-10 символов] → валидная, [0-5], [11+] → невалидные.
- **Списки выбора**: Выбранный элемент из списка → валидный, ввод несуществующего значения → невалидный.
- **Форматы данных**: Корректный email → валидный, некорректный формат → невалидный.

## Лучшие практики

- Всегда использовать **BVA вместе с EP** для максимальной эффективности.
- Учитывать **специфические бизнес-правила**, которые могут создавать дополнительные классы.
- Проверять **комбинации входных параметров** с помощью других техник (например, таблиц решений), если параметры взаимозависимы.
- Документировать **логику выделения классов** для обеспечения прозрачности и прослеживаемости.

</details>

<details>
  <summary>
    <b>Decision Table Testing (Таблицы решений / Принятия решений): Формализация бизнес-логики, где комбинации входных условий (причин) определяют выходные действия (следствия). Более формализованная и полная версия Cause/Effect</b>
  </summary>

## Основные понятия

- `Decision Table` (Таблица решений) - Техника чёрного ящика для проектирования тестов, основанная на анализе комбинаций входных условий и соответствующих им действий или выходных результатов.
- `Combinatorial Testing` (Комбинаторное тестирование) - Подход, направленный на проверку различных комбинаций входных параметров для выявления сложных дефектов.

## Когда применять

- В бизнес-логике присутствуют **сложные правила**, зависящие от нескольких условий.
- Требования описывают **разные исходы** в зависимости от комбинации факторов.
- Необходимо обеспечить **полное покрытие** всех возможных сценариев принятия решений.
- Примеры: расчет скидок, определение тарифов, валидация форм с множеством зависимых полей, обработка заказов.

## Структура таблицы решений

1. **Condition Stubs** (Заголовки условий) - Список входных условий или предпосылок.
2. **Condition Entries** (Входные значения условий) - Комбинации значений (обычно "Да/Нет", "Истина/Ложь", "0/1").
3. **Action Stubs** (Заголовки действий) - Список возможных системных реакций или выходных результатов.
4. **Action Entries** (Выходные значения действий) - Указание, какое действие выполняется при каждой комбинации условий.

## Алгоритм построения

1. **Идентифицировать все условия** из требований.
2. **Определить все возможные действия** системы.
3. **Рассчитать количество комбинаций**: N = V₁ × V₂ × ... × Vₙ, где V — количество значений для каждого условия.
4. **Построить таблицу** и заполнить колонки всеми уникальными комбинациями условий.
5. **Определить действия** для каждой комбинации на основе бизнес-правил.
6. **Оптимизировать таблицу**:
  - Удалить невозможные или противоречивые комбинации.
  - Объединить столбцы с одинаковыми результатами.
  - Уточнить неоднозначные случаи у аналитиков.

## Преимущества

- **Полнота покрытия** - Гарантирует, что не будет упущена ни одна логическая комбинация.
- **Наглядность** - Сложная логика представляется в простой и структурированной форме.
- **Простота преобразования в тест-кейсы** - Каждый столбец таблицы напрямую соответствует одному тест-кейсу.
- **Универсальность** - Может быть реализована с помощью любых табличных инструментов (Excel, Google Sheets).

## Недостатки

- **Экспоненциальный рост** - При большом количестве условий число комбинаций становится непрактичным (проблема "комбинаторного взрыва").
- **Трудоёмкость** - Требует значительных временных затрат на анализ и построение.
- **Не подходит для простых сценариев** - Избыточна для линейных процессов с одним или двумя условиями.

## Лучшие практики

- Использовать технику **парного тестирования** (`Pairwise Testing`) для сокращения числа комбинаций при большом количестве входных параметров.
- Активно сотрудничать с **бизнес-аналитиками** для уточнения правил и устранения неоднозначностей.
- Интегрировать таблицы решений в **спецификации требований** как живую документацию.
- Рассматривать каждую строку таблицы как **спецификацию для автоматизированного теста**.

</details>

<details>
  <summary>
    <b>State Transition Testing (Тестирование перехода состояний)</b>
  </summary>

## Основные понятия

- `State Transition Testing` (Тестирование перехода состояний) - Техника чёрного ящика, используемая для тестирования систем, поведение которых зависит от текущего состояния и изменяется в ответ на события или входные данные.
- `State` (Состояние) - Условие или ситуация, в которой система находится в определённый момент времени.
- `Transition` (Переход) - Изменение состояния системы в ответ на событие или входное воздействие.
- `State Transition Diagram` (`STD`) (Диаграмма переходов состояний) - Визуальное представление всех возможных состояний системы и допустимых переходов между ними.
- `Event` (Событие) - Внешний или внутренний триггер, вызывающий переход между состояниями.

## Когда применять

- Система имеет **конечное число чётко определённых состояний**.
- Поведение системы **зависит от последовательности событий**, а не только от текущего ввода.
- Требования описывают **реакцию на события** в зависимости от текущего состояния.
- Примеры: авторизация (логин/логаут), заказ (создан → оплачен → отправлен → доставлен), лифт, игровой персонаж, конечные автоматы.

## Ключевые элементы диаграммы

- **Состояния** - Обозначаются прямоугольниками или закруглёнными блоками.
- **Начальное состояние** - Указывается стрелкой без источника.
- **Конечное состояние** - Может быть обозначено двойным кругом или специальным маркером.
- **Переходы** - Стрелки между состояниями, подписанные событием и/или действием (например, «Ввести пароль → Проверить»).
- **Условия перехода** - Логические выражения, определяющие, при каких условиях происходит переход.

## Подходы к тестированию

- **Покрытие всех состояний** - Убедиться, что каждое состояние может быть достигнуто.
- **Покрытие всех переходов** - Проверить каждый допустимый переход между состояниями.
- **Покрытие всех путей** - Протестировать все возможные последовательности переходов (часто ограничивают длину из-за комбинаторного взрыва).
- **Тестирование недопустимых переходов** - Попытаться выполнить переход, который не разрешён в текущем состоянии (например, повторный вход без выхода).

## Алгоритм создания тестов

1. **Анализ требований** для выявления состояний и событий.
2. **Построение диаграммы состояний** с указанием всех переходов.
3. **Создание таблицы состояний** (State Table) для формализации модели.
4. **Генерация тест-кейсов**:
  - Для каждого допустимого перехода
  - Для недопустимых переходов (негативные тесты)
  - Для граничных условий и исключительных ситуаций
5. **Оптимизация набора тестов** путем объединения в цепочки переходов.

## Преимущества

- **Наглядность** - Сложная логика состояний легко визуализируется.
- **Полнота** - Помогает выявить пропущенные или некорректные переходы.
- **Фокус на поведении** - Соответствует реальному пользовательскому опыту, где действия выполняются последовательно.
- **Раннее выявление дефектов** - Многие ошибки логики состояний обнаруживаются ещё на этапе проектирования диаграммы.

## Недостатки

- **Сложность при большом числе состояний** - Диаграмма становится громоздкой и трудной для анализа.
- **Не подходит для статических систем** - Неэффективна для систем, где состояние не играет ключевой роли.
- **Требует точных требований** - Необходимо чёткое понимание всех возможных состояний и событий.

## Лучшие практики

- Создавать диаграмму **совместно с аналитиками и разработчиками**.
- Использовать **стандартные нотации** (например, UML State Machine Diagrams).
- Интегрировать диаграммы в **спецификации требований** как живую документацию.
- Автоматизировать тесты на основе диаграммы, особенно для критических бизнес-процессов.
- Регулярно **обновлять диаграмму** при изменении бизнес-логики.

</details>

- `Use Case Testing` (Тестирование на основе сценариев использования): Тестирование типичных пользовательских сценариев (use cases) для проверки, удовлетворяет ли система своим целям и задачам.

### Методы белого ящика (White-box):
- `Statement Coverage` (Покрытие операторов/инструкций): Каждая строка кода должна быть выполнена хотя бы один раз.
- `Branch/Decision Coverage` (Покрытие ветвей/условий): Каждая возможная ветвь (true/false) в управляющих структурах (if, switch, циклы) должна быть выполнена хотя бы один раз.
- `Path Coverage` (Покрытие путей): Проверка всех возможных уникальных путей выполнения через блок кода. Часто нереализуемо на практике из-за комбинаторного взрыва.

### Методы, основанные на опыте (Experience-based):
- `Error Guessing` - `EG` (Предугадывание Ошибки): Использование опыта тестировщика, интуиции и знания системы для предположения о потенциальных дефектах и создание тестов под эти сценарии.
- `Exploratory Testing` - `ET` (Исследовательское тестирование): Одновременное изучение системы, проектирование тестов и их выполнение. Активность тестирования управляется идеями тестировщика, а не заранее написанными тест-кейсами.
- `Checklist-Based Testing` (Тестирование на основе чек-листов): Использование списка контрольных пунктов (чек-листа) для направления тестовой активности, но без строго прописанных шагов.

## Техники оптимизации и комбинирования:

<details>
  <summary>
    <b>Pairwise Testing (Попарное тестирование)</b>
  </summary>

## Основные понятия

- `Pairwise Testing` (Попарное тестирование) - Техника комбинаторного тестирования, основанная на предположении, что большинство дефектов вызывается взаимодействием значений **двух** параметров, а не всей их совокупности.
- `Combinatorial Testing` (Комбинаторное тестирование) - Общий класс методов, направленных на проверку различных комбинаций входных параметров.
- `All-Pairs Testing` (Тестирование всех пар) - Синоним попарного тестирования.

## Принцип работы

Вместо тестирования **всех возможных комбинаций** (что приводит к экспоненциальному росту числа тестов), попарное тестирование генерирует минимальный набор тестовых случаев, в котором **каждая возможная пара значений любых двух параметров встречается хотя бы один раз**.

### Пример

Допустим, у нас есть 3 параметра:
- Браузер: Chrome, Firefox, Safari
- ОС: Windows, macOS, Linux
- Язык: EN, RU

**Полный перебор**: 3 × 3 × 2 = **18 тестов**  
**Попарное тестирование**: ~**9–12 тестов** (в зависимости от алгоритма), при этом каждая пара (Браузер-ОС, Браузер-Язык, ОС-Язык) покрыта полностью.

## Когда применять

- При наличии **многих входных параметров** с несколькими значениями.
- Когда **полный перебор** непрактичен из-за времени или ресурсов.
- Для **конфигурационного тестирования** (разные ОС, браузеры, устройства).
- При **тестировании форм** с множеством зависимых полей.
- В **API-тестировании** с большим числом параметров запроса.

## Преимущества

- **Значительное сокращение** количества тест-кейсов (часто на 70–90%).
- **Высокая эффективность** — обнаруживает до 90% дефектов, вызванных взаимодействием двух параметров.
- **Ускорение** как создания, так и выполнения тестов.
- **Снижение затрат** на тестирование без существенной потери качества.
- **Лучшее покрытие**, чем случайный или интуитивный выбор тестов.

## Недостатки

- **Не гарантирует** обнаружение дефектов, вызванных взаимодействием **трёх и более** параметров.
- **Требует специальных инструментов** для генерации оптимальных наборов (вручную сложно).
- Может быть **избыточным** для простых систем с малым числом параметров.

## Популярные инструменты

- **PICT** (Microsoft) — консольный генератор тестовых наборов.
- **AllPairs** — простой скрипт для генерации попарных комбинаций.
- **Hexawise** — коммерческий инструмент с визуальным интерфейсом и расширенными возможностями.
- **TestRail**, **Xray**, **qTest** — системы управления тестами с поддержкой интеграции попарного тестирования.

## Лучшие практики

- Использовать **только после анализа требований** — не все параметры взаимодействуют.
- Исключать **несовместимые комбинации** (например, Safari на Windows).
- Комбинировать с **анализом граничных значений** и **эквивалентным разбиением**.
- Применять **иерархию приоритетов** — критические параметры можно тестировать с покрытием троек (`3-wise`).
- Интегрировать в **CI/CD pipeline** для автоматического генерирования и запуска тестов.

## Расширения метода

- `N-wise Testing` — обобщение метода для N параметров (например, 3-wise, 4-wise).
- `Orthogonal Arrays` (Ортогональные массивы) — математический подход к построению сбалансированных наборов комбинаций.
- `Risk-Based Pairwise Testing` — фокус на парах параметров с высоким риском.

</details>

- `Exhaustive Testing` (Исчерпывающее Тестирование): Теоретическая техника, предполагающая проверку ВСЕХ возможных комбинаций входных данных. На практике неприменима для нетривиальных систем.

</details>

<details>
  <summary>
    <b>Risk-based Testing (Тестирование на основе рисков)</b>
  </summary>

## Основные понятия

- `Risk-based Testing` (`RBT`) (Тестирование на основе рисков) - Методология, при которой объем, глубина и приоритеты тестирования определяются на основе анализа потенциальных рисков для продукта и проекта.
- `Risk Assessment` / `Risk Analysis` (Оценка / Анализ рисков) - Процесс идентификации, анализа и приоритизации рисков для определения их потенциального воздействия и вероятности возникновения.

## Основные категории рисков

- `Product Risks` / `Quality Risks` (Риски продукта / Риски качества) - Риски, связанные непосредственно с качеством и характеристиками разрабатываемого продукта (например, дефекты, уязвимости, низкая производительность).
- `Project Risks` (Риски проекта) - Риски, связанные с управлением и реализацией проекта (например, срывы сроков, превышение бюджета, нехватка квалифицированных ресурсов).

## Ключевые виды рисков продукта (Product Risks)

- `Functional Risks` (Функциональные риски) - Риск некорректной реализации или невыполнения ключевых функций продукта, что делает его непригодным для использования.
- `Security Risks` (Риски безопасности) - Риск наличия уязвимостей, которые могут привести к утечке данных, несанкционированному доступу или атакам на систему.
- `Performance Risks` (Риски производительности) - Риск, что система не будет соответствовать требованиям по скорости, времени отклика, стабильности или масштабируемости под нагрузкой.
- `Technical Risks` / `Architectural Risks` (Технические / Архитектурные риски) - Риски, вызванные сложностью, новизной технологий, ошибками в проектировании или интеграцией со сторонними системами.
- `Usability & UX Risks` (Риски удобства использования) - Риск создания продукта с плохим пользовательским интерфейсом, что приведет к неудовлетворенности и оттоку пользователей.
- `Compliance & Legal Risks` (Риски соответствия / Правовые риски) - Риск несоответствия продукта законодательным нормам, отраслевым стандартам или лицензионным соглашениям.

## Ключевые виды рисков проекта (Project Risks)

- `Schedule & Time Risks` (Риски графика) - Риск срыва сроков релиза из-за переоценки возможностей, изменения требований или технических сложностей.
- `Budget & Financial Risks` (Бюджетные / Финансовые риски) - Риск превышения бюджета проекта из-за доработок, увеличения команды или внешних факторов.
- `Resource & People Risks` (Ресурсные / Кадровые риски) - Риск, связанный с нехваткой, недостаточной квалификацией или текучестью членов команды (тестировщиков, разработчиков).
- `Requirements & Scope Risks` (Риски требований / Объема работ) - Риск нечетких, постоянно меняющихся или противоречивых требований, ведущих к непониманию и ошибкам.

## Процесс и практики

- `Risk Priority Number` (`RPN`) (Приоритетное число риска) - Числовая оценка риска, часто рассчитываемая как произведение его Вероятности (Probability) и Влияния (Impact).
- `Risk Mitigation` (Смягчение рисков) - Действия, направленные на снижение вероятности возникновения риска или минимизацию его негативных последствий.
- `Test Prioritization` (Приоритизация тестирования) - Распределение усилий по тестированию: высокоприоритетные тесты покрывают области с наибольшим уровнем риска.
- `Residual Risk` (Остаточный риск) - Риск, который остается после применения всех запланированных мер по его смягчению. Осознанное решение, принимаемое заинтересованными сторонами.

</details>

<details>
  <summary>
    <b>Root Cause Analysis (RCA) (Анализ первопричин)</b>
  </summary>

## Основные понятия

- `Root Cause Analysis` (`RCA`) (Анализ первопричин) - Систематический подход к выявлению фундаментальных (корневых) причин инцидентов, дефектов или сбоев с целью их устранения и предотвращения повторного возникновения.
- `Incident` (Инцидент) - Любое нежелательное событие, нарушающее нормальное функционирование системы (например, сбой в production, утечка данных, критический баг).

## Цели и значение RCA

- `Prevent Recurrence` (Предотвращение повторения) - Главная цель — не просто исправить проявление проблемы, а устранить её источник, чтобы она больше не возникала.
- `Improve Quality` (Повышение качества) - Устранение системных недостатков напрямую ведет к повышению надежности и стабильности продукта.
- `Enhance Processes` (Совершенствование процессов) - Выявленные причины часто указывают на слабые места в процессах разработки, тестирования или эксплуатации, что дает возможность их улучшить.
- `Reduce Costs` (Снижение затрат) - Решение проблемы на корню гораздо дешевле, чем постоянная борьба с её последствиями.

## Процесс проведения RCA (5 этапов)

1. **Определение проблемы и её влияния**  
   Четко сформулируйте, что пошло не так, и оцените воздействие на бизнес-цели (финансы, репутация, пользователи).

2. **Поиск вероятных причин**  
   Проведите мозговой штурм или используйте структурированные методы (например, диаграмму Исикавы) для генерации списка потенциальных причин.

3. **Сбор информации и анализ**  
   Соберите данные (логи, метрики, отчеты, свидетельства), чтобы подтвердить или опровергнуть каждую из вероятных причин.

4. **Причинно-следственный анализ**  
   Используйте техники вроде «5 Почему» или FMEA, чтобы углубиться от симптомов к истинной первопричине.

5. **Разработка и внедрение решений**  
   Выберите наиболее эффективные корректирующие и превентивные действия, назначьте ответственных и сроки, а затем отслеживайте их эффективность.

## Преимущества RCA

- Создает культуру ответственности и непрерывного улучшения.
- Повышает прозрачность и предсказуемость процессов разработки.
- Снижает количество инцидентов в production-среде.
- Повышает доверие клиентов и заинтересованных сторон к продукту и команде.

## Когда проводить RCA

- После критических сбоев в production.
- При обнаружении повторяющихся или хронических дефектов.
- В рамках ретроспективы спринта или завершения проекта.
- При значительном отклонении от плановых показателей качества или сроков.

</details>