# API

API (Application Programming Interface) — это контракт между различными программными компонентами, который определяет, как они могут взаимодействовать. 

Он описывает набор доступных методов и данных, которые одна программа может запросить у другой, не вдаваясь в детали её внутренней реализации. 

Проще говоря, это посредник, который позволяет приложениям общаться друг с другом, соблюдая строгие правила.

## API Architectural Styles 

Стиль проектирования API - это набор ограничений и принципов, определяющих, как компоненты системы взаимодействуют друг с другом через интерфейсы. 

Стиль задаёт:

- как передаются запросы и ответы,
- как идентифицируются ресурсы,
- является ли взаимодействие синхронным или асинхронным,
- как обрабатываются ошибки,
- какие форматы данных используются и т.д.

| Стиль                                     | Архитектурные принципы                                                                                                                                                                                                                     | Модель взаимодействия                                                                                                  | Контракт / Спецификация                                                                                               | Тип данных и сериализация                                                        | Поддержка в Java-экосистеме                                                                                   | Типичные сценарии использования                                                                                                               | Производительность                                     | Безопасность                                            |
|:------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:-----------------------------------------------------------------------------------------------------------------------|:----------------------------------------------------------------------------------------------------------------------|:---------------------------------------------------------------------------------|:--------------------------------------------------------------------------------------------------------------|:----------------------------------------------------------------------------------------------------------------------------------------------|:-------------------------------------------------------|:--------------------------------------------------------|
| REST<br>(Representational State Transfer) | Архитектурный стиль, основанный на ограничениях Роя Филдинга: client-server, stateless, cacheable, uniform interface, layered system, code-on-demand (опционально). Опирается на ресурсы, идентифицируемые URI, и стандартные HTTP-методы. | Синхронный запрос–ответ (request–response). Клиент инициирует взаимодействие.                                          | Неформальный или частично формализованный (OpenAPI/Swagger). Нет строгого контракта времени компиляции.               | Обычно JSON или XML (текстовые, человекочитаемые).                               | Spring Boot (WebMvc/WebFlux), JAX-RS (Jersey, RESTEasy), Micronaut, Quarkus.                                  | Публичные веб-API, мобильные бэкенды, CRUD-сервисы, интеграции с фронтендом.                                                                  | Средняя (текстовые форматы, HTTP overhead)             | HTTPS, OAuth 2.0, JWT, API Keys                         |
| RPC<br>(Remote Procedure Call)            | Клиент вызывает функцию/метод на удалённом сервере как будто она локальная. Стиль фокусируется на операциях, а не на ресурсах. Часто нарушает uniform interface REST.                                                                      | Синхронный или асинхронный запрос–ответ. Может поддерживать streaming (в современных реализациях).                     | Строгий контракт: определяется в IDL (Interface Definition Language), например .proto (Protocol Buffers) или .thrift. | Бинарные форматы: Protocol Buffers (gRPC), Apache Thrift, или JSON (в JSON-RPC). | gRPC-Java, Spring gRPC, Apache Thrift, JSON-RPC (библиотеки вроде jsonrpc4j).                                 | Внутренние микросервисы с высокой нагрузкой, low-latency системы, когда важна производительность и чёткость контракта.                        | Высокая (бинарные форматы, HTTP/2)                     | TLS, mTLS, токены аутентификации                        |
| GraphQL                                   | Запрос-ориентированный стиль: клиент отправляет запрос с описанием желаемой структуры данных, сервер возвращает ровно это. Инверсия контроля — сервер предоставляет "граф возможностей", клиент выбирает, что запрашивать.                 | Синхронный запрос–ответ (обычно поверх HTTP POST). Поддерживает подписки (subscriptions) через WebSocket (асинхронно). | Схема типов (GraphQL Schema) — строгая, но динамически исполняемая. Контракт проверяется при выполнении.              | JSON (всегда). Запрос и ответ — структурированные JSON-объекты.                  | DGS (Netflix), GraphQL Java, Spring for GraphQL, Quarkus GraphQL.                                             | Фронтенды с разнообразными требованиями к данным (web/mobile), когда нужно избежать over-fetching/under-fetching.                             | Средняя (риск N+1 проблемы, сложность кеширования)     | HTTPS, авторизация на уровне полей, rate limiting       |
| Event-driven / Messaging                  | Взаимодействие через асинхронную передачу событий. Основано на паттернах Pub/Sub или Message Queue. Сервисы слабо связаны (loose coupling), часто используют CQRS или Event Sourcing.                                                      | Асинхронное, однонаправленное. Нет немедленного ответа. Возможны retry, dead-letter queues, ordering guarantees.       | Контракт — событийная схема (Avro, JSON Schema, Protobuf). Часто версионируется.                                      | JSON, Avro, Protobuf, XML — в зависимости от брокера и требований.               | Spring Boot + Kafka/RabbitMQ, Quarkus + SmallRye, Project Reactor, Vert.x, Jakarta Messaging (JMS).           | Микросервисы с высокой отказоустойчивостью, обработка в реальном времени, аудит, аналитика, Saga-транзакции.                                  | Высокая (асинхронность, батчинг)                       | Шифрование сообщений, SASL, ACL брокера                 |
| SOAP<br>(Simple Object Access Protocol)   | Строгий, стандартизированный протокол (не стиль), основанный на XML и WSDL. Поддерживает WS-* расширения (безопасность, транзакции, надёжная доставка).                                                                                    | Синхронный запрос–ответ (иногда one-way).                                                                              | WSDL — машинно-читаемый формальный контракт. Контракт создаётся до реализации (contract-first).                       | XML (тяжёлый, многословный).                                                     | Apache CXF, Spring Web Services, JAX-WS (встроено до Java 11), Metro.                                         | Legacy enterprise-интеграции (банки, госуслуги), где требуется формальная спецификация, ACID-транзакции на уровне протокола, или WS-Security. | Низкая (XML overhead, сложность парсинга)              | WS-Security, WS-Trust, цифровые подписи                 |
| Webhooks                                  | Push-based механизм: сервер уведомляет клиент, отправляя HTTP-запрос на его endpoint при наступлении события. Это обратный вызов (callback) по HTTP.                                                                                       | Асинхронный, но запрос инициирует сервер. Клиент должен предоставить публичный endpoint.                               | Неформальный. Часто задокументирован в виде JSON-примеров.                                                            | Обычно JSON, иногда form-encoded.                                                | Реализуется вручную через Spring Web (как обычный контроллер) + HTTP-клиент (OkHttp, WebClient) для отправки. | Интеграции с внешними провайдерами (Stripe, GitHub, Slack), когда polling неэффективен.                                                       | Высокая (push-модель, нет polling)                     | HTTPS, подписи HMAC, IP whitelist                       |
| WebSockets                                | Полнодуплексная связь поверх TCP. Постоянное соединение между клиентом и сервером для real-time коммуникации.                                                                                                                              | Асинхронный, двунаправленный. Сервер и клиент могут инициировать отправку сообщений в любое время.                     | Неформальный. Обычно определяется протоколом приложения поверх WebSocket.                                             | JSON, бинарные данные, текст — любые форматы.                                    | Spring WebSocket, Java-WebSocket, Netty, Vert.x.                                                              | Real-time приложения: чаты, игры, live-обновления, торговые терминалы.                                                                        | Очень высокая (минимальный overhead после handshake)   | WSS (WebSocket Secure), токены в заголовках             |
| Server-Sent Events (SSE)                  | Однонаправленный поток данных от сервера к клиенту поверх HTTP. Сервер "толкает" обновления клиенту в real-time.                                                                                                                           | Асинхронный, однонаправленный (только сервер → клиент). Автоматическое переподключение.                                | Стандарт W3C. Простой текстовый протокол с полями data, event, id, retry.                                             | Текстовые данные (обычно JSON в поле data).                                      | Spring WebFlux, SseEmitter, Reactor, RxJava.                                                                  | Live-обновления UI, уведомления, мониторинг, новостные ленты.                                                                                 | Высокая (HTTP keep-alive, меньше overhead чем polling) | HTTPS, CORS, авторизация через query params или headers |