# Аннотации

Аннотация в Java - это метаинформация для компилятора / JVM / библиотек.

Аннотации используются для:

1. Указания для компилятора: Например, `@Override` сообщает компилятору, что метод должен переопределять метод родителя. 
Если это не так, компилятор выдаст ошибку.
2. Обработка во время компиляции: Генерация дополнительного кода (например, логгеров, билдеров) на основе аннотаций.
Это делают такие инструменты, как Lombok (`@Data`, `@Getter`).
3. Обработка во время выполнения (Runtime): 
С помощью Рефлексии (Reflection API) программа может прочитать аннотации и, в зависимости от них, изменить свое поведение. 
Именно так работают фреймворки Spring, Hibernate, JUnit.
<br>
Spring: `@Autowired`
<br>
JUnit: `@Test`
<br>
Hibernate: `@Entity`

## Встроенные аннотации

<details>
    <summary>
        <b>Базовые аннотации</b>
    </summary>

- `@Override` - Указывает, что метод переопределяет метод родительского класса.
- `@Deprecated` - Помечает класс, метод или поле как устаревший.
@Deprecated(since = "версия", forRemoval = true/false)
- `@SuppressWarnings` - Инструмент для подавления предупреждений компилятора.
Популярные значения: `"unchecked"`, `"deprecation"`, `"rawtypes"`.
- `@FunctionalInterface` - Указывает, что интерфейс является функциональным (имеет ровно один абстрактный метод).
```java
@FunctionalInterface
interface Calculator {
    int calculate(int a, int b); // единственный абстрактный метод
    
    // Можно иметь default методы
    default void printResult(int result) {
        System.out.println("Result: " + result);
    }
}

// Использование с лямбдой
Calculator add = (a, b) -> a + b;
System.out.println(add.calculate(5, 3)); // 8
```
- `@SafeVarargs` - Подавляет предупреждения о небезопасных операциях с varargs параметрами универсального типа.
```java
public class SafeVarargsExample {
    
    // Без @SafeVarargs компилятор выдаст предупреждение
    @SafeVarargs
    public final <T> void printItems(T... items) {
        for (T item : items) {
            System.out.println(item);
        }
    }
    
    public static void main(String[] args) {
        SafeVarargsExample example = new SafeVarargsExample();
        example.printItems("Hello", "World"); // Работает без предупреждений
    }
}
```

### Аннотации из javax.annotation (часто используются в Jakarta EE)
- `@Generated` - Указывает, что код был сгенерирован инструментом, а не написан вручную
```java
@Generated(value = "com.example.CodeGenerator", 
           date = "2023-10-27T10:00:00",
           comments = "Generated by automated tool")
public class GeneratedClass {
    // Этот класс сгенерирован автоматически
}
```

- `@PostConstruct` и `@PreDestroy` - Управление жизненным циклом бинов.
```java
import javax.annotation.*;

public class DatabaseService {
    
    @PostConstruct
    public void init() {
        System.out.println("Инициализация соединения с БД");
        // Вызывается после создания бина и инъекции зависимостей
    }
    
    public void queryData() {
        System.out.println("Выполнение запроса к БД");
    }
    
    @PreDestroy
    public void cleanup() {
        System.out.println("Закрытие соединения с БД");
        // Вызывается перед уничтожением бина
    }
}
```

### Аннотации для сериализации

- `@Serial` и `@Transient` (Java 14+) - Альтернативы `serialVersionUID` и `transient` для более строгой проверки.

`@Serial` предназначен для:
- `serialVersionUID`
- Методов сериализации (writeObject, readObject, etc.)
- Только для полей/методов, которые участвуют в сериализации

Когда вы помечаете поле/метод @Serial, компилятор проверяет:

- Для `serialVersionUID`:
  - Поле должно быть `static final long`
  - Должно называться точно `serialVersionUID`

- Для методов сериализации:
  - Сигнатура должна точно совпадать с ожидаемой
  - Например: `private void writeObject(ObjectOutputStream)`

- Для полей:
  - Поле должно быть сериализуемым (НЕ `transient`)

`@Transient` / `transient` означает:
- Это поле не участвует в сериализации
- Компилятор и JVM должны игнорировать это поле при сериализации

```java
import java.io.*;

public class User implements Serializable {

    @Serial // serialVersionUID участвует в сериализации
    private static final long serialVersionUID = 1L;

    private String username;  // Сериализуется автоматически
    private String email;     // Сериализуется автоматически

    @Transient // поле НЕ сериализуется
    private String temporaryData;

    // Альтернатива:
    private transient String sessionData; // используем transient

    @Serial // метод участвует в сериализации
    private void writeObject(ObjectOutputStream out) throws IOException {
        out.defaultWriteObject();
        // Можно добавить кастомную логику сериализации
    }

    @Serial // метод участвует в десериализации
    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
        in.defaultReadObject();
        // Можно добавить кастомную логику десериализации
    }
}
```

### Аннотации для документации (для JavaDoc):

- `@param` - документирование параметров
- `@return` - документирование возвращаемого значения
- `@throws` / @exception - документирование исключений
- `@see` - ссылка на другую документацию
- `@since` - версия, в которой появился элемент
- `@version` - версия класса
- `@author` - автор кода

```java
/**
 * Калькулятор для базовых математических операций
 * @author Иванов Иван
 * @version 1.1
 * @since 1.0
 */
public class Calculator {

    /**
     * Складывает два числа
     * @param a первое слагаемое
     * @param b второе слагаемое
     * @return сумма a и b
     * @throws IllegalArgumentException если a или b отрицательные
     * @see #subtract(int, int)
     */
    public int add(int a, int b) throws IllegalArgumentException {
        if (a < 0 || b < 0) {
            throw new IllegalArgumentException("Numbers must be positive");
        }
        return a + b;
    }
}
```

### Аннотации для проверки nullability `@Nullable` и `@NonNull` (из различных библиотек)

```java
import org.springframework.lang.NonNull;
import org.springframework.lang.Nullable;

public class UserService {
    
    public void createUser(@NonNull String username, @Nullable String email) {
        // username не может быть null (IDE и инструменты проверят)
        // email может быть null
        
        if (username == null) {
            throw new IllegalArgumentException("Username cannot be null");
        }
        
        System.out.println("Creating user: " + username);
        if (email != null) {
            System.out.println("Email: " + email);
        }
    }
}
```

Преимущества использования:
- Раннее обнаружение ошибок - IDE показывает проблемы сразу
- Самодокументирующийся код - ясно видно, что может быть null
- Улучшенная поддержка IDE - автодополнение, подсказки, рефакторинг
- Снижение количества NPE - многие ошибки обнаруживаются до запуска

Ограничения:
- Только статический анализ - во время выполнения проверок нет
- Зависит от инструментов - не все IDE/анализаторы поддерживают одинаково
- Не заменяет валидацию - для пользовательского ввода всё равно нужны проверки


### Аннотации для многопоточности

- `@GuardedBy` (из java.util.concurrent.locks) - Указывает, какой монитор защищает поле или метод.

`@GuardedBy` — это аннотация из библиотеки `JCIP` (Java Concurrency in Practice), которая указывает, какой монитор (lock) защищает доступ к полю или методу. 
Это документация для разработчиков, а не функциональная проверка.

`@GuardedBy("this")` - защита монитором текущего объекта:
```java
import net.jcip.annotations.*;

public class ThreadSafeCounter {
    
    @GuardedBy("this") // 'this' ссылается на текущий экземпляр ThreadSafeCounter
    private int count = 0; // Защищено монитором экземпляра классса ThreadSafeCounter

    // synchronized метод использует монитор ТЕКУЩЕГО объекта (this)
    public synchronized void increment() {
        count++; // Защищено synchronized (this)
    }

    // synchronized метод использует монитор ТЕКУЩЕГО объекта (this)
    public synchronized int getCount() {
        return count; // Защищено synchronized (this)
    }

    // Альтернатива @GuardedBy("this") - synchronized блок с явным указанием this
    public void increment() {
        synchronized(this) { // Явно указываем монитор - this
            count++;
        }
    }
}
```

`@GuardedBy("lock")` - защита явным lock полем:
```java
public class LockProtected {
    private final Object lock = new Object(); // Монитор

    @GuardedBy("lock")
    private int value;

    public void updateValue() {
        synchronized(lock) { // Соответствует аннотации
            value++;
        }
    }
}
```

`@GuardedBy("ClassName.lock")` - защита статическим lock:
```java
public class GlobalCounter {
    private static final Object STATIC_LOCK = new Object();
    
    @GuardedBy("GlobalCounter.STATIC_LOCK")
    private static int globalCount = 0;
    
    public static void increment() {
        synchronized(STATIC_LOCK) { // ✅
            globalCount++;
        }
    }
}
```

`@GuardedBy("fieldName")` - защита другим полем-монитором:
```java
public class SmartResource {

    // Разные мониторы для разных целей
    private final Object dataLock = new Object();
    private final Object metadataLock = new Object();

    @GuardedBy("dataLock")
    private List<String> data = new ArrayList<>();

    @GuardedBy("metadataLock")
    private int accessCount = 0;

    // Операции с данными - не блокируют операции со статистикой
    public void addData(String item) {
        synchronized(dataLock) {
            data.add(item);
        }
        // Не блокируем metadataLock здесь - параллелизм!
    }

    public void recordAccess() {
        synchronized(metadataLock) {
            accessCount++; // Быстрая операция
        }
        // Не блокируем dataLock
    }

    // Комплексная операция - блокирует всё
    public void complexOperation(String item) {
        synchronized(dataLock) {
            synchronized(metadataLock) {
                data.add(item);
                accessCount++;
            }
        }
    }
}
```

В production-коде часто предпочтительнее использовать приватные final-мониторы для лучшей инкапсуляции и избежания проблем с внешними блокировками:
```java
// Production-ready подход:
public class ProductionCounter {
    
    private final Object lock = new Object(); // Приватный монитор
   
    @GuardedBy("lock")
    private int count = 0;
    
    public void increment() {
        synchronized(lock) {
            count++;
        }
    }
}
```
</details>

<details>
    <summary>
        <b>Bean Validation API (javax.validation / jakarta.validation).</b>
    </summary>

### Базовые аннотации для строк
`@NotNull` - проверяет, что значение не null:
```java
public class User {
    
    @NotNull(message = "Имя не может быть null")
    private String username;
    
    // Использование:
    // User user = new User();
    // user.setUsername(null); // ❌ ValidationException
}
```

`@NotEmpty` - проверяет, что строка/коллекция не null и не пуста:
```java
public class User {
    
    @NotEmpty(message = "Email не может быть пустым")
    private String email;
    
    @NotEmpty(message = "Список ролей не может быть пустым")
    private List<String> roles;
    
    // Использование:
    // user.setEmail("");     // ❌ ValidationException
    // user.setRoles(new ArrayList<>()); // ❌ ValidationException  
}
```

`@NotBlank` - проверяет, что строка не null и не состоит из пробелов:
```java
public class User {
    
    @NotBlank(message = "Пароль не может быть пустым или состоять из пробелов")
    private String password;
    
    // Использование:
    // user.setPassword(null);    // ❌ ValidationException
    // user.setPassword("");      // ❌ ValidationException
    // user.setPassword("   ");   // ❌ ValidationException
    // user.setPassword("12345"); // ✅ OK
}
```

### Аннотации для чисел

`@Min` / `@Max` - минимальное/максимальное значение:
```java
public class Product {
    
    @Min(value = 0, message = "Цена не может быть отрицательной")
    private BigDecimal price;
    
    @Max(value = 150, message = "Возраст не может превышать 150 лет")
    private Integer age;
    
    // Использование:
    // product.setPrice(new BigDecimal("-10")); // ❌ ValidationException
    // product.setAge(200); // ❌ ValidationException
}
```

`@DecimalMin` / `@DecimalMax` - для BigDecimal и String:
```java
public class Account {
    
    @DecimalMin(value = "0.0", inclusive = false, message = "Баланс должен быть положительным")
    private BigDecimal balance;
    
    @DecimalMax(value = "1000000", message = "Сумма не может превышать 1,000,000")
    private String maxAmount;
    
    // Использование:
    // account.setBalance(BigDecimal.ZERO); // ❌ ValidationException (inclusive=false)
}
```

`@Positive` / `@PositiveOrZero` - положительные числа:
```java
public class Order {
    
    @Positive(message = "Количество должно быть положительным")
    private Integer quantity;
    
    @PositiveOrZero(message = "Скидка не может быть отрицательной")
    private BigDecimal discount;
    
    // Использование:
    // order.setQuantity(-5); // ❌ ValidationException
    // order.setDiscount(new BigDecimal("-10")); // ❌ ValidationException
}
```

`@Negative` / `@NegativeOrZero` - отрицательные числа:
```java
public class Temperature {
    
    @Negative(message = "Температура замерзания должна быть отрицательной")
    private Integer freezingPoint;
    
    @NegativeOrZero(message = "Изменение не может быть положительным")
    private BigDecimal delta;
}
```

`@Digits` - проверка цифр (целая и дробная части):
```java
public class Money {
    @Digits(integer = 6, fraction = 2, message = "Сумма должна иметь максимум 6 целых и 2 дробных цифры")
    private BigDecimal amount;
    
    // Использование:
    // money.setAmount(new BigDecimal("1234567.12")); // ❌ 7 целых цифр
    // money.setAmount(new BigDecimal("12345.123"));  // ❌ 3 дробных цифры
    // money.setAmount(new BigDecimal("12345.12"));   // ✅ OK
}
```

### Аннотации для дат

`@Past` / `@PastOrPresent` - прошедшие даты:
```java
public class Person {
    
    @Past(message = "Дата рождения должна быть в прошлом")
    private LocalDate birthDate;
    
    @PastOrPresent(message = "Дата создания не может быть в будущем")
    private LocalDateTime createdAt;
    
    // Использование:
    // person.setBirthDate(LocalDate.now().plusDays(1)); // ❌ ValidationException
}
```

`@Future` / `@FutureOrPresent` - будущие даты:
```java
public class Event {
    
    @Future(message = "Дата события должна быть в будущем")
    private LocalDate eventDate;
    
    @FutureOrPresent(message = "Дата начала не может быть в прошлом")
    private ZonedDateTime startTime;
    
    // Использование:
    // event.setEventDate(LocalDate.now().minusDays(1)); // ❌ ValidationException
}
```

`@Size` - размер строки/коллекции/массива:
```java
public class RegistrationForm {
    
    @Size(min = 2, max = 50, message = "Имя должно быть от 2 до 50 символов")
    private String firstName;
    
    @Size(min = 1, max = 10, message = "Максимум 10 телефонных номеров")
    private List<String> phoneNumbers;
    
    @Size(min = 6, message = "Пароль должен содержать минимум 6 символов")
    private char[] password;
    
    // Использование:
    // form.setFirstName("A"); // ❌ Слишком короткое
    // form.setPhoneNumbers(List.of("1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11")); // ❌ Слишком много
}
```

`@Range` - комбинация `@Min` и `@Max` (из Hibernate Validator):
```java
public class Product {
    @Range(min = 1, max = 100, message = "Рейтинг должен быть от 1 до 100")
    private Integer rating;
    
    // Эквивалентно:
    // @Min(1) @Max(100)
    // private Integer rating;
}
```

### Аннотации для паттернов и форматов

`@Pattern` - регулярные выражения
```java
public class User {
    
    @Pattern(regexp = "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$", 
             message = "Некорректный формат email")
    private String email;
    
    @Pattern(regexp = "\\+7\\d{10}", message = "Телефон должен быть в формате +7XXXXXXXXXX")
    private String phone;
    
    // Использование:
    // user.setEmail("invalid-email"); // ❌ ValidationException
    // user.setPhone("89991234567");   // ❌ ValidationException (нет +7)
}
```

`@Email` - валидация email (из Hibernate Validator)
```java
public class Contact {
    
    @Email(message = "Некорректный формат email адреса")
    private String email;
    
    // Более удобная альтернатива @Pattern для email
}
```

### Специальные аннотации

`@AssertTrue` / `@AssertFalse` - булевые проверки
```java
public class Registration {
    
    @AssertTrue(message = "Необходимо принять условия соглашения")
    private Boolean termsAccepted;
    
    @AssertFalse(message = "Пользователь не должен быть заблокирован")
    private Boolean isBanned;
    
    // Также работает с методами:
    @AssertTrue(message = "Пароли должны совпадать")
    public boolean isPasswordConfirmed() {
        return password != null && password.equals(confirmPassword);
    }
}
```

`@Valid` - каскадная валидация
```java
public class Order {
    
    @NotNull
    @Valid // Валидирует вложенный объект
    private User user;
    
    @NotEmpty
    @Valid // Валидирует каждый элемент коллекции
    private List<OrderItem> items;
}

public class OrderItem {
    
    @NotBlank
    private String productName;
    
    @Min(1)
    private Integer quantity;
}
```

### Аннотации для денежных величин

`@Currency` - валидация валюты (из Hibernate Validator)
```java
public class Money {
    
    @Currency(value = {"USD", "EUR", "RUB"})
    private Currency currency;
    
    // Использование:
    // money.setCurrency(Currency.getInstance("CNY")); // ❌ ValidationException
}
```

### Полный пример использования
```java
// import javax.validation.constraints.*;

public class UserRegistrationDto {
    
    @NotBlank(message = "Имя пользователя обязательно")
    @Size(min = 3, max = 20, message = "Имя пользователя должно быть от 3 до 20 символов")
    private String username;

    @NotBlank(message = "Email обязателен")
    @Email(message = "Некорректный формат email")
    private String email;

    @NotBlank(message = "Пароль обязателен")
    @Size(min = 8, message = "Пароль должен содержать минимум 8 символов")
    @Pattern(regexp = "^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z]).*$", 
             message = "Пароль должен содержать цифры, строчные и заглавные буквы")
    private String password;

    @Min(value = 18, message = "Возраст должен быть не менее 18 лет")
    @Max(value = 120, message = "Возраст должен быть не более 120 лет")
    private Integer age;

    @Past(message = "Дата рождения должна быть в прошлом")
    private LocalDate birthDate;

    @AssertTrue(message = "Необходимо принять условия использования")
    private Boolean termsAccepted;

    // Конструкторы, геттеры, сеттеры
}

@RestController
@RequestMapping("/api/users")
public class UserController {

    @PostMapping
    public ResponseEntity<?> createUser(@Valid @RequestBody UserRegistrationDto userDto) {
        // Если валидация не пройдена - автоматически возвращается 400 Bad Request
        // с детализацией ошибок

        userService.createUser(userDto);
        return ResponseEntity.ok("Пользователь создан");
    }
}

@ControllerAdvice
public class GlobalExceptionHandler {
    
    // Обработчик ошибок валидации
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Map<String, String>> handleValidationExceptions(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        
        ex.getBindingResult().getAllErrors().forEach(error -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });
        
        return ResponseEntity.badRequest().body(errors);
    }
}
```
</details>

## Кастомные аннотации

<details>
    <summary>
        <b>Базовый синтаксис</b>
    </summary>

Объявление аннотации:
```java
// Объявляем нашу аннотацию
public @interface MyFirstAnnotation {
}
```

Использование:
```java
@MyFirstAnnotation
public class MyClass {
}
```
</details>

<details>
    <summary>
        <b>Элементы аннотации (Параметры)</b>
    </summary>

Аннотации могут иметь элементы, которые работают как методы. Они делают аннотации гибкими:
```java
public @interface Author {
    String name();             // Обязательный элемент
    String date();             // Еще один обязательный элемент
    int version() default 1;   // Элемент со значением по умолчанию (необязательный)
}
```

Использование:
```java
@Author(name = "Алексей", date = "2023-10-27") // version не указан, будет = 1
class MyService { }

@Author(name = "Мария", date = "2023-11-15", version = 2)
class AnotherService { }
```

Специальный элемент value: Если у аннотации только один элемент, и он называется value, его можно указывать без имени:
```java
public @interface Schedule {
    String value(); // Специальный элемент value
}
```

Использование:
```java
@Schedule("daily") // Вместо @Schedule(value = "daily")
class Task { }
```
</details>

<details>
    <summary>
        <b>Жизненный цикл аннотации: @Retention</b>
    </summary>

`@Retention` определяет, когда аннотация будет доступна.
- `RetentionPolicy.SOURCE` — Аннотация существует только в исходном коде. 
Она отбрасывается компилятором и не попадает в `.class` файл. 
<br>
Пример: `@Override`, `@SuppressWarnings`. 
<br>
Нужны только на этапе компиляции.

- `RetentionPolicy.CLASS` (Значение по умолчанию) - Аннотация записывается в `.class` файл, но недоступна во время выполнения JVM. 
<br>
Используется редко.

- `RetentionPolicy.RUNTIME` — Аннотация записывается в `.class` файл и доступна во время выполнения через Рефлексию. 
<br>
Это то, что нужно для Spring, Hibernate, JUnit.

```java
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

@Retention(RetentionPolicy.RUNTIME) // Ключевая строка! Без нее аннотация "исчезнет" при запуске.
public @interface MyRuntimeAnnotation {
    String data();
}
```
</details>

<details>
    <summary>
        <b>Целевые объекты: @Target</b>
    </summary>

Эта аннотация (мета-аннотация, т.е. аннотация для аннотаций) указывает, к каким элементам кода можно применять нашу аннотацию.

```java
import java.lang.annotation.ElementType;
import java.lang.annotation.Target;

@Target({ElementType.TYPE, ElementType.METHOD}) // Можно вешать на классы и методы
public @interface MyAnnotation {
    String value();
}
```

Популярные значения ElementType:

- `TYPE` — классы, интерфейсы, перечисления.
- `FIELD` — поля класса.
- `METHOD` — методы.
- `PARAMETER` — параметры методов.
- `CONSTRUCTOR` — конструкторы.
</details>

<details>
    <summary>
        <b>Кастомные аннотации валидации</b>
    </summary>

### Создание аннотации валидации

```java
// Аннотация
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = AdultValidator.class)
public @interface Adult {
    String message() default "Пользователь должен быть совершеннолетним";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
    int value() default 18; // Минимальный возраст
}

// Валидатор с обработкой violations
public class AdultValidator implements ConstraintValidator<Adult, LocalDate> {
    private int minAge;
    private String message;

    @Override
    public void initialize(Adult constraintAnnotation) {
        this.minAge = constraintAnnotation.value();
        this.message = constraintAnnotation.message();
    }

    @Override
    public boolean isValid(LocalDate birthDate, ConstraintValidatorContext context) {
        if (birthDate == null) {
            return true; // null обрабатывается @NotNull
        }

        int age = Period.between(birthDate, LocalDate.now()).getYears();

        if (age >= minAge) {
            return true;
        }

        // создание constraint violation
        context.disableDefaultConstraintViolation();
        context.buildConstraintViolationWithTemplate(message)
                .addConstraintViolation();

        return false;
    }
}
```

Ключевые моменты:
- Всегда используйте addConstraintViolation() для кастомных сообщений
- disableDefaultConstraintViolation() отключает стандартное сообщение
- addPropertyNode() указывает к какому полю относится ошибка
- Можно добавлять несколько violations в одном валидаторе
- Возвращайте false только после добавления всех violations

### Группы валидации

Преимущества групп валидации:
- Гибкость - разные сценарии валидации для одного объекта
- Переиспользование - один DTO для multiple use cases
- Производительность - проверяем только нужные поля
- Чистота кода - не нужно создавать множество DTO классов
- Семантическая ясность - явно указываем контекст валидации

Группы валидации особенно полезны в REST API, где разные endpoints требуют разной степени проверки одних и тех же данных.

Определение групп:
```java
// Группы - это просто маркерные интерфейсы (без методов)
public interface BasicInfo {}    // Для базовой информации
public interface FullInfo {}     // Для полной информации
public interface AdminInfo {}    // Для административных данных

// Можно наследовать группы
public interface Registration extends BasicInfo {}
public interface ProfileUpdate extends BasicInfo, FullInfo {}
```

Применение к полям класса:
```java
public class User {
    
    // Обязательно всегда - без группы (валидируется всегда)
    @NotBlank(message = "ID пользователя обязателен")
    private String id;
    
    // Базовая информация - проверяется при регистрации
    @NotBlank(groups = BasicInfo.class, message = "Имя пользователя обязательно")
    private String username;

    // Базовая информация - проверяется при регистрации
    @Email(groups = BasicInfo.class, message = "Некорректный email")
    private String email;
    
    // Полная информация - проверяется при заполнении профиля
    @Size(min = 10, groups = FullInfo.class, message = "Адрес должен быть не менее 10 символов")
    private String address;

    // Полная информация - проверяется при заполнении профиля
    @Pattern(regexp = "\\+7\\d{10}", groups = FullInfo.class, 
             message = "Телефон должен быть в формате +7XXXXXXXXXX")
    private String phone;
    
    // Административная информация - только для админов
    @AssertTrue(groups = AdminInfo.class, message = "Пользователь должен быть верифицирован")
    private Boolean verified;

    // Административная информация - только для админов
    @Min(value = 1, groups = AdminInfo.class, message = "Уровень доступа должен быть положительным")
    private Integer accessLevel;
    
    // Конструкторы, геттеры, сеттеры

    Validator validator = Validation.buildDefaultValidatorFactory().getValidator();

    // Валидируем только BasicInfo группу
    Set<ConstraintViolation<User>> violations = validator.validate(user, BasicInfo.class);

    System.out.println("=== BasicInfo Validation ===");
    for (ConstraintViolation<User> violation : violations) {
        System.out.println(violation.getPropertyPath() + ": " + violation.getMessage());
    }

    // Валидируем несколько групп
    Set<ConstraintViolation<User>> violations = validator.validate(user, BasicInfo.class, FullInfo.class);

    System.out.println("=== BasicInfo + FullInfo Validation ===");
    for (ConstraintViolation<User> violation : violations) {
        System.out.println(violation.getPropertyPath() + ": " + violation.getMessage());
    }

    Set<ConstraintViolation<User>> violations = validator.validate(user,
            BasicInfo.class, FullInfo.class, AdminInfo.class);

    System.out.println("=== All Groups Validation ===");
    for (ConstraintViolation<User> violation : violations) {
        System.out.println(violation.getPropertyPath() + ": " + violation.getMessage());
    }
}
```

### Практическое использование в Spring Boot

Группы в DTO:
```java
public class UserDto {
    public interface OnCreate {}
    public interface OnUpdate {}
    
    @Null(groups = OnCreate.class, message = "ID должен быть null при создании")
    @NotNull(groups = OnUpdate.class, message = "ID обязателен при обновлении")
    private Long id;
    
    @NotBlank(groups = OnCreate.class, message = "Имя обязательно при создании")
    private String name;
    
    @Email(groups = {OnCreate.class, OnUpdate.class})
    private String email;
}
```

Использование в Controller с `@Validated`:
```java
@RestController
@RequestMapping("/api/users")
@Validated
public class UserController {
    
    // Создание пользователя - только OnCreate группа
    @PostMapping
    public ResponseEntity<?> createUser(@Validated(UserDto.OnCreate.class) @RequestBody UserDto userDto) {
        
        // Валидируются только поля с groups = OnCreate.class
        userService.create(userDto);
        
        return ResponseEntity.ok("Пользователь создан");
    }
    
    // Обновление пользователя - только OnUpdate группа  
    @PutMapping("/{id}")
    public ResponseEntity<?> updateUser(
            @PathVariable Long id, 
            @Validated(UserDto.OnUpdate.class) @RequestBody UserDto userDto) {
        
        // Валидируются только поля с groups = OnUpdate.class
        userDto.setId(id);
        userService.update(userDto);
        
        return ResponseEntity.ok("Пользователь обновлен");
    }
}
```

Каскадная валидация с группами:
```java
public class OrderDto {
    
    public interface BasicValidation {}
    public interface FullValidation {}
    
    @NotBlank(groups = BasicValidation.class)
    private String orderNumber;
    
    @Valid
    @NotNull(groups = BasicValidation.class)
    private UserDto user;
    
    @Valid
    @NotEmpty(groups = FullValidation.class)
    private List<OrderItemDto> items;
}

public class UserDto {
    
    @NotBlank(groups = OrderDto.BasicValidation.class)
    private String name;
    
    @Email(groups = OrderDto.FullValidation.class)
    private String email;
}

// Валидация:
validator.validate(order, OrderDto.BasicValidation.class);
// Проверит: orderNumber, user (и name внутри UserDto)
// НЕ проверит: items, email
```

Наследование групп:
```java
public interface BasicInfo {}
public interface ContactInfo extends BasicInfo {} // Наследует BasicInfo
public interface FullInfo extends ContactInfo {}  // Наследует ContactInfo и BasicInfo

public class User {
    
    @NotBlank(groups = BasicInfo.class)
    private String username;
    
    @Email(groups = ContactInfo.class) 
    private String email; // Автоматически включает BasicInfo
    
    @Size(min = 10, groups = FullInfo.class)
    private String address; // Автоматически включает BasicInfo и ContactInfo
}

// Валидация:
validator.validate(user, FullInfo.class);
// Проверит ВСЕ поля: username, email, address
```

Группы по умолчанию:
```java
public class User {
    
    // Без groups - валидируется всегда (группа по умолчанию)
    @NotBlank
    private String id;
    
    // С группой - валидируется только когда указана группа
    @Email(groups = BasicInfo.class)
    private String email;
}

// Валидация без указания групп - только поля без groups
Set<ConstraintViolation<User>> violations = validator.validate(user);
// Проверит только: id
// НЕ проверит: email
```

Последовательность групп (GroupSequence):
```java
// Определяем порядок валидации
@GroupSequence({BasicInfo.class, FullInfo.class, AdminInfo.class})
public interface CompleteValidation {}

public class User {
    
    @NotBlank(groups = BasicInfo.class)
    private String username;
    
    @Size(min = 10, groups = FullInfo.class)  
    private String address;
    
    @Min(value = 1, groups = AdminInfo.class)
    private Integer level;
}

// Валидация останавливается на первой неудачной группе
Set<ConstraintViolation<User>> violations = validator.validate(user, CompleteValidation.class);
// Если BasicInfo fails - FullInfo и AdminInfo НЕ проверяются!
```

Обработка ошибок с группами:
```java
@ControllerAdvice
public class ValidationExceptionHandler {
    
    @ExceptionHandler(ConstraintViolationException.class)
    public ResponseEntity<Map<String, String>> handleValidationException(ConstraintViolationException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getConstraintViolations().forEach(violation -> {
            String fieldName = violation.getPropertyPath().toString();
            String errorMessage = violation.getMessage();
            errors.put(fieldName, errorMessage);
        });
        
        return ResponseEntity.badRequest().body(errors);
    }
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Map<String, String>> handleMethodArgumentNotValid(MethodArgumentNotValidException ex) {
        
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> {
            errors.put(error.getField(), error.getDefaultMessage());
        });
        
        return ResponseEntity.badRequest().body(errors);
    }
}
```

Основные пакеты:
- Jakarta EE 9+: `jakarta.validation.constraints.*`
- Java EE 8-: `javax.validation.constraints.*`
- Hibernate Validator: `org.hibernate.validator.constraints.*`
</details>





