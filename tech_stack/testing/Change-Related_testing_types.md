# Change-Related Testing Types (Типы тестирования связанные с изменениями)

<details>
  <summary>
    <b>Smoke Testing (Дымовое тестирование)</b>
  </summary>

## Основные понятия

- `Smoke Testing` — начальный уровень функционального тестирования, направленный на быструю проверку жизнеспособности сборки (build) или новой версии приложения.
  <br>Не предназначено для глубокой проверки функциональности, а служит «воротами» для дальнейшего тестирования.

## Цели и задачи

- Подтвердить, что критически важные функции работают корректно.
- Убедиться, что приложение стабильно запускается и не содержит блокирующих дефектов.
- Предотвратить трату ресурсов на полноценное тестирование нерабочей сборки.
- Обеспечить быструю обратную связь разработчикам.

## Область применения

- После каждой новой сборки (в том числе в CI/CD pipeline).
- Перед передачей сборки QA-команде.
- В начале регрессионного или системного тестирования.

## Основной фокус

- Ключевые пользовательские сценарии (например: вход в систему, открытие основной страницы, выполнение базовой операции).
- Компоненты, без которых дальнейшее тестирование невозможно.
- Отсутствие критических сбоев (падения, зависания, ошибки 5xx и т.п.).

## Скорость выполнения

- Должно занимать минимальное время (обычно от нескольких минут до получаса в зависимости от сложности системы).
- Часто полностью автоматизируется для интеграции в пайплайн сборки.

## Реакция на ошибки

- При обнаружении любого блокирующего дефекта тестирование прекращается.
- Сборка считается «непроходной» (failed build) и не передаётся на дальнейшее тестирование.
- Разработчики получают уведомление и исправляют проблему до повторной сборки.

## Лучшие практики

- Автоматизировать набор smoke-тестов и запускать их на каждом коммите или nightly-сборке.
- Поддерживать минимальный, но достаточный набор сценариев — только самые критичные пути.
- Чётко определять критерии прохождения/провала.
- Избегать дублирования с sanity- или регрессионным тестированием — smoke-тесты должны быть максимально поверхностными, но значимыми.
- Использовать как часть «качественного шлюза» (quality gate) в DevOps-процессах.
-
</details>

<details>
  <summary>
    <b>Regression Testing (Регрессионное тестирование)</b>
  </summary>

## Основные понятия

- `Regression Testing` (Регрессионное тестирование) - Тип функционального тестирования, направленный на подтверждение того, что недавно внесённые изменения в код (исправления, новые функции, оптимизация) не вызвали непреднамеренных побочных эффектов и не нарушили существующую функциональность.

## Цели и задачи

- `Side Effect Detection` (Обнаружение побочных эффектов) - Выявление дефектов, которые появились в ранее работающем коде из-за изменений в другом месте системы.
- `Stability Assurance` (Гарантия стабильности) - Обеспечение того, что основной функционал системы остаётся работоспособным после каждого изменения.
- `Confidence in Releases` (Уверенность в релизах) - Предоставление команде разработки и заинтересованным сторонам уверенности в том, что новый выпуск не сломает существующие возможности продукта.

## Триггеры для проведения

- Исправление дефектов (bug fixes).
- Добавление новой функциональности.
- Изменение требований к существующей функции.
- Рефакторинг или оптимизация исходного кода.
- Применение патчей и обновлений зависимостей.
- Изменения в конфигурации системы или окружения.

## Стратегии отбора тестов

- `Full Regression` (Полный регресс) - Запуск всего набора тестов. Используется при крупных изменениях или перед важными релизами.
- `Partial / Selective Regression` (Частичный / Избирательный регресс) - Запуск только тех тестов, которые связаны с изменёнными модулями и их зависимостями.
- `Prioritized Regression` (Приоритезированный регресс) - Запуск тестов в порядке их важности (например, сначала критические и высоко приоритетные).

## Подходы к организации

- `Test Suite Maintenance` (Поддержка тестового набора) - Регулярное обновление и актуализация тест-кейсов в соответствии с изменениями в требованиях и функционале.
- `Impact Analysis` (Анализ влияния) - Определение областей системы, которые могут быть затронуты внесёнными изменениями, для фокусировки тестирования.
- `Smoke & Sanity Testing` (Дымовое и sanity-тестирование) - Быстрая проверка основных функций перед запуском полного регрессионного цикла.

## Преимущества автоматизации

- `Speed` (Скорость) - Автоматизированные тесты выполняются значительно быстрее ручных.
- `Repeatability` (Повторяемость) - Гарантирует одинаковые условия выполнения при каждом запуске.
- `Cost Efficiency` (Экономическая эффективность) - Снижает долгосрочные затраты на повторяющиеся проверки, особенно в проектах с частыми релизами.
- `CI/CD Integration` (Интеграция с CI/CD) - Позволяет запускать регрессионные тесты автоматически при каждом коммите или сборке, обеспечивая быструю обратную связь.

## Лучшие практики

- `Automate Repetitive Tests` (Автоматизируйте повторяющиеся тесты) - Все тесты, которые нужно запускать часто, должны быть автоматизированы.
- `Maintain a Living Test Repository` (Поддерживайте актуальный репозиторий тестов) - Удаляйте устаревшие тесты и добавляйте новые по мере развития продукта.
- `Combine Manual and Automated` (Комбинируйте ручное и автоматизированное тестирование) - Используйте ручное тестирование для исследовательских и UX-аспектов, а автоматизацию — для проверки стабильности.
- `Run Tests Early and Often` (Запускайте тесты как можно раньше и чаще) - Интегрируйте регрессионное тестирование в ежедневный процесс разработки.

</details>

<details>
  <summary>
    <b>Sanity Testing (Санитарное тестирование)</b>
  </summary>

## Основные понятия

- `Sanity Testing` — узконаправленное функциональное тестирование, выполняемое для проверки корректности реализации конкретных изменений (новых функций, исправлений или улучшений) после их интеграции в основную кодовую базу.
  <br>Не охватывает всю систему, а фокусируется только на затронутых участках.

## Цели и задачи

- Убедиться, что новые или изменённые функции работают в соответствии с требованиями.
- Подтвердить, что изменения не содержат явных логических или функциональных ошибок.
- Принять решение: достаточно ли стабильно поведение новой функциональности для перехода к более глубокому тестированию (например, регрессии).

## Область применения

- После слияния feature-ветки в основную ветку разработки.
- Перед запуском полного цикла регрессионного тестирования.
- В условиях ограниченного времени, когда нужно быстро оценить качество изменений.

## Основной фокус

- Поведение новых или модифицированных компонентов.
- Корректность логики, обработки данных и взаимодействия с зависимыми модулями.
- Отсутствие критических дефектов в зоне изменений.

## Скорость выполнения

- Быстрее регрессионного тестирования, но может быть медленнее smoke-тестирования из-за более детальной проверки.
- Часто выполняется вручную, хотя ключевые сценарии могут быть автоматизированы.

## Реакция на ошибки

- При выявлении критической или блокирующей ошибки в зоне изменений тестирование приостанавливается.
- Сборка может быть отклонена для повторной доработки без запуска дальнейших тестов.

## Лучшие практики

- Выполнять только после успешного прохождения smoke-тестирования.
- Тестировать не только «счастливый путь», но и основные граничные и негативные сценарии в рамках изменённой логики.
- Не стремиться к полному покрытию — цель не в исчерпывающей проверке, а в подтверждении разумности поведения.
- Чётко отделять от регрессионного тестирования: sanity не проверяет влияние изменений на старую функциональность.
- Документировать результаты, особенно если тестирование выполняется вручную.

</details>

- `Build Verification Test` / `BVT` (Тестирование сборки): Аналог дымового тестирования для принятия решения о приемке новой версии в работу.
