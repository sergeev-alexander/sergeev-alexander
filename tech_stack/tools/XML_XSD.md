# XML and XSD 

## Основные понятия
- `XML` (Extensible Markup Language) — язык разметки для структурированного представления иерархических данных.
- `XSD` (XML Schema Definition) — язык описания структуры, типов и ограничений для XML-документов.
- `Well-formedness` (корректность синтаксиса) vs `Validity` (соответствие схеме).
- `Namespace` (пространство имён) — механизм предотвращения конфликтов имён элементов и атрибутов.

## Цели и задачи использования XML/XSD
- Обеспечение строгой контрактной спецификации между системами.
- Поддержка сложных иерархических структур данных (в отличие от плоских форматов).
- Гарантия целостности и типобезопасности при обмене данными.
- Применение в конфигурационных файлах, SOAP-сервисах, документообороте, фикстурах тестов.

## Ключевые аспекты XML

---

<details>
  <summary>
    <b>XML Syntax</b>
  </summary>

## Основные понятия

- `Element` (элемент) — базовая структурная единица XML-документа, состоящая из открывающего и закрывающего тегов, возможно, с вложенным содержимым.
- `Attribute` (атрибут) — пара имя/значение, связанная с элементом; значение всегда строковое и заключается в кавычки.
- `CDATA section` (секция CDATA) — блок текста, в котором символы `<`, `>` и `&` не интерпретируются как разметка.
- `Comment` (комментарий) — аннотация, игнорируемая парсером; не может содержать `--`.
- `Processing Instruction` (инструкция обработки, PI) — директива для приложения, обрабатывающего XML; не является частью данных.

## Структура элемента

Элемент может быть:
- Пустым: `<element/>` или `<element></element>`.
- Содержать текст: `<title>Introduction</title>`.
- Содержать дочерние элементы: `<book><title>...</title><author>...</author></book>`.
- Содержать смешанное содержимое (текст + элементы): `<para>This is <em>important</em>.</para>`.

Имена элементов:
- Чувствительны к регистру.
- Должны начинаться с буквы или `_`.
- Не могут содержать пробелы.
- Рекомендуется использовать ASCII-символы в production-контекстах.

## Атрибуты

Формат: `<element attrName="value"/>`.

Особенности:
- Значения атрибутов всегда строковые; типизация возможна только через XSD.
- Нельзя иметь два атрибута с одинаковым именем в одном элементе.
- Атрибуты не поддерживают вложенность или структурированные значения.
- В отличие от JSON, где объекты плоские, XML допускает одновременно атрибуты и дочерние элементы — но best practice: использовать атрибуты только для метаданных (например, `id`, `lang`, `version`), а данные — в элементах.

## CDATA секции

Синтаксис: `<![CDATA[ ... ]]>`.

Назначение:
- Предотвращает необходимость экранирования специальных символов (`<`, `>`, `&`) внутри текста.
- Часто используется для встраивания фрагментов кода, XML или HTML.

Ограничения:
- Нельзя вкладывать одну CDATA-секцию в другую.
- Содержимое CDATA не проверяется на well-formedness — это «сырой» текст.
- При сериализации некоторые библиотеки (например, JAXB) по умолчанию не используют CDATA; требуется явная настройка.

## Примеры:

### Пример 1: Вставка HTML-фрагмента без экранирования

```xml
<!-- Без CDATA -->
<description>
  This is a &lt;p&gt;paragraph&lt;/p&gt; with &lt;b&gt;bold&lt;/b&gt; text.
</description>
```

```xml
<!-- С CDATA -->
<description><![CDATA[
  This is a <p>paragraph</p> with <b>bold</b> text.
]]></description>
```

### Пример 2: Встраивание JavaScript или XML-подобного кода

```xml
<script><![CDATA[
  if (a < b && c > d) {
    alert("Hello & welcome!");
  }
]]></script>
```

Без CDATA символы <, >, & вызвали бы ошибку парсинга, так как интерпретировались бы как начало тега или сущности.

### Пример 3: Хранение фрагмента другого XML (например, в конфигурации)

```xml
<template><![CDATA[
  <user id="123">
    <name>Alexander</name>
    <email>alex@example.com</email>
  </user>
]]></template>
```
Здесь вложенный XML не парсится как часть основного документа — он воспринимается как обычная строка. Это полезно, если вы передаёте шаблон или payload, который будет обрабатываться позже.

Содержимое внутри <![CDATA[ ... ]]> не проверяется на соответствие правилам XML. Даже если там есть незакрытый тег (<unclosed) — это допустимо, потому что это просто текст.

## Комментарии

Синтаксис: `<!-- comment text -->`.

Правила:
- Не могут содержать `--` внутри.
- Могут располагаться в любом месте, кроме prolog и DTD.
- Игнорируются всеми conformant XML-парсерами.
- Не следует использовать для хранения значимых данных — они не являются частью информационного набора документа.

## Инструкции обработки (Processing Instructions)

Синтаксис: `<?target data?>`.

Пример: `<?xml-stylesheet type="text/xsl" href="style.xsl"?>`.

Характеристики:
- `target` — имя приложения или обработчика (например, `xml-stylesheet`).
- `data` — произвольная строка, интерпретируемая целевым приложением.
- PI не являются элементами и не входят в дерево документа в DOM.
- В Java (через SAX) перехватываются через `ContentHandler.processingInstruction()`.

## Производственные рекомендации

- Избегайте CDATA без необходимости — она усложняет валидацию и поиск по содержимому.
- Не храните бизнес-логику или данные в комментариях или PI.
- Используйте атрибуты экономно: только для свойств, которые не имеют внутренней структуры и не подлежат локализации.
- Убедитесь, что все текстовые данные корректно экранированы (`&lt;`, `&amp;` и т.д.), если не используются CDATA.

</details>

---

<details>
  <summary>
    <b>DOCTYPE and DTD (Объявление типа документа и определение типа документа)</b>
  </summary>

## Основные понятия

- `DOCTYPE` (Document Type Declaration) — объявление в прологе XML, указывающее на наличие и местоположение DTD.
- `DTD` (Document Type Definition) — устаревший, но всё ещё встречающийся механизм описания структуры XML-документа (предшественник XSD).
- `Internal subset` — часть DTD, встроенная непосредственно в документ.
- `External subset` — ссылка на внешний файл или URI с определением DTD.

## Синтаксис DOCTYPE

Базовая форма:
```xml
<!DOCTYPE rootElement [internal-subset]>
```

Примеры:

1. Только внутреннее подмножество:

```xml
<!DOCTYPE note [
  <!ELEMENT note (to,from,heading,body)>
  <!ELEMENT to (#PCDATA)>
  <!ELEMENT from (#PCDATA)>
  <!ELEMENT heading (#PCDATA)>
  <!ELEMENT body (#PCDATA)>
]>
```

2. Только внешнее подмножество:

```xml
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
```

3. Комбинированное:

```xml
<!DOCTYPE book SYSTEM "book.dtd" [
  <!ENTITY publisher "Acme Publishing">
]>
```

## Ключевые компоненты DTD

- `<!ELEMENT name content-model>` — определяет структуру элемента.
    - `(#PCDATA)` — парсированный текст.
    - `(child1, child2)` — последовательность.
    - `(a | b)` — выбор одного из.
    - `?`, `*`, `+` — квантификаторы.

- `<!ATTLIST element-name attr-name type default>` — объявление атрибутов.
    - Типы: `CDATA`, `ID`, `IDREF`, `NMTOKEN`, перечисления и др.
    - Значения по умолчанию: `#REQUIRED`, `#IMPLIED`, `#FIXED`.

- `<!ENTITY name "value">` — объявление сущности (аналог константы).
    - Общие сущности: `&name;`
    - Параметрические сущности (только в DTD): `%name;`

- `<!NOTATION>` — объявление типа данных, не разбираемых XML-парсером (например, MIME-типы).

## Отличия от XSD

- DTD использует собственный нетипизированный синтаксис (не XML).
- Не поддерживает пространства имён.
- Ограниченная система типов (нет чисел, дат, регулярных выражений).
- Поддерживает объявление сущностей — мощный, но опасный механизм (источник XXE-атак).

## Риски и ограничения

- `External entities` в DTD позволяют читать файлы с диска или выполнять сетевые запросы — основа уязвимости `XXE`.
- Современные парсеры по умолчанию отключают обработку DTD или внешних сущностей.
- В production-средах использование DTD **не рекомендуется**; предпочтителен XSD.

## Производственные рекомендации

- Избегайте использования DTD в новых системах.
- Если DOCTYPE необходим (например, для совместимости), используйте только внутреннее подмножество без сущностей.
- Никогда не принимайте XML от ненадёжных источников с разрешённой обработкой внешних сущностей.
- При настройке парсера явно отключайте DTD:  
  Для SAX/DOM в Java — установите фичу `"http://apache.org/xml/features/disallow-doctype-decl"` в `true`.

</details>

---

<details>
  <summary>
    <b>XML Prolog and Encoding Declaration (Prolog и объявление кодировки)</b>
  </summary>

## Основные понятия

- `XML prolog` (пролог XML) — необязательная начальная часть XML-документа, содержащая метаинформацию.
- `Encoding declaration` (объявление кодировки) — указание используемой кодовой страницы символов в документе.
- `Standalone document declaration` — флаг, указывающий, зависит ли документ от внешних определений (например, DTD).

## Структура пролога

Пролог может содержать до трёх компонентов в строгом порядке:

1. Обязательная XML-декларация (если присутствует):

```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
```

2. Необязательная DTD-декларация: 

```xml
``<!DOCTYPE ...>
```

3. Комментарии или processing instructions (до первого элемента).

Если пролог отсутствует, документ всё равно может быть well-formed при условии корректного синтаксиса.

## XML-декларация

Формат:

```xml
<?xml version="1.0" encoding="..." standalone="..."?>
```

- `version` — обязательный атрибут; допустимые значения: "1.0" или "1.1" (последний редко используется).
- `encoding` — необязательный, но настоятельно рекомендуемый; указывает кодировку (например, UTF-8, UTF-16, ISO-8859-1).
- `standalone` — необязательный; значения "yes" или "no":
    - "yes" означает, что документ не зависит от внешних сущностей или DTD.
    - По умолчанию — "no".

## Объявление кодировки

Правила:
- Если указано `encoding`, оно должно соответствовать фактической кодировке байтового потока.
- Для `UTF-8` и `UTF-16` парсер может определить кодировку автоматически по BOM (Byte Order Mark), но явное указание предпочтительнее.
- Если кодировка не указана:
    - Документ, передаваемый через HTTP, использует кодировку из заголовка `Content-Type`.
    - Локальный файл без BOM интерпретируется как `UTF-8` (по спецификации XML 1.0).

Важно: некорректное объявление кодировки (например, указание UTF-8, когда файл сохранён в Windows-1251) приведёт к ошибке парсинга или искажению не-ASCII символов.

## Standalone-декларация

Назначение:
- Информирует парсер, нужно ли загружать внешние ресурсы (например, внешнюю DTD).
- Не влияет на валидацию против XSD (только на DTD-зависимости).
- В production-средах почти всегда следует использовать standalone="yes" или опускать этот атрибут, если DTD не используется.

## Производственные рекомендации

- Всегда указывайте <?xml version="1.0" encoding="UTF-8"?> в начале документа, даже если это не обязательно — это повышает переносимость и читаемость.
- Используйте UTF-8 как стандартную кодировку для всех XML-документов в распределённых системах.
- Избегайте использования standalone="no" без явной необходимости во внешних DTD.
- Убедитесь, что инструменты генерации XML (библиотеки, шаблонизаторы) корректно устанавливают кодировку в прологе и согласуют её с фактическим выводом.
- При чтении XML из потока (InputStream) в Java всегда передавайте явную кодировку или используйте InputStream вместо Reader, чтобы позволить парсеру самому определить кодировку по прологу/BOM.

</details>

---

<details>
  <summary>
    <b>Well-Formedness Rules (Правила корректности XML-документа)</b>
  </summary>

## Основные понятия

- `Well-formed document` (корректный документ) — XML-документ, удовлетворяющий синтаксическим правилам спецификации XML 1.0.
- Отличается от `valid document` (валидного документа): well-formedness не требует наличия схемы, а validity — соответствие XSD/DTD.

## Ключевые правила well-formedness

### 1. Закрытость тегов
- Каждый открывающий тег `<element>` должен иметь соответствующий закрывающий `</element>`.
- Пустые элементы могут быть записаны в самозакрывающейся форме: `<element/>`.
- Вложенность должна быть строгой: `<a><b></a></b>` — **недопустимо**; правильно: `<a><b></b></a>`.

### 2. Уникальность атрибутов
- В пределах одного элемента имена атрибутов должны быть уникальны.
- Пример недопустимого XML: `<item id="1" id="2"/>`.

### 3. Экранирование специальных символов
Следующие символы **должны** быть экранированы в текстовом содержимом и значениях атрибутов:
- `<` → `&lt;`
- `>` → `&gt;` (обязательно только в последовательности `]]>`, но рекомендуется всегда)
- `&` → `&amp;`
- `"` → `&quot;` (в значениях атрибутов, заключённых в двойные кавычки)
- `'` → `&apos;` (в значениях атрибутов, заключённых в одинарные кавычки)

Пример корректного экранирования:
```xml
<example attr="He said &quot;Hello &amp; welcome!&quot;">3 &lt; 5</example>
```

### 4. Иерархическая структура
- Документ должен иметь ровно один корневой элемент (root element).
- Все элементы находятся внутри корневого — нет «плавающих» узлов на верхнем уровне.

### 5. Корректные имена
- Имена элементов и атрибутов чувствительны к регистру.
- Должны начинаться с буквы или символа подчёркивания `_`.
- Не могут начинаться с `xml` (в любом регистре) — зарезервировано.
- Не могут содержать пробелы или управляющие символы.

### 6. Корректная обработка CDATA и комментариев
- Секция CDATA должна быть завершена `]]>`.
- Комментарии не могут содержать `--`.
- Processing instructions не могут содержать `?>` внутри данных.

## Последствия нарушения

- Парсер выдаст ошибку `SAXParseException` или аналогичную.
- Документ не может быть обработан далее — даже частично.
- В отличие от HTML, XML не допускает «восстановления» после ошибки (no error recovery).

## Производственные рекомендации

- Всегда используйте проверенные библиотеки для генерации XML (никогда не конкатенируйте строки вручную).
- При приёме XML от внешних источников сначала проверяйте well-formedness, затем — validity и безопасность.
- Настройте парсер так, чтобы он строго следовал правилам (по умолчанию большинство Java-парсеров это делают).
- Избегайте ручного экранирования — используйте API сериализации (JAXB, DOM `Transformer`, StAX `XMLStreamWriter`), которые делают это автоматически.

</details>

---

## Ключевые аспекты XSD

---

<details>
  <summary>
    <b>XSD: SimpleType vs ComplexType (Простые и комплексные типы в XSD)</b>
  </summary>

## Основные понятия

- `SimpleType` (простой тип) — XSD-тип, описывающий **только текстовое содержимое** без атрибутов и дочерних элементов.
- `ComplexType` (комплексный тип) — XSD-тип, допускающий **дочерние элементы**, **атрибуты** и **смешанное содержимое**.

## SimpleType

### Назначение
Определяет ограничения на строковые значения:
- базовые типы (`xs:string`, `xs:integer`, `xs:date` и др.),
- производные типы через `restriction`.

### Синтаксис

Определение глобального простого типа:

```xml
<xs:simpleType name="NonEmptyString">
<xs:restriction base="xs:string">
<xs:minLength value="1"/>
<xs:pattern value="[A-Za-z0-9 ]+"/>
</xs:restriction>
</xs:simpleType>
```

Использование:

```xml
<xs:element name="username" type="NonEmptyString"/>
```

### Возможности
- `restriction` от встроенного или другого простого типа.
- Фасеты (`facets`): `minLength`, `maxLength`, `pattern`, `enumeration`, `whiteSpace`, `totalDigits`, `fractionDigits` и др.
- Не может содержать атрибутов или элементов.

### Ограничения
- Нельзя расширять (`extension`) простой тип до комплексного напрямую.
- Все данные — скалярные.

## ComplexType

### Назначение
Моделирует структурированные данные: объекты с полями, списки, вложенные сущности.

### Синтаксис
Базовый пример:
<xs:complexType name="Person">
<xs:sequence>
<xs:element name="firstName" type="xs:string"/>
<xs:element name="lastName" type="xs:string"/>
</xs:sequence>
<xs:attribute name="id" type="xs:ID" use="required"/>
</xs:complexType>

### Компоненты
- **Модель содержимого**:
    - `xs:sequence` — строгий порядок,
    - `xs:choice` — один из перечисленных,
    - `xs:all` — все элементы в любом порядке (ограничения по количеству и вложенности).
- **Атрибуты**: объявляются через `xs:attribute`.
- **Смешанное содержимое**: `<xs:complexType mixed="true">` — позволяет сочетать текст и элементы (как в HTML).

### Расширяемость
- `xs:extension` — добавление новых элементов/атрибутов к существующему типу.
- `xs:restriction` — ужесточение модели содержимого или атрибутов.

Пример расширения:
<xs:complexType name="Employee">
<xs:complexContent>
<xs:extension base="Person">
<xs:sequence>
<xs:element name="department" type="xs:string"/>
</xs:sequence>
</xs:extension>
</xs:complexContent>
</xs:complexType>

## Ключевые различия

| Критерий                | SimpleType                          | ComplexType                          |
|------------------------|-------------------------------------|--------------------------------------|
| Дочерние элементы       | Нет                                 | Да                                   |
| Атрибуты               | Нет                                 | Да                                   |
| Текстовое содержимое    | Только текст                        | Может быть текст + элементы (mixed) |
| Производные типы        | Только restriction                  | Extension и restriction             |
| Использование в элементах | Как тип элемента или атрибута     | Только как тип элемента             |

## Производственные рекомендации

- Используйте `SimpleType` для всех скалярных полей с бизнес-ограничениями (например, email, код страны, статус).
- Избегайте анонимных (встроенных) типов в сложных схемах — выносите их в глобальные для переиспользования.
- Предпочитайте `xs:sequence` явному указанию порядка; избегайте `xs:all` при большом числе элементов.
- Не используйте `mixed="true"` без крайней необходимости — усложняет обработку и валидацию.
- При проектировании API на основе XML чётко разделяйте данные (в элементах) и метаданные (в атрибутах).

</details>

---

- Ограничения (`restriction`): `minLength`, `maxLength`, `pattern`, `enumeration` и др.
- Модели содержимого: `sequence`, `choice`, `all`.
- Глобальные и локальные объявления.
- Расширяемость: `extension`, `restriction`, `substitutionGroup`.
- Импорт и включение схем (`import`, `include`).
- Управление пространствами имён в XSD.

## Подходы к обработке XML в Java
- `DOM` (Document Object Model) — загрузка всего документа в память; удобен для навигации и модификации.
- `SAX` (Simple API for XML) — событийная, потоковая обработка; низкое потребление памяти, только чтение.
- `StAX` (Streaming API for XML) — pull-парсинг; баланс между контролем и производительностью.
- `JAXB` (Java Architecture for XML Binding) — маршалинг/демаршалинг объектов в XML и обратно.

## Валидация XML против XSD
- Настройка `SchemaFactory` и `Validator`.
- Интеграция валидации в JAXB (`Unmarshaller.setSchema()`).
- Обработка ошибок валидации: `SAXParseException`, позиционирование ошибки.
- Использование в тестах: проверка соответствия ответа сервиса схеме.

## Безопасность при работе с XML
- Угроза `XXE` (XML External Entity) — принцип атаки и последствия.
- Отключение DTD и внешних сущностей по умолчанию.
- Рекомендации по безопасной конфигурации парсеров (например, `FEATURE_SECURE_PROCESSING`).
- Запрет `DOCTYPE` в production-системах без крайней необходимости.

## Особенности применения в тестировании
- Использование XML как формата фикстур и ожидаемых результатов.
- Сравнение XML-документов с учётом порядка, пространств имён и whitespace.
- Валидация входных и выходных XML в интеграционных и contract-тестах.
- Генерация тестовых данных на основе XSD (через инструменты вроде `xsdgen` или `JAXB`).

## Производительность и масштабируемость
- Выбор парсера в зависимости от размера документа и доступной памяти.
- Кэширование скомпилированных схем (`Schema` instances).
- Избегание повторной загрузки XSD в циклах.
- Параллельная обработка независимых XML-документов.

## Типичные ошибки и анти-паттерны
- Избыточное использование атрибутов вместо элементов.
- Жёсткая привязка к порядку элементов без необходимости.
- Отсутствие пространств имён в распределённых системах.
- Небезопасная десериализация без валидации и санитизации.

