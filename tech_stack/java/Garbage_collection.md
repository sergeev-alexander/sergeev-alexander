# `Garbage Collection`

**Garbage Collection** - это процесс автоматического управления памятью в JVM.
Её основная цель - освобождать память, занятую объектами, которые больше не используются приложением.
Это предотвращает утечки памяти и избавляет разработчиков от сложной и подверженной ошибкам задачи ручного управления
памятью.

Базовый принцип: найти объекты, до которых нельзя «добраться» из работающих потоков (такие объекты называются
«мусором»),
и удалить их. Однако алгоритмы и реализации, используемые для этого, сложны и высоко оптимизированы,
что делает сборку мусора критически важным фактором производительности приложения.

## Жизненный цикл объекта
Объекты в JVM проходят через несколько четко определенных этапов и областей памяти (поколений) в течение своего жизненного цикла. 
Это поколенное разделение основано на эмпирическом наблюдении, что большинство объектов умирают молодыми (гипотеза слабого поколения).

<details closed>
    <summary>
        <b>Eden (Эдем)</b>
    </summary>

 - Все новые объекты создаются именно в этой области памяти (за исключением очень больших объектов, которые могут быть размещены сразу в старом поколении).
 - Когда область Eden заполняется, происходит быстрая сборка мусора, известная как Minor GC.
</details>

<details closed>
    <summary>
        <b>Survivor Spaces (Пространства выживших, S0 и S1)</b>
    </summary>

 - После завершения Minor GC в Eden, все выжившие (достижимые) объекты перемещаются в одно из двух Survivor-пространств (например, в S0).
 - Survivor-пространства всегда работают в паре: одно активное, другое пустое.
 - При каждой последующей Minor GC происходит следующее:
   - Сборщик мусора очищает как Eden, так и активное Survivor-пространство (S0).
   - Все выжившие объекты из Eden и S0 перемещаются в пустое Survivor-пространство (S1).
   - Возраст выживших объектов увеличивается на 1 (объект "стареет").
 - Таким образом, Survivor-пространства служат буфером для объектов, которые пережили одну или несколько сборок мусора, 
и обеспечивают дополнительный отсев недолговечных объектов.
</details>

<details closed>
    <summary>
        <b>Старое поколение (Old Generation / Tenured Generation)</b>
    </summary>

 - Объекты, которые пережили определенное количество сборок мусора в молодом поколении (т.е. их возраст достиг определенного порога, 
по умолчанию 15), считаются достаточно "постоянными" и промоутируются (promoted) в старое поколение.
 - Сборка мусора в старом поколении называется Major GC. Она обычно выполняется реже, чем Minor GC, но длится значительно дольше, 
так размер старого поколения намного больше, и алгоритмы его очистки сложнее.
 - Если старое поколение заполняется и сборщик мусора не может освободить в нем достаточно места, происходит Full GC. 
Full GC подразумевает полную сборку как молодого, так и старого поколений и приводит к самой длительной паузе в работе приложения.
</details>

<details closed>
    <summary>
        <b>Постоянное поколение (Metaspace)</b>
    </summary>

 - Важно отметить, что начиная с Java 8, PermGen (Permanent Generation) была заменена на Metaspace.
 - Metaspace не является частью кучи и выделяется из native-памяти операционной системы.
 - В Metaspace хранятся метаданные классов, такие как структуры классов, байт-код методов, константы пула строк и т.д.
 - Сборка мусора в Metaspace происходит при выгрузке соответствующих загрузчиков классов.
</details>

## Краткое описание типов сборок мусора
 - **Minor GC:** Сборка мусора в молодом поколении (Eden + Survivor). Происходит часто и быстро.
 - **Major GC:** Сборка мусора в старом поколении. Происходит реже, но длится дольше.
 - **Full GC:** Полная сборка мусора во всех поколениях (Young + Old), а также очистка Metaspace (при необходимости). 
Вызывает самую длительную паузу.

## Типы сборщиков мусора (Garbage Collectors)

JVM предоставляет несколько реализаций GC, предназначенных для разных целей и нагрузок.
Выбор сборщика - это ключевое решение для настройки производительности приложения.

<details closed>
    <summary>
        <b>Serial GC</b>
    </summary>

 - **Алгоритм:** Serial GC использует комбинацию Copying для Young Generation и Mark-Compact для Old Generation. 
В Young Generation (которая делится на Eden и два Survivor пространства - S0 и S1) при создании объекты размещаются в Eden. 
Когда Eden заполняется, запускается Minor GC. Выжившие объекты (достижимые) копируются из Eden и активного Survivor пространства в другое, 
пустое Survivor пространство. Объекты, пережившие несколько таких циклов (по умолчанию 15), переходят в Old Generation. 
Для Old Generation используется алгоритм Mark-Compact. Сначала алгоритм помечает все достижимые объекты, проходя по графу ссылок. 
Затем все выжившие объекты перемещаются (компактифицируются) в начало области памяти Old Generation, 
что позволяет освободить непрерывный блок свободной памяти в её конце и избежать фрагментации. 
Весь процесс выполняется в одном потоке, что приводит к полной остановке (Stop-The-World) всех потоков приложения на время сборки.
 - **Потоки:** Работает в **одном потоке** (Single-threaded).
 - **Использование:** Предназначен для приложений с маленькой кучей (до ~100 МБ) и работающих в окружениях с одним
  процессорным ядром.
 - **Основной сценарий:** Клиентские приложения, не требующие низких задержек.
 - **Активация:** `-XX:+UseSerialGC`

</details>

<details closed> 
    <summary>
            <b>Parallel GC (Throughput Collector)</b>
    </summary>

 - **Алгоритм:** Parallel GC, также известный как throughput collector, в целом повторяет логику Serial GC (Copying для Young, Mark-Compact для Old), 
но ключевое отличие - использование многопоточности для ускорения процесса. 
При сборке Young Generation (Minor GC) несколько потоков параллельно занимаются маркировкой и копированием выживших объектов из Eden и активного Survivor в другой Survivor. 
Аналогично, при сборке Old Generation (Major GC) несколько потоков параллельно выполняют фазы маркировки и компактификации. 
Это позволяет значительно сократить время паузы по сравнению с однопоточным Serial GC за счёт полного использования вычислительных ресурсов многоядерных процессоров. 
Однако сборка всё равно остаётся Stop-The-World, просто более короткой. Основная цель - максимизировать общую пропускную способность приложения, 
жертвуя потенциально более длинными, но менее частыми паузами.
 - **Потоки:** Запускает сборку мусора в нескольких потоках, что значительно ускоряет процесс.
 - **Использование:** По умолчанию на 64-битных JVM вплоть до Java 8. 
Оптимизирован для максимальной пропускной способности (throughput) за счет использования всех доступных ядер CPU.
 - **Основной сценарий:** Приложения, где важна общая производительность и пиковые stop-the-world паузы допустимы
(например, пакетная обработка данных).
 - **Активация:** `-XX:+UseParallelGC`

</details>

<details closed> 
    <summary>
        <b>CMS GC (Concurrent Mark Sweep)</b>
    </summary>

 - **Алгоритм:** CMS GC разработан для минимизации пауз за счёт выполнения большей части работы конкурентно с потоками приложения. 
Он использует алгоритм Mark-Sweep для Old Generation и не выполняет компактификацию по умолчанию. 
Процесс сборки Old Generation сложен и состоит из нескольких фаз: 
   - Initial Mark: краткая Stop-The-World пауза для маркировки "корневых" объектов, напрямую достижимых из приложения. 
   - Concurrent Mark: потоки сборщика конкурентно с приложением помечают все достижимые объекты, обходя граф ссылок. 
   - Remark: ещё одна Stop-The-World пауза для повторной маркировки объектов, которые могли измениться во время Concurrent Mark. 
   - Concurrent Sweep: потоки сборщика конкурентно с приложением освобождают память, занимаемую непомеченными (мусорными) объектами. 
   Из-за отсутствия компактификации память со временем фрагментируется, и для выделения больших объектов может потребоваться дорогостоящая полная Stop-The-World сборка (Compact).
 - **Цель:** Минимизация пауз (low latency). Большая часть работы по сборке мусора выполняется конкурентно с работой приложения.
 - **Плюсы:** Короткие паузы.
 - **Минусы:** Более высокая нагрузка на CPU, сложность настройки, риск "concurrent mode failure", фрагментация памяти.
 - **Статус:** Устарел (Deprecated) и полностью удален, начиная с Java 14. Не рекомендуется к использованию.
 - **Активация:** `-XX:+UseConcMarkSweepGC`

</details>

<details closed>
    <summary>
        <b>G1 GC (Garbage-First)</b>
    </summary>

 - **Алгоритм:** G1 GC (Garbage-First) делит кучу на множество регионов фиксированного размера (обычно от 1 до 32 МБ), 
отказавшись от классического физического разделения на Young и Old Generation. 
Молодые объекты (Eden) и старые объекты (Old) могут располагаться в любых регионах. 
Молодые поколения представляют собой просто набор регионов Eden и Survivor. 
Сборка проходит в несколько этапов. 
   - Initial Mark: краткая Stop-The-World пауза, помечающая корневые объекты, является частью цикла Young GC. 
   - Concurrent Mark: потоки GC конкурентно с приложением помечают живые объекты во всех регионах. 
   -  Remark: Stop-The-World пауза завершает маркировку. 
   - Live Data Counting and Evacuation (Cleanup): На основе собранной статистики G1 выбирает для очистки регионы с наибольшим количеством мусора ("garbage-first"). 
     Затем происходит эвакуация (копирование) всех выживших объектов из этих регионов в один или несколько свободных регионов, что одновременно освобождает память и устраняет фрагментацию. 
     Этот процесс, называемый смешанной (Mixed) сборкой, позволяет предсказуемо управлять длительностью пауз.
 - **Цель:** Замена для CMS. Баланс между пропускной способностью и низкими задержками. 
Предсказуемые паузы с возможностью задания целевой длительности.
 - **Использование:** Сборщик по умолчанию начиная с Java 9.
 - **Основной сценарий:** Приложения, работающие с большой кучей (более 4-6 ГБ), где важна стабильность и предсказуемость пауз.
 - **Активация:** `-XX:+UseG1GC`

</details>

<details closed> 
    <summary>
        <b>ZGC (Z Garbage Collector)</b>
    </summary>

 - **Алгоритм:** ZGC (Z Garbage Collector) спроектирован для обеспечения сверхнизких пауз (менее 10 мс) даже при работе с терабайтными кучами. 
Его ключевые особенности - использование окрашивания указателей (colored pointers) и load barriers. 
В 64-битных указателях ZGC резервирует несколько бит для мета-информации. 
Это позволяет сборщику отслеживать состояние объектов (например, помечен ли он) без необходимости иметь отдельные битовые карты. 
Load Barrier - это небольшой фрагмент кода, выполняемый потоками приложения при загрузке ссылки из памяти. 
Этот барьер проверяет мета-биты в указателе и при необходимости может выполнить дополнительную работу, например, 
завершить перемещение объекта, на который ссылаются. 
Сам процесс сборки (маркировка, перемещение/компактификация) выполняется конкурентно с приложением. 
Потоки ZGC помечают объекты, находят подходящие регионы для компактификации и перемещают живые объекты в новые регионы, 
при этом приложение может продолжать работать с объектами через механизм load barrier, который обеспечивает корректность ссылок.
 - **Цель:** Сверхнизкие задержки (sub-millisecond pauses), которые практически не растут с увеличением размера кучи.
 - **Потоки:** Полностью параллельная и конкурентная работа. 
 - **Использование:** Подходит для приложений, требующих очень больших объемов памяти (терабайты) и 
крайне низкого времени отклика (например, финансовые торги, базы данных в памяти).
 - **Активация:** `-XX:+UseZGC`

</details>

<details closed> 
    <summary>
        <b>Shenandoah GC</b>
    </summary>

 - **Алгоритм:** Shenandoah GC, как и ZGC, нацелен на снижение пауз до минимума и также использует технику окрашивания указателей и барьеры чтения. 
Однако его внутренняя реализация имеет ключевые отличия. 
Shenandoah делит кучу на регионы и выполняет маркировку и эвакуацию (перемещение живых объектов) конкурентно с работой приложения. 
Основная сложность, которую он решает - это "конкурентная компактификация". 
Когда Shenandoah решает переместить живые объекты из фрагментированного региона, он не останавливает приложение. 
Вместо этого он копирует объекты в новый регион и использует барьер чтения (Brooks pointer) для перенаправления всех обращений к старой копии объекта на новую. 
Барьер перехватывает каждое чтение ссылки из памяти и проверяет, не был ли объект перемещён. 
Этот механизм позволяет приложению продолжать использовать старые и новые копии объектов практически без остановок, 
пока сборщик в фоне обновляет ссылки в корнях и в других объектах, окончательно освобождая старый регион.
 - **Цель:** Аналогична ZGC — снижение пауз до минимума, независимо от размера кучи.
 - **Основное отличие от ZGC:** Разные внутренние реализации механизмов конкурентности. 
Shenandoah разрабатывается Red Hat и была back-ported до Java 8.
 - **Активация:** `-XX:+UseShenandoahGC`

</details>

## Ключевые флаги JVM для мониторинга и настройки GC
Флаги JVM позволяют контролировать поведение сборщика мусора, настраивать параметры памяти и отслеживать производительность приложения. Их можно разделить на несколько категорий.

<details closed>
    <summary>
        <b>Флаги выбора сборщика мусора</b>
    </summary>

Эти флаги активируют конкретную реализацию GC.

`-XX:+UseSerialGC` - Включает Serial Garbage Collector.

`-XX:+UseParallelGC` - Включает Parallel Garbage Collector (Throughput Collector).

`-XX:+UseConcMarkSweepGC` - Устарел Ранее включал CMS Garbage Collector.

`-XX:+UseG1GC` - Включает G1 Garbage Collector (сборщик по умолчанию с Java 9).

`-XX:+UseZGC` - Включает Z Garbage Collector (доступен с Java 11).

`-XX:+UseShenandoahGC` - Включает Shenandoah Garbage Collector.

</details>

<details closed>
    <summary>
        <b>Флаги настройки размера памяти</b>
    </summary>

Эти флаги управляют общим размером кучи и её отдельных областей.

`-Xms[size]` - Задает начальный размер кучи (например, `-Xms512m` или `-Xms2g`).

`-Xmx[size]` - Задает максимальный размер кучи (например, `-Xmx2048m` или `-Xmx4g`). 
На практике `-Xms` и `-Xmx` часто выставляют в одинаковое значение для предотвращения динамического изменения размера кучи и связанных с этим издержек.

`-Xmn[size]` - Задает размер молодого поколения (Young Generation, включая Eden и Survivor spaces). 
Указание этого размера напрямую влияет на размер старого поколения, которое будет равно `Xmx` - `Xmn`.

`-XX:MetaspaceSize=[size]` - Задает начальный размер Metaspace.

`-XX:MaxMetaspaceSize=[size]` - Задает максимальный размер Metaspace.

</details>

<details closed>
    <summary>
        <b>Флаги логирования и мониторинга GC</b>
    </summary>

Эти флаги критически важны для анализа производительности и диагностики проблем.

`-Xlog:gc` - Базовая команда для вывода логов GC в стандартный поток вывода (современный формат, начиная с Java 9).

`-Xlog:gc*` - Расширенное логирование, которое включает всю доступную информацию о GC (детали фаз, тайминги, размеры памяти и т.д.).

`-Xlog:gc:file=gc.log` - Запись логов GC в файл gc.log.

`-Xlog:gc*,safepoint::time,level,tags` - Логирование с дополнительной информацией о сафпоинтах.

`-XX:+PrintGCDetails` - Устарел. Ранее выводил детальную информацию о сборке мусора (используйте -Xlog:gc* для Java 9+).

`-XX:+PrintGCDateStamps` / `-XX:+PrintGCTimeStamps` - Устарели. Добавляли временные метки в логи GC.

`-XX:+UseGCLogFileRotation` / `-XX:NumberOfGCLogFiles=[n]` / `-XX:GCLogFileSize=[size]` - Настройка ротации файлов логов GC для предотвращения переполнения диска.

`-XX:+PrintTenuringDistribution` - Полезный флаг для анализа возраста объектов и настройки порога промоутирования в старое поколение.
Показывает, сколько объектов каждого возраста находится в Survivor-пространствах.

</details>

<details closed>
    <summary>
        <b>Флаги настройки поведения GC</b>
    </summary>
Эти флаги позволяют тонко настроить работу выбранного сборщика.

<details closed>
    <summary>
        <b>Для Parallel GC</b>
    </summary>

`-XX:ParallelGCThreads=[n]` - Задает количество потоков, используемых для параллельной сборки мусора в молодом и старом поколениях.

`-XX:MaxGCPauseMillis=[ms]` - Целевой параметр, указывающий сборщику, что желательное максимальное время паузы GC не должно превышать указанное значение в миллисекундах. 
Сборщик будет пытаться подстроить размеры областей памяти под эту цель.

`-XX:GCTimeRatio=[n]` - Определяет целевое соотношение времени работы приложения ко времени сборки мусора. 
По умолчанию 99, что означает цель - тратить не более 1% времени на GC.

</details>

<details closed>
    <summary>
        <b>Для G1 GC</b>
    </summary>

`-XX:MaxGCPauseMillis=[ms]` - Основной целевой параметр для G1. Указывает желаемую максимальную длительность паузы (например, 200 мс). 
G1 будет активно подстраивать размеры регионов и другие параметры для достижения этой цели.

`-XX:G1NewSizePercent=[n]` - Минимальный размер молодого поколения в процентах от всей кучи (по умолчанию 5).

`-XX:G1MaxNewSizePercent=[n]` - Максимальный размер молодого поколения в процентах от всей кучи (по умолчанию 60).

`-XX:G1HeapRegionSize=[n]` - Задает размер региона в мегабайтах. Должен быть степенью двойки (1, 2, 4, 8, 16, 32 МБ).

</details>

<details closed>
    <summary>
        <b>Для ZGC</b>
    </summary>

`-XX:MaxGCPauseMillis=[ms]` - Как и у других сборщиков, указывает целевую максимальную паузу.

`-XX:SoftMaxHeapSize=[size]` - Целевой максимальный размер кучи. ZGC будет стараться не превышать этот размер, 
но может использовать больше памяти под нагрузкой, если это необходимо для соблюдения пауз.

</details>
</details>
