# `JVM`

**Java Virtual Machine (JVM)** - это виртуальная машина, которая обеспечивает выполнение Java-байткода.
<br>
Она является фундаментальным компонентом платформы Java, отвечающим за кроссплатформенность приложений по принципу "написано однажды, запускается везде".
<br>
JVM предоставляет среду выполнения для Java-приложений, управляя памятью, обеспечивая безопасность и оптимизируя производительность во время работы.

## Основные компоненты JVM

**JVM** состоит из нескольких ключевых подсистем, которые совместно обеспечивают выполнение Java-программ:

<details closed> 
    <summary>
        <b>ClassLoader (Загрузчик классов)</b>
    </summary>

ClassLoader отвечает за загрузку, связывание и инициализацию классов.
<br>
Он состоит из трех основных компонентов:

- **Bootstrap ClassLoader:** Загружает основные Java-классы из rt.jar
- **Extension ClassLoader:** Загружает классы из директории расширений JRE
- **Application ClassLoader:** Загружает классы из classpath приложения

**ClassLoader** использует механизм делегирования - сначала запрашивает загрузку у родительского загрузчика, 
и только если родитель не может загрузить класс, пытается сделать это самостоятельно.

</details>

<details closed> 
    <summary>
        <b>Runtime Data Areas (Области данных времени выполнения)</b>
    </summary>

- **Runtime Data Areas** - это области памяти, которые JVM выделяет для выполнения программы:
- **Method Area:** Хранит метаданные классов, константы, код методов
- **Heap:** Основная область для хранения объектов и массивов
- **Stack:** Хранит фреймы методов, локальные переменные и частичные результаты
- **PC Registers:** Содержат адрес текущей выполняемой инструкции
- **Native Method Stacks:** Поддерживает выполнение нативных методов

Эти области организованы таким образом, чтобы обеспечить изоляцию данных и эффективное управление памятью.

</details>

<details closed> 
    <summary>
        <b>Execution Engine (Исполняющий движок)</b>
    </summary>

- **Execution Engine** выполняет байт-код, содержащийся в загруженных классах. Он состоит из:
- **Interpreter:** Интерпретирует байт-код построчно
- **JIT-Compiler (Just-In-Time):** Компилирует "горячий" код в нативный для повышения производительности
- **Garbage Collector:** Автоматически управляет памятью, освобождая неиспользуемые объекты

JIT-компилятор использует сложные алгоритмы анализа для определения наиболее часто выполняемых участков кода (hot spots) и оптимизирует их выполнение.

</details>

<details closed> 
    <summary>
        <b>JNI (Java Native Interface)</b>
    </summary>

**JNI (Java Native Interface)** предоставляет механизм для взаимодействия с нативным кодом, написанным на других языках программирования (C, C++, ассемблер),
что позволяет:

- Вызывать нативные методы из Java-кода
- Использовать существующие библиотеки, написанные на других языках
- Реализовывать критичные к производительности операции на низкоуровневом коде

JNI обеспечивает мост между платформенно-независимым Java-кодом и платформенно-зависимыми нативными реализациями.
</details>

## Управление памятью в JVM

### Структура кучи (Heap Structure)

Куча JVM разделена на несколько поколений для оптимизации процесса сборки мусора, основанной на гипотезе слабого поколения.

<details closed> 
    <summary>
        <b>Young Generation (Молодое поколение)</b>
    </summary>

Область для хранения недавно созданных объектов. Разделена на три части:

- **Eden Space:** Здесь создаются все новые объекты
- **Survivor Space 0 (From Space):** Активная область для выживших объектов
- **Survivor Space 1 (To Space):** Резервная область для копирования

При заполнении Eden запускается **Minor GC**. 
<br>
Выжившие объекты перемещаются между **Survivor spaces**, увеличивая свой возраст.
<br>
Когда возраст достигает порога (по умолчанию **15**), объекты промоутируются в **Old Generation**.

</details>

<details closed> 
    <summary>
        <b>Old Generation (Старое поколение)</b>
    </summary>

Хранит долгоживущие объекты, которые пережили несколько циклов сборки в Young Generation.
<br>
Сборка мусора здесь выполняется реже, но требует больше времени.
<br>
Используются различные алгоритмы:

- **Mark-Sweep-Compact:** Пометить-очистить-уплотнить
- **Concurrent Mark-Sweep:** Конкурентная маркировка и очистка
- **G1 Mixed Collections:** Смешанные сборки в G1

Размер Old Generation обычно составляет 2/3 от всей кучи.

</details>

<details closed> 
    <summary>
        <b>Memory Allocation</b>
    </summary>

Процесс выделения памяти оптимизирован для скорости:

- **Bump-the-pointer:** Быстрое выделение в Eden
- **TLABs (Thread-Local Allocation Buffers):** Каждый поток получает свой буфер для избежания блокировок
- **Large Object Allocation:** Большие объекты могут размещаться сразу в Old Generation

При нехватке памяти в куче бросается OutOfMemoryError.
</details>

### Stack vs Heap: различия в хранении данных

<details closed> 
    <summary>
        <b>Stack Memory</b>
    </summary>

Стек потока хранит:

- Примитивные типы переменных методов
- Ссылки на объекты в куче
- Фреймы методов (стек вызовов)

Характеристики:

- Автоматическое управление **(LIFO)**
- Быстрый доступ
- Ограниченный размер
- Потокобезопасность (у каждого потока свой стек)
- Переполнение вызывает **StackOverflowError**

Размер стека контролируется параметром `-Xss`.

</details>

<details closed> 
    <summary>
        <b>Heap Memory</b>
    </summary>

Куча хранит:

- Все объекты (экземпляры классов)
- Массивы
- Статические переменные

Характеристики:

- Динамическое выделение памяти
- Медленнее стека
- Общее пространство для всех потоков
- Управляется **Garbage Collector**
- Переполнение вызывает **OutOfMemoryError**

Размер кучи контролируется параметрами `-Xms` и `-Xmx`.
</details>

### Metaspace: управление метаданными классов

<details closed> 
    <summary>
        <b>Architecture</b>
    </summary>

Metaspace заменил **PermGen** начиная с **Java 8**.

Хранит:

- Метаданные классов (Class metadata)
- Байт-код методов
- Константы пула строк
- Аннотации
- Оптимизированный код JIT

Ключевые особенности:

- Автоматическое управление размером
- Использует native memory ОС
- Сборка мусора при выгрузке ClassLoader'ов
- Отсутствие фиксированного лимита (можно ограничить)

</details>

<details closed> 
    <summary>
        <b>Configuration</b>
    </summary>

Основные параметры:

`-XX:MetaspaceSize`: Начальный размер Metaspace<br>
`-XX:MaxMetaspaceSize`: Максимальный размер<br>
`-XX:MinMetaspaceFreeRatio`: Минимальный процент свободного пространства<br>
`-XX:MaxMetaspaceFreeRatio`: Максимальный процент свободного пространства<br>

Мониторинг:

JMX beans (MemoryPoolMXBean) - программный интерфейс для мониторинга через JMX
<br>
`jstat -gcmetacapacity` - утилита JDK для мониторинга статистики Metaspace
<br>
`-XX:NativeMemoryTracking` - флаг JVM для отслеживания нативной памяти

</details>

## JIT-компиляция: C1/C2 компиляторы

<details closed> 
    <summary>
        <b>Tiered Compilation</b>
    </summary>

JVM использует многоуровневую компиляцию для баланса между скоростью запуска и производительностью:

Уровень 0 - Интерпретатор:

- Быстрый старт выполнения
- Низкая производительность
- Сбор профильной информации

Уровень 1 - C1 (Client Compiler):

- Быстрая компиляция
- Базовые оптимизации
- Подходит для короткоживущих приложений

Уровень 2 - C1 с полной инстрyментацией:

- Сбор детальной профильной информации
- Подготовка для C2 компиляции

Уровень 3 - C1 с ограниченной инстрyментацией:

- Улучшенная версия C1
- Баланс скорости и качества

Уровень 4 - C2 (Server Compiler):

- Агрессивные оптимизации
- Длительное время компиляции
- Максимальная производительность

</details>

<details closed> 
    <summary>
        <b>Optimization Techniques</b>
    </summary>

C1 Compiler оптимизации:

- Inlining маленьких методов
- Локальные оптимизации циклов
- Удаление мертвого кода
- Базовая оптимизация исключений

C2 Compiler оптимизации:

- Агрессивное inlining
- Развертывание циклов
- Эскалация проверок
- Специализация по типам
- Элиминация границ массивов
- Оптимизация escape analysis
</details>

<details closed> 
    <summary>
        <b>Performance Analysis</b>
    </summary>

Метрики для анализа:

- CPU Usage: Загрузка процессора
- Memory Usage: Потребление памяти, GC activity
- Throughput: Количество операций в единицу времени
- Latency: Время отклика приложения
- Garbage Collection: Время пауз, частота сборок

Типичные проблемы:

- Memory leaks
- Excessive GC
- Lock contention
- Inefficient algorithms
- Poor cache utilization
</details>

## Внутренние оптимизации JVM

<details closed> 
    <summary>
        <b>Runtime Optimizations</b>
    </summary>

Method Inlining

- Замена вызова метода его телом
- Устранение накладных расходов
- Основа для других оптимизаций

Escape Analysis

- Анализ области видимости объектов
- Stack allocation вместо heap
- Устранение синхронизации

Loop Optimizations

- Развертывание циклов
- Векторизация (использование SIMD)
- Параллелизация

Type-based Optimizations

- Специализация по типам
- Devirtualization вызовов
- Устранение проверок типов

</details>

<details closed> 
    <summary>
        <b>JVM Flags for Optimization</b>
    </summary>

Основные параметры:

`-XX:+AggressiveOpts`: Включение экспериментальных оптимизаций<br>
`-XX:+DoEscapeAnalysis`: Анализ побега объектов<br>
`-XX:+EliminateLocks`: Устранение блокировок<br>
`-XX:+UseStringDeduplication`: Дедупликация строк<br>
`-XX:+UseCompressedOops`: Сжатые указатели (64-bit)<br>
`-XX:AutoBoxCacheMax`: Кеширование автоупакованных значений

Настройка компиляции:

`-XX:CompileThreshold`: Порог компиляции методов<br>
`-XX:TieredStopAtLevel`: Ограничение уровня компиляции<br>
`-XX:ReservedCodeCacheSize`: Размер кеша скомпилированного кода

</details>
