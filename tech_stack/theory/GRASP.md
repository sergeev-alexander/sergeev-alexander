# GRASP

**GRASP** (General Responsibility Assignment Software Patterns) - это **набор фундаментальных принципов (или паттернов) назначения ответственностей** классам и объектам при проектировании объектно-ориентированных систем.

В отличие от GoF-паттернов, GRASP **не описывает конкретные шаблоны кода**, а задаёт **направляющие принципы** для принятия решений на этапе проектирования:
- Кому передать ответственность за выполнение действия?
- Как обеспечить слабую связанность?
- Как сделать систему устойчивой к изменениям?

> GRASP был систематизирован Крейгом Ларманом (Craig Larman) и лежит в основе **responsibility-driven design** - подхода, в котором объекты рассматриваются как **исполнители ролей**, а не просто контейнеры данных.

9 паттернов, которые отвечают на вопрос: "Какой класс должен нести ответственность за определенную функцию?".

<details>
    <summary>
        <b>1. Information Expert (Информационный эксперт)</b>
    </summary>


> **«Ответственность за выполнение задачи должна быть назначена тому классу, который обладает наибольшей информацией, необходимой для её выполнения»**

### Этот принцип предлагает **назначать поведение (методы) тому объекту, у которого уже есть нужные данные**. Цель — сохранить **инкапсуляцию**, избежать «справочных» классов (анемичных моделей) и снизить связанность.

Если для выполнения операции нужны данные `A`, `B` и `C`, то метод должен находиться в том классе, где эти данные **уже есть** — или в классе, который их естественным образом агрегирует.

### ❌ Антипаттерн: Анемичная модель + «менеджер»

```java
// Данные без поведения
public class Order {
    
    private List<OrderItem> items;
    public List<OrderItem> getItems() { return items; }
}

// Весь бизнес в отдельном "менеджере"
public class OrderManager {
    
    public double calculateTotal(Order order) {
        double total = 0;
        for (OrderItem item : order.getItems()) {
            total += item.getPrice() * item.getQuantity();
        }
        return total;
    }
}
```

Проблемы:

- Order - просто контейнер данных (анемичная модель).
- Логика расчёта размазана по внешнему классу.
- Нарушена инкапсуляция: OrderManager лезет внутрь Order.
- Если структура Order изменится - придётся править OrderManager.

### ✅ Решение: Поведение там, где данные

```java
public class Order {
    private List<OrderItem> items;

    // Метод живёт в том же классе, где и данные
    public double calculateTotal() {
        return items.stream()
            .mapToDouble(item -> item.getPrice() * item.getQuantity())
            .sum();
    }
}
```

Теперь:

- Order — полноценный объект с данными и поведением.
- Клиентский код просто вызывает order.calculateTotal().
- Изменение структуры Order не требует изменения внешнего кода.
- Инкапсуляция соблюдена: данные и логика работы с ними — вместе.

### Преимущества

- Высокая связанность внутри класса (cohesion)
- Низкая связанность между классами (coupling)
- Код становится более интуитивным: объекты «умеют» делать то, что от них логично ожидать.
- Упрощается поддержка и рефакторинг.
</details>

<br>

<details>
    <summary>
        <b>2. Creator (Создатель)</b>
    </summary>


> **«Класс B следует назначить ответственность за создание экземпляра класса A, если выполняется хотя бы одно из следующих условий:  
> - B содержит или агрегирует объекты A,  
> - B тесно использует объекты A,  
> - B имеет инициирующие данные для создания A,  
> - B является частью A (например, фабрика),  
> - B записывает экземпляры A в долговременное хранилище»**

### Суть
Принцип **Creator** помогает ответить на вопрос: **«Кому поручить создание нового объекта?»**  
Цель - избежать случайных или произвольных мест создания объектов, которые приводят к хаотичной архитектуре и высокой связанности.

Идея: **объект, который «естественно связан» с создаваемым экземпляром, должен быть ответственен за его создание**.

---

### ❌ Антипаттерн: Создание «из ниоткуда»

```java
public class OrderProcessor {
    public void processOrderData(Map<String, Object> rawData) {
        // Создаём Order внутри сервиса, хотя он не связан с его данными напрямую
        Order order = new Order();
        order.setId((Long) rawData.get("id"));
        order.setCustomer((String) rawData.get("customer"));
        // ... ручная инициализация
    }
}
```








</details>







