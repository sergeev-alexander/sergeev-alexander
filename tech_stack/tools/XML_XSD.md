# XML and XSD

## Основные понятия

- `XML` (Extensible Markup Language) — язык разметки для структурированного представления иерархических данных.
- `XSD` (XML Schema Definition) — язык описания структуры, типов и ограничений для XML-документов.
- `Well-formedness` (корректность синтаксиса) vs `Validity` (соответствие схеме).
- `Namespace` (пространство имён) — механизм предотвращения конфликтов имён элементов и атрибутов.

## Цели и задачи использования XML/XSD

- Обеспечение строгой контрактной спецификации между системами.
- Поддержка сложных иерархических структур данных (в отличие от плоских форматов).
- Гарантия целостности и типобезопасности при обмене данными.
- Применение в конфигурационных файлах, SOAP-сервисах, документообороте, фикстурах тестов.

## Ключевые аспекты XML

---

<details>
  <summary>
    <b>XML Syntax</b>
  </summary>

## Основные понятия

- `Element` (элемент) — базовая структурная единица XML-документа, состоящая из открывающего и закрывающего тегов,
  возможно, с вложенным содержимым.
- `Attribute` (атрибут) — пара имя/значение, связанная с элементом; значение всегда строковое и заключается в кавычки.
- `CDATA section` (секция CDATA) — блок текста, в котором символы `<`, `>` и `&` не интерпретируются как разметка.
- `Comment` (комментарий) — аннотация, игнорируемая парсером; не может содержать `--`.
- `Processing Instruction` (инструкция обработки, PI) — директива для приложения, обрабатывающего XML; не является
  частью данных.

## Структура элемента

Элемент может быть:

- Пустым: `<element/>` или `<element></element>`.
- Содержать текст: `<title>Introduction</title>`.
- Содержать дочерние элементы: `<book><title>...</title><author>...</author></book>`.
- Содержать смешанное содержимое (текст + элементы): `<para>This is <em>important</em>.</para>`.

Имена элементов:

- Чувствительны к регистру.
- Должны начинаться с буквы или `_`.
- Не могут содержать пробелы.
- Рекомендуется использовать ASCII-символы в production-контекстах.

## Атрибуты

Формат: `<element attrName="value"/>`.

Особенности:

- Значения атрибутов всегда строковые; типизация возможна только через XSD.
- Нельзя иметь два атрибута с одинаковым именем в одном элементе.
- Атрибуты не поддерживают вложенность или структурированные значения.
- В отличие от JSON, где объекты плоские, XML допускает одновременно атрибуты и дочерние элементы — но best practice:
  использовать атрибуты только для метаданных (например, `id`, `lang`, `version`), а данные — в элементах.

## CDATA секции

Синтаксис: `<![CDATA[ ... ]]>`.

Назначение:

- Предотвращает необходимость экранирования специальных символов (`<`, `>`, `&`) внутри текста.
- Часто используется для встраивания фрагментов кода, XML или HTML.

Ограничения:

- Нельзя вкладывать одну CDATA-секцию в другую.
- Содержимое CDATA не проверяется на well-formedness — это «сырой» текст.
- При сериализации некоторые библиотеки (например, JAXB) по умолчанию не используют CDATA; требуется явная настройка.

## Примеры:

### Пример 1: Вставка HTML-фрагмента без экранирования

```xml
<!-- Без CDATA -->
<description>
    This is a &lt;p&gt;paragraph&lt;/p&gt; with &lt;b&gt;bold&lt;/b&gt; text.
</description>
```

```xml
<!-- С CDATA -->
<description><![CDATA[
  This is a <p>paragraph</p> with <b>bold</b> text.
]]></description>
```

### Пример 2: Встраивание JavaScript или XML-подобного кода

```xml

<script><![CDATA[
  if (a < b && c > d) {
    alert("Hello & welcome!");
  }
]]></script>
```

Без CDATA символы <, >, & вызвали бы ошибку парсинга, так как интерпретировались бы как начало тега или сущности.

### Пример 3: Хранение фрагмента другого XML (например, в конфигурации)

```xml

<template><![CDATA[
  <user id="123">
    <name>Alexander</name>
    <email>alex@example.com</email>
  </user>
]]></template>
```

Здесь вложенный XML не парсится как часть основного документа — он воспринимается как обычная строка. Это полезно, если
вы передаёте шаблон или payload, который будет обрабатываться позже.

Содержимое внутри <![CDATA[ ... ]]> не проверяется на соответствие правилам XML. Даже если там есть незакрытый тег (<
unclosed) — это допустимо, потому что это просто текст.

## Комментарии

Синтаксис: `<!-- comment text -->`.

Правила:

- Не могут содержать `--` внутри.
- Могут располагаться в любом месте, кроме prolog и DTD.
- Игнорируются всеми conformant XML-парсерами.
- Не следует использовать для хранения значимых данных — они не являются частью информационного набора документа.

## Инструкции обработки (Processing Instructions)

Синтаксис: `<?target data?>`.

Пример: `<?xml-stylesheet type="text/xsl" href="style.xsl"?>`.

Характеристики:

- `target` — имя приложения или обработчика (например, `xml-stylesheet`).
- `data` — произвольная строка, интерпретируемая целевым приложением.
- PI не являются элементами и не входят в дерево документа в DOM.
- В Java (через SAX) перехватываются через `ContentHandler.processingInstruction()`.

## Производственные рекомендации

- Избегайте CDATA без необходимости — она усложняет валидацию и поиск по содержимому.
- Не храните бизнес-логику или данные в комментариях или PI.
- Используйте атрибуты экономно: только для свойств, которые не имеют внутренней структуры и не подлежат локализации.
- Убедитесь, что все текстовые данные корректно экранированы (`&lt;`, `&amp;` и т.д.), если не используются CDATA.

</details>

---

<details>
  <summary>
    <b>DOCTYPE and DTD (Объявление типа документа и определение типа документа)</b>
  </summary>

## Основные понятия

- `DOCTYPE` (Document Type Declaration) — объявление в прологе XML, указывающее на наличие и местоположение DTD.
- `DTD` (Document Type Definition) — устаревший, но всё ещё встречающийся механизм описания структуры XML-документа (
  предшественник XSD).
- `Internal subset` — часть DTD, встроенная непосредственно в документ.
- `External subset` — ссылка на внешний файл или URI с определением DTD.

## Синтаксис DOCTYPE

Базовая форма:

```xml
<!DOCTYPE rootElement [internal-subset]>
```

Примеры:

1. Только внутреннее подмножество:

```xml
<!DOCTYPE note [
        <!ELEMENT note (to,from,heading,body)>
        <!ELEMENT to (#PCDATA)>
        <!ELEMENT from (#PCDATA)>
        <!ELEMENT heading (#PCDATA)>
        <!ELEMENT body (#PCDATA)>
        ]>
```

2. Только внешнее подмножество:

```xml
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
```

3. Комбинированное:

```xml
<!DOCTYPE book SYSTEM "book.dtd" [
        <!ENTITY publisher "Acme Publishing">
        ]>
```

## Ключевые компоненты DTD

- `<!ELEMENT name content-model>` — определяет структуру элемента.
    - `(#PCDATA)` — парсированный текст.
    - `(child1, child2)` — последовательность.
    - `(a | b)` — выбор одного из.
    - `?`, `*`, `+` — квантификаторы.

- `<!ATTLIST element-name attr-name type default>` — объявление атрибутов.
    - Типы: `CDATA`, `ID`, `IDREF`, `NMTOKEN`, перечисления и др.
    - Значения по умолчанию: `#REQUIRED`, `#IMPLIED`, `#FIXED`.

- `<!ENTITY name "value">` — объявление сущности (аналог константы).
    - Общие сущности: `&name;`
    - Параметрические сущности (только в DTD): `%name;`

- `<!NOTATION>` — объявление типа данных, не разбираемых XML-парсером (например, MIME-типы).

## Отличия от XSD

- DTD использует собственный нетипизированный синтаксис (не XML).
- Не поддерживает пространства имён.
- Ограниченная система типов (нет чисел, дат, регулярных выражений).
- Поддерживает объявление сущностей — мощный, но опасный механизм (источник XXE-атак).

## Риски и ограничения

- `External entities` в DTD позволяют читать файлы с диска или выполнять сетевые запросы — основа уязвимости `XXE`.
- Современные парсеры по умолчанию отключают обработку DTD или внешних сущностей.
- В production-средах использование DTD **не рекомендуется**; предпочтителен XSD.

## Производственные рекомендации

- Избегайте использования DTD в новых системах.
- Если DOCTYPE необходим (например, для совместимости), используйте только внутреннее подмножество без сущностей.
- Никогда не принимайте XML от ненадёжных источников с разрешённой обработкой внешних сущностей.
- При настройке парсера явно отключайте DTD:  
  Для SAX/DOM в Java — установите фичу `"http://apache.org/xml/features/disallow-doctype-decl"` в `true`.

</details>

---

<details>
  <summary>
    <b>XML Prolog and Encoding Declaration (Prolog и объявление кодировки)</b>
  </summary>

## Основные понятия

- `XML prolog` (пролог XML) — необязательная начальная часть XML-документа, содержащая метаинформацию.
- `Encoding declaration` (объявление кодировки) — указание используемой кодовой страницы символов в документе.
- `Standalone document declaration` — флаг, указывающий, зависит ли документ от внешних определений (например, DTD).

## Структура пролога

Пролог может содержать до трёх компонентов в строгом порядке:

1. Обязательная XML-декларация (если присутствует):

```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
```

2. Необязательная DTD-декларация:

```xml
``<!DOCTYPE ...>
```

3. Комментарии или processing instructions (до первого элемента).

Если пролог отсутствует, документ всё равно может быть well-formed при условии корректного синтаксиса.

## XML-декларация

Формат:

```xml
<?xml version="1.0" encoding="..." standalone="..."?>
```

- `version` — обязательный атрибут; допустимые значения: "1.0" или "1.1" (последний редко используется).
- `encoding` — необязательный, но настоятельно рекомендуемый; указывает кодировку (например, UTF-8, UTF-16, ISO-8859-1).
- `standalone` — необязательный; значения "yes" или "no":
    - "yes" означает, что документ не зависит от внешних сущностей или DTD.
    - По умолчанию — "no".

## Объявление кодировки

Правила:

- Если указано `encoding`, оно должно соответствовать фактической кодировке байтового потока.
- Для `UTF-8` и `UTF-16` парсер может определить кодировку автоматически по BOM (Byte Order Mark), но явное указание
  предпочтительнее.
- Если кодировка не указана:
    - Документ, передаваемый через HTTP, использует кодировку из заголовка `Content-Type`.
    - Локальный файл без BOM интерпретируется как `UTF-8` (по спецификации XML 1.0).

Важно: некорректное объявление кодировки (например, указание UTF-8, когда файл сохранён в Windows-1251) приведёт к
ошибке парсинга или искажению не-ASCII символов.

## Standalone-декларация

Назначение:

- Информирует парсер, нужно ли загружать внешние ресурсы (например, внешнюю DTD).
- Не влияет на валидацию против XSD (только на DTD-зависимости).
- В production-средах почти всегда следует использовать standalone="yes" или опускать этот атрибут, если DTD не
  используется.

## Производственные рекомендации

- Всегда указывайте <?xml version="1.0" encoding="UTF-8"?> в начале документа, даже если это не обязательно — это
  повышает переносимость и читаемость.
- Используйте UTF-8 как стандартную кодировку для всех XML-документов в распределённых системах.
- Избегайте использования standalone="no" без явной необходимости во внешних DTD.
- Убедитесь, что инструменты генерации XML (библиотеки, шаблонизаторы) корректно устанавливают кодировку в прологе и
  согласуют её с фактическим выводом.
- При чтении XML из потока (InputStream) в Java всегда передавайте явную кодировку или используйте InputStream вместо
  Reader, чтобы позволить парсеру самому определить кодировку по прологу/BOM.

</details>

---

<details>
  <summary>
    <b>Well-Formedness Rules (Правила корректности XML-документа)</b>
  </summary>

## Основные понятия

- `Well-formed document` (корректный документ) — XML-документ, удовлетворяющий синтаксическим правилам спецификации XML
  1.0.
- Отличается от `valid document` (валидного документа): well-formedness не требует наличия схемы, а validity —
  соответствие XSD/DTD.

## Ключевые правила well-formedness

### 1. Закрытость тегов

- Каждый открывающий тег `<element>` должен иметь соответствующий закрывающий `</element>`.
- Пустые элементы могут быть записаны в самозакрывающейся форме: `<element/>`.
- Вложенность должна быть строгой: `<a><b></a></b>` — **недопустимо**; правильно: `<a><b></b></a>`.

### 2. Уникальность атрибутов

- В пределах одного элемента имена атрибутов должны быть уникальны.
- Пример недопустимого XML: `<item id="1" id="2"/>`.

### 3. Экранирование специальных символов

Следующие символы **должны** быть экранированы в текстовом содержимом и значениях атрибутов:

- `<` → `&lt;`
- `>` → `&gt;` (обязательно только в последовательности `]]>`, но рекомендуется всегда)
- `&` → `&amp;`
- `"` → `&quot;` (в значениях атрибутов, заключённых в двойные кавычки)
- `'` → `&apos;` (в значениях атрибутов, заключённых в одинарные кавычки)

Пример корректного экранирования:

```xml

<example attr="He said &quot;Hello &amp; welcome!&quot;">3 &lt; 5</example>
```

### 4. Иерархическая структура

- Документ должен иметь ровно один корневой элемент (root element).
- Все элементы находятся внутри корневого — нет «плавающих» узлов на верхнем уровне.

### 5. Корректные имена

- Имена элементов и атрибутов чувствительны к регистру.
- Должны начинаться с буквы или символа подчёркивания `_`.
- Не могут начинаться с `xml` (в любом регистре) — зарезервировано.
- Не могут содержать пробелы или управляющие символы.

### 6. Корректная обработка CDATA и комментариев

- Секция CDATA должна быть завершена `]]>`.
- Комментарии не могут содержать `--`.
- Processing instructions не могут содержать `?>` внутри данных.

## Последствия нарушения

- Парсер выдаст ошибку `SAXParseException` или аналогичную.
- Документ не может быть обработан далее — даже частично.
- В отличие от HTML, XML не допускает «восстановления» после ошибки (no error recovery).

## Производственные рекомендации

- Всегда используйте проверенные библиотеки для генерации XML (никогда не конкатенируйте строки вручную).
- При приёме XML от внешних источников сначала проверяйте well-formedness, затем — validity и безопасность.
- Настройте парсер так, чтобы он строго следовал правилам (по умолчанию большинство Java-парсеров это делают).
- Избегайте ручного экранирования — используйте API сериализации (JAXB, DOM `Transformer`, StAX `XMLStreamWriter`),
  которые делают это автоматически.

</details>

---

## Ключевые аспекты XSD

---

<details>
  <summary>
    <b>XSD: SimpleType vs ComplexType (Простые и комплексные типы в XSD)</b>
  </summary>

## Основные понятия

- `SimpleType` (простой тип) — XSD-тип, описывающий **только текстовое содержимое** без атрибутов и дочерних элементов.
- `ComplexType` (комплексный тип) — XSD-тип, допускающий **дочерние элементы**, **атрибуты** и **смешанное содержимое**.

## SimpleType

### Назначение

Определяет ограничения на строковые значения:

- базовые типы (`xs:string`, `xs:integer`, `xs:date` и др.),
- производные типы через `restriction`.

### Синтаксис

Определение глобального простого типа:

```xml

<xs:simpleType name="NonEmptyString">
    <xs:restriction base="xs:string">
        <xs:minLength value="1"/>
        <xs:pattern value="[A-Za-z0-9 ]+"/>
    </xs:restriction>
</xs:simpleType>
```

Использование:

```xml

<xs:element name="username" type="NonEmptyString"/>
```

### Возможности

- `restriction` от встроенного или другого простого типа.
- Фасеты (`facets`): `minLength`, `maxLength`, `pattern`, `enumeration`, `whiteSpace`, `totalDigits`, `fractionDigits` и
  др.
- Не может содержать атрибутов или элементов.

### Ограничения

- Нельзя расширять (`extension`) простой тип до комплексного напрямую.
- Все данные — скалярные.

## ComplexType

### Назначение

Моделирует структурированные данные: объекты с полями, списки, вложенные сущности.

### Синтаксис

Базовый пример:

```xml

<xs:complexType name="Person">
    <xs:sequence>
        <xs:element name="firstName" type="xs:string"/>
        <xs:element name="lastName" type="xs:string"/>
    </xs:sequence>
    <xs:attribute name="id" type="xs:ID" use="required"/>
</xs:complexType>
```

### Компоненты

- **Модель содержимого**:
    - `xs:sequence` — строгий порядок,
    - `xs:choice` — один из перечисленных,
    - `xs:all` — все элементы в любом порядке (ограничения по количеству и вложенности).
- **Атрибуты**: объявляются через `xs:attribute`.
- **Смешанное содержимое**: `<xs:complexType mixed="true">` — позволяет сочетать текст и элементы (как в HTML).

### Расширяемость

- `xs:extension` — добавление новых элементов/атрибутов к существующему типу.
- `xs:restriction` — ужесточение модели содержимого или атрибутов.

Пример расширения:

```xml

<xs:complexType name="Employee">
    <xs:complexContent>
        <xs:extension base="Person">
            <xs:sequence>
                <xs:element name="department" type="xs:string"/>
            </xs:sequence>
        </xs:extension>
    </xs:complexContent>
</xs:complexType>
```

## Ключевые различия

| Критерий                  | SimpleType                    | ComplexType                         |
|---------------------------|-------------------------------|-------------------------------------|
| Дочерние элементы         | Нет                           | Да                                  |
| Атрибуты                  | Нет                           | Да                                  |
| Текстовое содержимое      | Только текст                  | Может быть текст + элементы (mixed) |
| Производные типы          | Только restriction            | Extension и restriction             |
| Использование в элементах | Как тип элемента или атрибута | Только как тип элемента             |

## Производственные рекомендации

- Используйте `SimpleType` для всех скалярных полей с бизнес-ограничениями (например, email, код страны, статус).
- Избегайте анонимных (встроенных) типов в сложных схемах — выносите их в глобальные для переиспользования.
- Предпочитайте `xs:sequence` явному указанию порядка; избегайте `xs:all` при большом числе элементов.
- Не используйте `mixed="true"` без крайней необходимости — усложняет обработку и валидацию.
- При проектировании API на основе XML чётко разделяйте данные (в элементах) и метаданные (в атрибутах).

</details>

---

<details>
  <summary>
    <b>XSD Restrictions and Facets (Ограничения и фасеты в XSD)</b>
  </summary>

## Основные понятия

- `Restriction` (ограничение) — механизм в XSD для создания производного типа с более узким набором допустимых значений
  по сравнению с базовым типом.
- `Facet` (фасет) — отдельное правило ограничения, применимое к простому типу или атрибуту.

## Общие принципы

- Ограничения применяются только через `<xs:restriction base="...">`.
- Базовый тип должен быть простым (`xs:string`, `xs:integer`, `xs:date` и т.д.) или другим простым типом.
- Несколько фасетов могут комбинироваться в одном `<xs:restriction>`.
- Все фасеты проверяются **одновременно**; значение должно удовлетворять всем.

## Ключевые фасеты

### `minLength` / `maxLength`

- Применяются к строковым типам и `xs:base64Binary`.
- Задают минимальную и максимальную длину содержимого в символах (не байтах).
- Пример:

```xml

<xs:simpleType name="ShortCode">
    <xs:restriction base="xs:string">
        <xs:minLength value="3"/>
        <xs:maxLength value="10"/>
    </xs:restriction>
</xs:simpleType>
```

### `length`

- Фиксированная длина.
- Взаимоисключающ с `minLength`/`maxLength`.

### `pattern`

- Регулярное выражение (синтаксис упрощённый, по спецификации XML Schema).
- Совпадение проверяется по **всей строке** (не частичное).
- Пример (почтовый индекс США):

```xml

<xs:pattern value="[0-9]{5}(-[0-9]{4})?"/>
```

### `enumeration`

- Явный перечень допустимых значений.
- Поддерживает любые простые типы (строки, числа, даты).
- Пример:

```xml

<xs:simpleType name="Status">
    <xs:restriction base="xs:string">
        <xs:enumeration value="active"/>
        <xs:enumeration value="inactive"/>
        <xs:enumeration value="pending"/>
    </xs:restriction>
</xs:simpleType>
```

### `whiteSpace`

- Управляет обработкой пробельных символов:
    - `preserve` — оставить как есть (по умолчанию для `xs:string`),
    - `replace` — заменить все `\t`, `\n`, `\r` на пробел,
    - `collapse` — выполнить `replace`, затем удалить начальные/конечные пробелы и сжать последовательности пробелов в
      один.
- Особенно важен при использовании `pattern` и `enumeration`.

### Числовые фасеты (`xs:decimal`, `xs:float`, `xs:integer` и производные)

- `minInclusive` / `maxInclusive` — включая границу.
- `minExclusive` / `maxExclusive` — исключая границу.
- `totalDigits` — общее число цифр.
- `fractionDigits` — число цифр после десятичной точки.

Пример:

```xml

<xs:simpleType name="PositivePrice">
    <xs:restriction base="xs:decimal">
        <xs:minExclusive value="0.00"/>
        <xs:fractionDigits value="2"/>
    </xs:restriction>
</xs:simpleType>
```

### Фасеты для дат и времени (`xs:date`, `xs:dateTime`)

- Ограничения через `minInclusive`/`maxInclusive`:

```xml

<xs:minInclusive value="1900-01-01"/>
<xs:maxInclusive value="2100-12-31"/>
```

## Порядок применения

Парсер применяет фасеты в следующем логическом порядке:

1. `whiteSpace` → нормализация строки.
2. Проверка остальных фасетов (`length`, `pattern`, `enumeration` и др.).

## Производственные рекомендации

- Всегда указывайте `whiteSpace="collapse"` для строковых полей, вводимых пользователем, чтобы избежать проблем с
  лишними пробелами.
- Используйте `enumeration` вместо документационных комментариев — это делает схему исполняемой спецификацией.
- При проектировании API избегайте избыточно строгих `pattern`, если семантика может измениться (например, формат
  телефонов).
- Тестируйте регулярные выражения в контексте XSD: синтаксис отличается от Perl/Java (нет `\d`, `\w`; используются
  POSIX-классы или явные диапазоны).
- Для денежных сумм используйте `xs:decimal` с `fractionDigits="2"`, а не `xs:float` — избегайте ошибок округления.

</details>

---

<details>
  <summary>
    <b>XSD Content Models: sequence, choice, all (Модели содержимого в XSD)</b>
  </summary>

## Основные понятия

- `Content model` (модель содержимого) — описание структуры дочерних элементов внутри комплексного типа.
- Определяется с помощью групповых конструкций: `xs:sequence`, `xs:choice`, `xs:all`.
- Применяется только внутри `xs:complexType`.

## xs:sequence

### Назначение

Элементы должны появляться **строго в указанном порядке**, с учётом кратности.

### Синтаксис

```xml

<xs:complexType name="Address">
    <xs:sequence>
        <xs:element name="street" type="xs:string"/>
        <xs:element name="city" type="xs:string"/>
        <xs:element name="postalCode" type="xs:string"/>
    </xs:sequence>
</xs:complexType>
```

### Особенности

- Порядок фиксирован.
- Каждый элемент может иметь атрибуты `minOccurs` и `maxOccurs` (по умолчанию — 1).
- Вложенные `xs:sequence` допустимы и полезны для группировки.

Пример с повторением:

```xml

<xs:element name="item" maxOccurs="unbounded"/>
```

## xs:choice

### Назначение

Ровно **один** из перечисленных элементов (или их групп) должен присутствовать в каждом экземпляре.

### Синтаксис

```xml

<xs:complexType name="ContactInfo">
    <xs:choice>
        <xs:element name="email" type="xs:string"/>
        <xs:element name="phone" type="xs:string"/>
        <xs:element name="address" type="Address"/>
    </xs:choice>
</xs:complexType>
```

### Особенности

- По умолчанию `minOccurs="1"`, `maxOccurs="1"` для всей группы.
- Атрибуты `minOccurs`/`maxOccurs` на уровне `xs:choice` позволяют указать, сколько раз выбор может повторяться.
- Полезен для моделирования вариантов (например, один из способов идентификации).

Пример множественного выбора:

```xml

<xs:choice minOccurs="1" maxOccurs="3">
    <!-- можно выбрать до трёх разных способов связи -->
</xs:choice>
```

## xs:all

### Назначение

Все перечисленные элементы **должны присутствовать**, но **в любом порядке**.

### Синтаксис

```xml

<xs:complexType name="Person">
    <xs:all>
        <xs:element name="firstName" type="xs:string"/>
        <xs:element name="lastName" type="xs:string"/>
        <xs:element name="age" type="xs:integer" minOccurs="0"/>
    </xs:all>
</xs:complexType>
```

### Ограничения

- Допускается **только на верхнем уровне** `xs:complexType` (нельзя вкладывать в `sequence` или `choice`).
- Каждый дочерний элемент может иметь `minOccurs="0"` или `1`, и `maxOccurs="1"` (повторение запрещено).
- Не поддерживается в XSD 1.0 для типов, используемых в `substitutionGroup` или при наследовании через `extension`.

### Производственное замечание

> Из-за ограничений `xs:all` часто избегают в favour of `xs:sequence` даже при отсутствии семантической зависимости
> порядка — ради гибкости расширения.
>
> Хотя xs:all кажется «более правильным» для неупорядоченных данных, его жёсткие ограничения делают схему менее гибкой к
> изменениям. А в production-средах схемы почти всегда эволюционируют.
> Поэтому профессионалы часто жертвуют семантической точностью («порядок не важен») ради практической поддерживаемости —
> и
> используют xs:sequence, даже если клиенты могут отправлять элементы в любом порядке (а парсер всё равно их корректно
> обработает).

## Сравнение

| Модель     | Порядок       | Повторение            | Все/один/любой                   | Ограничения                               |
|------------|---------------|-----------------------|----------------------------------|-------------------------------------------|
| `sequence` | Фиксированный | Да (`maxOccurs`)      | Все                              | Нет                                       |
| `choice`   | Неважен       | Да (на уровне группы) | Ровно один (или указанное число) | Нет                                       |
| `all`      | Любой         | Нет (`maxOccurs=1`)   | Все                              | Только на верхнем уровне, без вложенности |

## Производственные рекомендации

- Используйте `xs:sequence` по умолчанию — он наиболее совместим и гибок.
- Применяйте `xs:choice`, когда данные действительно взаимоисключающие (например, тип идентификатора).
- Избегайте `xs:all` в публичных API — его ограничения мешают эволюции схемы.
- При необходимости произвольного порядка с повторением — моделируйте через `xs:sequence` с `minOccurs="0"` и
  документируйте, что порядок не важен.

</details>

---

<details>
  <summary>
    <b>XSD: Global vs Local Declarations (Глобальные и локальные объявления)</b>
  </summary>

## Основные понятия

- `Global declaration` (глобальное объявление) — определение элемента, типа или атрибута на уровне корня схемы (
  `xs:schema`), доступное для повторного использования в пределах схемы и из других схем.
- `Local declaration` (локальное объявление) — определение, вложенное внутрь другого элемента или типа; область
  видимости ограничена родительским контекстом.

## Объявление элементов

### Глобальный элемент

Определяется как прямой потомок `<xs:schema>`:

```xml

<xs:element name="Order" type="OrderType"/>
```

Особенности:

- Может быть корневым элементом XML-документа.
- Имеет квалифицированное имя в пространстве имён схемы.
- Может ссылаться на глобальный или анонимный тип.

### Локальный элемент

Определяется внутри `<xs:complexType>` или `<xs:sequence>`/`<xs:choice>`:

```xml

<xs:complexType name="OrderType">
    <xs:sequence>
        <xs:element name="customerId" type="xs:string"/>
    </xs:sequence>
</xs:complexType>
```

Особенности:

- Не может быть корневым элементом документа.
- Не имеет собственного имени в глобальной области — только в контексте родителя.
- Часто использует анонимные типы.

## Объявление типов

### Глобальный тип

```xml

<xs:complexType name="AddressType">...</xs:complexType>
```

Преимущества:

- Повторное использование в нескольких элементах.
- Поддержка наследования (`extension`, `restriction`).
- Возможность импорта в другие схемы.

### Локальный (анонимный) тип

```xml

<xs:element name="address">
    <xs:complexType>
        <xs:sequence>
            <xs:element name="street" type="xs:string"/>
        </xs:sequence>
    </xs:complexType>
</xs:element>
```

Особенности:

- Привязан к одному элементу.
- Не может быть расширен или ограничен извне.
- Упрощает схему при однократном использовании.

## Атрибуты

Аналогично:

- Глобальные атрибуты объявляются через `<xs:attribute name="..." type="..."/>` на уровне схемы.
- Локальные — внутри `<xs:complexType>`.

## Влияние на пространства имён

- Глобальные элементы и атрибуты **квалифицированы** по умолчанию (требуют префикса или явного `xmlns` в XML).
- Локальные элементы и атрибуты подчиняются значению атрибута `elementFormDefault` / `attributeFormDefault` в
  `<xs:schema>`:
    - `qualified` — все элементы/атрибуты должны быть в целевом пространстве имён.
    - `unqualified` (по умолчанию для локальных) — локальные элементы/атрибуты не принадлежат никакому пространству
      имён.

Пример:

```xml

<xs:schema targetNamespace="http://example.com" elementFormDefault="qualified">
```

→ Все элементы (включая локальные) будут в `http://example.com`.

## Производственные рекомендации

- Используйте **глобальные типы** для всех сущностей, которые могут быть переиспользованы или станут частью контракта
  API.
- Делайте **глобальные элементы** только для корневых объектов (например, `Request`, `Response`).
- Избегайте смешивания `elementFormDefault="unqualified"` в распределённых системах — это усложняет обработку и
  сериализацию.
- Предпочитайте именованные глобальные типы вместо анонимных, даже если они используются один раз — это упрощает
  отладку, документирование и генерацию кода (например, в JAXB классы будут иметь осмысленные имена).
- При проектировании модульных схем выносите общие типы в отдельный XSD-файл и импортируйте их через `xs:import`.

</details>

---

<details>
  <summary>
    <b>XSD Extensibility: extension, restriction, substitutionGroup (Расширяемость в XSD)</b>
  </summary>

## Основные понятия

- `Extension` (расширение) — механизм наследования в XSD, позволяющий добавлять новые элементы или атрибуты к
  существующему комплексному типу.
- `Restriction` (ограничение) — создание более узкого типа путём сужения модели содержимого или набора атрибутов.
- `SubstitutionGroup` (группа подстановки) — механизм, позволяющий одному элементу заменять другой в XML-документе без
  изменения структуры.

## Extension

### Назначение

Расширение базового типа новыми полями — аналог наследования в ООП.

### Синтаксис

```xml

<xs:complexType name="Person">
    <xs:sequence>
        <xs:element name="name" type="xs:string"/>
    </xs:sequence>
</xs:complexType>

<xs:complexType name="Employee">
<xs:complexContent>
    <xs:extension base="Person">
        <xs:sequence>
            <xs:element name="employeeId" type="xs:string"/>
        </xs:sequence>
    </xs:extension>
</xs:complexContent>
</xs:complexType>
```

### Особенности

- Работает только с `complexType`.
- Требует обёртки `<xs:complexContent>`.
- Порядок: сначала содержимое базового типа, затем расширяющее.
- Атрибуты также могут быть добавлены после секции элементов.

### Производственное применение

- Моделирование иерархий (например, `Payment` → `CreditCardPayment`, `BankTransfer`).
- Эволюция API: добавление необязательных полей в новых версиях.

## Restriction

### Назначение

Создание подтипа с более строгими ограничениями — как «сужение» контракта.

### Синтаксис (complexType)

```xml

<xs:complexType name="ShortName">
    <xs:complexContent>
        <xs:restriction base="Person">
            <xs:sequence>
                <xs:element name="name">
                    <xs:simpleType>
                        <xs:restriction base="xs:string">
                            <xs:maxLength value="20"/>
                        </xs:restriction>
                    </xs:simpleType>
                </xs:element>
            </xs:sequence>
        </xs:restriction>
    </xs:complexContent>
</xs:complexType>
```

### Особенности

- Все элементы и атрибуты базового типа **должны** присутствовать.
- Можно только **сужать** типы (например, уменьшать `maxLength`, убирать `maxOccurs`).
- Не допускается изменение порядка или удаление элементов.

### Ограничения

- Редко используется в практике из-за жёстких требований.
- Требует полного повторения структуры базового типа.

## SubstitutionGroup

### Назначение

Позволяет в XML-документе использовать один элемент вместо другого, если они объявлены в одной группе подстановки.

### Синтаксис

```xml

<xs:element name="Payment" type="PaymentType"/>
<xs:element name="CreditCardPayment" type="CreditCardType" substitutionGroup="Payment"/>
<xs:element name="BankTransfer" type="BankTransferType" substitutionGroup="Payment"/>
```

В XML:

```xml

<Order>
    <CreditCardPayment>...</CreditCardPayment> <!-- допустимо вместо <Payment> -->
</Order>
```

### Условия

- Замещающий элемент должен быть **совместим** по типу (либо тот же, либо производный через `extension`).
- Головной элемент (`Payment`) может быть абстрактным: `<xs:element name="Payment" abstract="true"/>`.

### Отличие от `choice`

- `substitutionGroup` позволяет расширять набор допустимых элементов **в других схемах** (через `xs:import`), не меняя
  исходную.
- `xs:choice` фиксирует все варианты в одном месте.

### Производственные риски

- Поддержка `substitutionGroup` в инструментах (JAXB, парсерах) может быть неполной или требовать дополнительной
  настройки.
- Усложняет статический анализ документа.

## Сравнение подходов

| Механизм            | Изменяет тип?          | Расширяемость              | Поддержка инструментами | Типичное применение |
|---------------------|------------------------|----------------------------|-------------------------|---------------------|
| `extension`         | Да (новый тип)         | Высокая                    | Отличная                | Иерархии объектов   |
| `restriction`       | Да (сужение)           | Низкая                     | Удовлетворительная      | Специализация       |
| `substitutionGroup` | Нет (заменяет элемент) | Очень высокая (межсхемная) | Средняя/низкая          | Plug-in архитектуры |

## Производственные рекомендации

- Предпочитайте `extension` для моделирования иерархий — он надёжен и хорошо поддерживается.
- Избегайте `restriction` для complexType в production-схемах — трудно поддерживать при эволюции.
- Используйте `substitutionGroup` только при явной необходимости plug-in расширяемости; в большинстве API достаточно
  `xs:choice` или полиморфизма через `xsi:type`.
- При генерации Java-классов (JAXB) `substitutionGroup` требует аннотации `@XmlElementRef` и может усложнить
  десериализацию.
- Всегда делайте головной элемент `substitutionGroup` абстрактным (`abstract="true"`), если он не должен использоваться
  напрямую.

</details>

---

<details>
  <summary>
    <b>Polymorphism via xsi:type (Полиморфизм через xsi:type)</b>
  </summary>

## Основные понятия

- `xsi:type` — атрибут из пространства имён `http://www.w3.org/2001/XMLSchema-instance`, позволяющий явно указать *
  *фактический тип элемента** в XML-документе, отличный от объявленного в схеме.
- Механизм поддерживает **полиморфную десериализацию**: парсер создаёт экземпляр производного типа, даже если в XSD
  указан базовый.
- Требует наличия иерархии типов, построенной через `xs:extension`.

## Условия применения

1. В XSD определён базовый `complexType`.
2. Один или несколько производных типов созданы через `<xs:extension base="...">`.
3. В XML-документе:

- Объявлено пространство имён `xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"`.
- Элемент использует атрибут `xsi:type` со значением — **именем глобального комплексного типа**.

## Пример

### XSD

```xml

<xs:complexType name="Notification">
    <xs:sequence>
        <xs:element name="recipient" type="xs:string"/>
    </xs:sequence>
</xs:complexType>

<xs:complexType name="EmailNotification">
<xs:complexContent>
    <xs:extension base="Notification">
        <xs:sequence>
            <xs:element name="subject" type="xs:string"/>
            <xs:element name="body" type="xs:string"/>
        </xs:sequence>
    </xs:extension>
</xs:complexContent>
</xs:complexType>

        <!-- Объявляем глобальный элемент с именем notification, чей тип — Notification -->
<xs:element name="notification" type="Notification"/>
```

### XML

```xml

<notification xsi:type="EmailNotification">
    <recipient>user@example.com</recipient>
    <subject>Welcome</subject>
    <body>Hello!</body>
</notification>
```

Глобальный элемент объявляется, чтобы можно было иметь несколько элементов одного типа или использовать один и тот же
тип в разных контекстах:

```xml

<xs:element name="userNotification" type="Notification"/>
<xs:element name="systemAlert" type="Notification"/>
```

## Особенности

- Значение `xsi:type` должно быть **глобальным именем типа** (т.е. тип должен быть объявлен как
  `<xs:complexType name="...">`).
- Производный тип **должен быть совместим** с базовым (все обязательные элементы и атрибуты базового типа присутствуют).
- При валидации против XSD парсер проверяет, что фактическое содержимое соответствует указанному типу.
- Не требует изменения структуры XML — используется тот же тег, что и для базового типа.

## Поддержка в Java (JAXB)

- Класс базового типа аннотируется `@XmlSeeAlso({EmailNotification.class})`.
- Или все подтипы перечисляются в `@XmlRootElement` / контексте `JAXBContext`.
- Десериализация автоматически создаёт объект нужного подкласса.
- Без правильной настройки JAXB игнорирует `xsi:type` и создаёт только базовый тип.

## Отличие от других механизмов

| Механизм            | Изменяет структуру XML? | Требует новых имён элементов? | Поддержка JAXB | Расширяемость          |
|---------------------|-------------------------|-------------------------------|----------------|------------------------|
| `xsi:type`          | Нет                     | Нет                           | Отличная       | В пределах одной схемы |
| `substitutionGroup` | Да                      | Да                            | Средняя        | Межсхемная             |
| `xs:choice`         | Нет (но разные теги)    | Да                            | Отличная       | Фиксированная          |

## Производственные рекомендации

- Используйте `xsi:type` для моделирования ООП-подобных иерархий в XML-API (особенно в SOAP).
- Убедитесь, что все производные типы объявлены как **глобальные**.
- Всегда включайте `@XmlSeeAlso` в JAXB-классах базового типа.
- Не применяйте `xsi:type` в публичных REST API поверх XML — он менее интуитивен для клиентов, чем явные теги.
- При проектировании схемы документируйте допустимые значения `xsi:type` для каждого полиморфного элемента.

</details>

---

<details>
  <summary>
    <b>XSD: Import and Include (Импорт и включение схем)</b>
  </summary>

## Основные понятия

- `xs:include` — механизм объединения нескольких XSD-файлов, относящихся к **одному и тому же целевому пространству имён
  ** (`targetNamespace`).
- `xs:import` — механизм подключения компонентов из XSD-файла, определённого в **другом пространстве имён**.

Обе директивы размещаются как прямые потомки `<xs:schema>`.

## xs:include

### Назначение

Модульная организация большой схемы: разделение на логические файлы без изменения пространства имён.

### Синтаксис

```xml

<xs:schema targetNamespace="http://example.com/order">
    <xs:include schemaLocation="common-types.xsd"/>
    <xs:include schemaLocation="payment.xsd"/>
</xs:schema>
```

### Требования

- Включаемый файл **не должен** иметь `targetNamespace`, **либо** должен иметь **тот же** `targetNamespace`, что и
  основной файл.
- Если включаемый файл не имеет `targetNamespace`, он считается частью целевого пространства имён основной схемы.

### Типичное применение

- Вынос общих типов (`AddressType`, `Money`) в отдельный файл.
- Разделение схемы по доменным сущностям (заказы, пользователи, платёжные данные).

## xs:import

### Назначение

Использование компонентов (элементов, типов) из схемы, определённой в **другом пространстве имён**.

### Синтаксис

```xml

<xs:schema targetNamespace="http://example.com/order">
    <xs:import namespace="http://example.com/common" schemaLocation="common.xsd"/>
</xs:schema>
```

### Требования

- Атрибут `namespace` **обязателен** и должен точно совпадать с `targetNamespace` импортируемой схемы.
- `schemaLocation` — рекомендательный URI (парсер может игнорировать его и использовать внутренний каталог).

### Пример использования

В схеме заказа:

```xml

<xs:element name="customer" type="common:PersonType"/>
```

Где `common` — префикс, связанный с `http://example.com/common`.

## Ключевые различия

| Критерий           | xs:include                     | xs:import                                                  |
|--------------------|--------------------------------|------------------------------------------------------------|
| Пространство имён  | То же или отсутствует          | Другое (обязательно указано)                               |
| Атрибут            | Только `schemaLocation`        | `namespace` (обязательно) + `schemaLocation` (опционально) |
| Область применения | Модульность внутри одной схемы | Интеграция внешних контрактов                              |

## Производственные рекомендации

- Используйте `xs:include` для **внутренней модульности**: разбиение большой схемы на управляемые части.
- Используйте `xs:import` только для **явных внешних зависимостей** (например, общие типы из корпоративной библиотеки
  схем).
- Указывайте `schemaLocation` даже при использовании `xs:import` — это упрощает разработку и отладку.
- Избегайте циклических зависимостей между схемами — они нарушают принципы композиции и усложняют валидацию.
- При публикации API документируйте все зависимости (`import`/`include`) и предоставляйте полный набор XSD-файлов.
- В Java (JAXB) убедитесь, что все импортируемые схемы доступны в classpath или явно указаны при создании `JAXBContext`.

</details>

---

<details>
  <summary>
    <b>Namespace Management in XSD (Управление пространствами имён в XSD)</b>
  </summary>

## Основные понятия

- `Target namespace` (`targetNamespace`) — пространство имён, которому принадлежат все глобальные компоненты (элементы,
  типы, атрибуты) данной схемы.
- `Default namespace` — пространство имён, применяемое к элементам без префикса в XML-документе.
- `elementFormDefault` / `attributeFormDefault` — атрибуты схемы, предписывающие, должны ли локальные элементы и
  атрибуты
  быть квалифицированы (т.е. принадлежать `targetNamespace`).

## targetNamespace

### Назначение

Определяет URI, который идентифицирует схему как контракт. Все глобальные объявления автоматически попадают в это
пространство.

### Синтаксис

```xml

<xs:schema targetNamespace="http://example.com/order" ...>
```

### Последствия

- Глобальные элементы и типы доступны в XML только при указании этого URI.
- Для ссылки на типы из других схем требуется `xs:import` с этим `namespace`.

## elementFormDefault

### Значения

- `qualified` (по умолчанию в большинстве генераторов): **все** элементы (включая локальные) должны быть в
  `targetNamespace`.
- `unqualified` (значение по спецификации XML Schema, если не указано): только глобальные элементы квалифицированы;
  локальные — без пространства имён.

### Пример: elementFormDefault="qualified"

XSD:

```xml

<xs:schema targetNamespace="http://example.com" elementFormDefault="qualified">
    <xs:element name="order" type="OrderType"/>
    <xs:complexType name="OrderType">
        <xs:sequence>
            <xs:element name="customerId" type="xs:string"/>
        </xs:sequence>
    </xs:complexType>
</xs:schema>
```

XML (валиден):

```xml

<order xmlns="http://example.com">
    <customerId>123</customerId> <!-- оба элемента в http://example.com -->
</order>
```

### Пример: elementFormDefault="unqualified"

XSD:

```xml

<xs:schema targetNamespace="http://example.com" elementFormDefault="unqualified">
    <xs:element name="order" type="OrderType"/>
    <xs:complexType name="OrderType">
        <xs:sequence>
            <xs:element name="customerId" type="xs:string"/>
        </xs:sequence>
    </xs:complexType>
</xs:schema>
```

XML (валиден):

```xml

<order xmlns="http://example.com">
    <customerId xmlns="">123</customerId> <!-- order в http://example.com, customerId — без NS -->
</order>
```

XML (НЕВАЛИДЕН при unqualified!):

```xml

<order xmlns="http://example.com">
    <customerId>123</customerId> <!-- customerId ошибочно попадает в http://example.com -->
</order>
        <!-- Этот документ НЕ ПРОЙДЁТ валидацию, так как локальный элемент оказался в targetNamespace,
             тогда как elementFormDefault="unqualified" требует его отсутствия в любом пространстве имён. -->
```

### Производственное предпочтение

Всегда используйте `elementFormDefault="qualified"`. Это:

- Упрощает обработку (все элементы в одном NS),
- Избегает путаницы при вложенных структурах,
- Соответствует ожиданиям большинства инструментов (JAXB, SOAP).

## attributeFormDefault

Аналогично, но для атрибутов:

- По умолчанию — `unqualified` (атрибуты не принадлежат `targetNamespace`).
- Редко меняется на `qualified` — атрибуты почти всегда локальны.

Пример:

```xml

<xs:attribute name="id" type="xs:ID"/>  
```

→ В XML: `<item id="123"/>`, даже если `targetNamespace` задан.

## Пространства имён в XML-документе

Для корректного соответствия XSD XML должен:

- Объявлять `targetNamespace` схемы как default NS или через префикс.
- Квалифицировать элементы в соответствии с `elementFormDefault`.

Пример (qualified):

```xml

<order xmlns="http://example.com/order">
    <items>
        <item id="1"/>
    </items>
</order>
```

## Импорт и пространства имён

При `xs:import`:

- Компоненты из импортируемой схемы остаются в своём `targetNamespace`.
- В основной схеме они используются с префиксом, связанным с этим NS.

Пример:

```xml

<xs:import namespace="http://example.com/common" schemaLocation="common.xsd"/>
<xs:element name="customer" type="common:PersonType"/>
```

Здесь `common` — префикс, определённый в `xs:schema`:

```text
xmlns:common="http://example.com/common"
```

## Типичные ошибки

1. **Несоответствие `elementFormDefault` и XML**  
   → Ошибка валидации: «element not declared».

2. **Отсутствие `targetNamespace` в схеме, но его наличие в XML**  
   → Элементы не совпадают по пространству имён.

3. **Смешивание qualified/unqualified в одной системе**  
   → Усложняет сериализацию/десериализацию.

## Производственные рекомендации

- Всегда явно указывайте `targetNamespace` в схемах API.
- Устанавливайте `elementFormDefault="qualified"` и `attributeFormDefault="unqualified"`.
- Не используйте одинаковые локальные имена элементов в разных пространствах имён без крайней необходимости.
- При генерации Java-классов (JAXB) аннотация `@XmlSchema` должна отражать те же настройки (`elementForm = QUALIFIED`).
- Документируйте `targetNamespace` и правила квалификации в спецификации API.

</details>

---

### Подходы к обработке XML в Java

- `DOM` — загружает весь XML-документ в память как дерево объектов; удобен для произвольной навигации и модификации, но
  потребляет много памяти на больших документах.
- `SAX` — событийный push-парсер: вызывает обработчики при встрече тегов; минимальное потребление памяти, подходит
  только для однократного чтения.
- `StAX` — pull-парсер: приложение само запрашивает следующее событие; сочетает контроль над потоком (как в SAX) и
  простоту использования (ближе к DOM).
- `JAXB` — привязывает XML к Java-объектам: автоматически преобразует (`marshal`/`unmarshal`) между POJO и XML на основе
  аннотаций или сгенерированных классов.

### Валидация XML против XSD

- Создание `Schema` через `SchemaFactory.newInstance().newSchema(xsdSource)` и последующая валидация через
  `Validator.validate()`.
- В JAXB валидацию можно включить через `Unmarshaller.setSchema(schema)`, что позволяет проверять данные при
  десериализации.
- Ошибки валидации передаются как `SAXParseException`, содержащий номер строки и столбца — полезно для диагностики в
  тестах.
- В contract-тестах рекомендуется валидировать XML-ответы сервиса против актуальной XSD, чтобы гарантировать
  соответствие контракту.

### Безопасность при работе с XML

- Угроза `XXE` (XML External Entity) заключается в использовании внешних сущностей для чтения файлов, выполнения сетевых
  запросов или DoS.
- По умолчанию многие парсеры не отключают DTD и внешние сущности — это необходимо делать явно.
- Ключевые меры: установка `FEATURE_SECURE_PROCESSING`, отключение `DOCTYPE`, запрет `external-general-entities` и
  `external-parameter-entities` через фичи парсера.
- В production-системах рекомендуется полностью запрещать `DOCTYPE` с помощью фичи
  `"http://apache.org/xml/features/disallow-doctype-decl"`.

### Особенности применения в тестировании

- XML часто используется как формат фикстур (ожидаемых ответов) и входных данных в интеграционных тестах.
- При сравнении XML следует учитывать: порядок элементов, пространства имён, whitespace и наличие CDATA — лучше
  использовать специализированные утилиты (например, `XMLUnit`).
- Валидация входных и выходных XML против XSD обеспечивает раннее выявление регрессий в контрактах.
- Тестовые данные можно генерировать на основе XSD с помощью JAXB (через `xjc`) или инструментов вроде `xsdgen`.

### Производительность и масштабируемость

- Для малых документов — `DOM`; для больших — `SAX` или `StAX`; для объектной модели — `JAXB` с кэшированием контекста.
- Экземпляры `Schema` (скомпилированная XSD) стоит кэшировать — их создание дорогостояще.
- Не загружайте XSD из файла/ресурса внутри циклов — делайте это один раз при инициализации.
- Независимые XML-документы можно обрабатывать параллельно, но учтите, что `JAXBContext` потокобезопасен, а
  `Marshaller`/`Unmarshaller` — нет.

### Типичные ошибки и анти-паттерны

- Избыточное использование атрибутов вместо элементов усложняет расширение и локализацию.
- Жёсткая привязка к порядку элементов через `xs:sequence` без реальной необходимости снижает гибкость API.
- Отсутствие `targetNamespace` в распределённых системах ведёт к конфликтам имён и проблемам композиции.
- Десериализация XML без валидации и отключения DTD открывает векторы для XXE и других атак.