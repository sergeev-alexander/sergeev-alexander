# `REST` (Representational State Transfer)

REST - это архитектурный стиль для проектирования распределённых гипермедиа-систем, впервые описанный Роем Филдингом в
его диссертации 2000 года.

Он не является протоколом или стандартом, а представляет собой набор ограничений (constraints), соблюдение которых
приводит к системам с желаемыми свойствами: масштабируемостью, простотой, надёжностью и возможностью кэширования.

<details>
    <summary>
        <b>Шесть основных ограничений REST</b>
    </summary>

Чтобы система считалась truly RESTful, она должна удовлетворять шести ограничениям:

### 1. Client–Server (Клиент–Сервер)

- Разделение ответственности: клиент отвечает за UI/UX, сервер - за хранение данных и бизнес-логику.
- Позволяет масштабировать клиенты и серверы независимо.
- Взаимодействие происходит только через единый интерфейс.

### 2. Stateless (Без состояния)

- Каждый запрос от клиента к серверу должен содержать всю информацию, необходимую для его обработки.
- Сервер не хранит контекст между запросами (например, сессии в памяти).
- Состояние сеанса (если нужно) хранится на клиенте и передаётся явно (например, через токен).
- Преимущества: упрощает масштабирование, повышает надёжность.

### 3. Cacheable (Кэшируемость)

- Ответы от сервера должны быть явно помечены как кэшируемые или некэшируемые.
- Клиент (или промежуточный прокси) может повторно использовать кэшированные ответы, уменьшая задержки и нагрузку.
- REST опирается на встроенные механизмы кэширования HTTP (заголовки Cache-Control, ETag, Last-Modified и др.).

### 4. Uniform Interface (Единый интерфейс)

Самое важное и отличительное ограничение REST.<br>
Достигается через четыре подограничения:

- **Идентификация ресурсов**<br>
Каждый ресурс (например, пользователь, заказ) идентифицируется URI (например, /users/123).
- **Манипуляция ресурсами через представления**<br>
Клиент получает представление ресурса (например, JSON-объект), а не сам ресурс.
На основе этого представления он может изменить состояние ресурса, отправив новое представление.
- **Самоописываемые сообщения**<br>
Каждое сообщение содержит достаточно информации для его обработки: HTTP-метод, URI, заголовки (включая Content-Type, Accept) и тело.
- **Гипермедиа как движок состояния приложения (HATEOAS)**<br>
Клиент переходит от состояния к состоянию, следуя гиперссылкам, возвращаемым сервером (например, _links в ответе).
Это позволяет эволюционировать API без жёсткой привязки клиента к URI.

Почему HATEOAS редко используют?
- Сложность на клиенте: клиент должен "парсить" действия, а не вызывать жёстко заданные методы.
- Отладка и документирование: Swagger/OpenAPI плохо описывают динамические ссылки.
- Привычки разработчиков: проще "знать URI заранее".
- Мобильные и фронтенд-команды часто предпочитают стабильный контракт поверх гибкости.

### 5. Layered System (Многоуровневая система)

- Клиент не знает, взаимодействует ли он напрямую с сервером или через промежуточные слои (прокси, шлюзы,
  балансировщики).
- Позволяет внедрять безопасность, кэширование, мониторинг без изменения клиентского кода.

### 6. Code on Demand (опционально)

- Сервер может передавать клиенту исполняемый код (например, JavaScript), чтобы расширить его функциональность.
- Это единственное необязательное ограничение.
- Редко используется в современных REST API (чаще в веб-приложениях с динамическим UI).

</details>

<details>
    <summary>
        <b>Ключевые понятия REST</b>
    </summary>

### Ресурс (Resource)

Любая информация, которая может быть названа и идентифицирована URI: документ, изображение, коллекция, сервис и т.д.

Любая концепция или сущность, которая может быть идентифицирована с помощью URI.

Примеры:

- Пользователь (`/users/42`)
- Коллекция заказов (`/orders`)
- Изображение (`/images/logo.png`)
- Служба или абстрактная операция (`/search`, если она ведёт себя как ресурс-коллекция результатов)

В REST всё - это ресурс.
Даже поиск или вычисление может быть представлено как ресурс-коллекция, параметры которого передаются через
query-строку (`/search?q=java`).

### Представление (Representation)

Конкретная сериализованная форма ресурса в определённый момент времени (например, JSON, XML, HTML).

Один и тот же ресурс может иметь множество представлений: JSON для мобильного клиента, XML для legacy-системы, HTML для
браузера.

Клиент указывает желаемый формат через заголовок Accept (content negotiation).

Сервер указывает формат в Content-Type.

```
Запрос:

GET /users/42
Accept: application/json

Ответ:

HTTP/1.1 200 OK
Content-Type: application/json

{
    "id": 42, 
    "name": "Alex"
}
```

### HTTP-методы как глаголы

HTTP-методы в REST (Uniform Interface)
REST использует стандартные HTTP-методы как единый интерфейс для манипуляции ресурсами.

Каждый метод имеет чёткую семантику, безопасность и идемпотентность.

- Безопасный метод - не изменяет состояние сервера (например, GET).
- Идемпотентный метод - повторный вызов даёт тот же результат, что и первый (GET, PUT, DELETE).

REST-совместимость требует соблюдения этой семантики.

| Метод       | Семантика                                                                              | Безопасный |                                                                 Идемпотентный                                                                  | Кэшируемый | Типичные коды ответов        | Пример                                                                                                  | Примечания                                                                                                                                                            |
|:------------|:---------------------------------------------------------------------------------------|:----------:|:----------------------------------------------------------------------------------------------------------------------------------------------:|:----------:|:-----------------------------|:--------------------------------------------------------------------------------------------------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **GET**     | Получить представление ресурса или коллекции                                           |    ✅ Да    |                                                                      ✅ Да                                                                      |    ✅ Да    | 200, 404, 304 (Not Modified) | `GET /users/42`<br>→ получает данные пользователя                                                       | Не должен изменять состояние. Может кэшироваться.                                                                                                                     |
| **HEAD**    | То же, что GET, но без тела ответа - только заголовки                                  |    ✅ Да    |                                                                      ✅ Да                                                                      |    ✅ Да    | 200, 404, 304                | `HEAD /documents/report.pdf`<br>→ проверить существование и размер                                      | Используется для проверки метаданных (например, Content-Length, ETag) без передачи данных.                                                                            |
| **POST**    | Создать новый ресурс внутри коллекции ИЛИ выполнить неидемпотентную обработку          |   ❌ Нет    |                                                                     ❌ Нет                                                                      |   ❌ Нет    | 201, 200, 202, 400, 409      | `POST /users`<br>→ создаёт нового пользователя<br><br>`POST /orders/123/cancel`<br>→ выполняет действие | В классическом REST: создание подресурса. В прагматичном REST: также используется для "действий", если нет лучшего способа.                                           |
| **PUT**     | Полностью заменить ресурс по указанному URI. Клиент отправляет полное представление    |   ❌ Нет    |                                                                      ✅ Да                                                                      |   ❌ Нет    | 200, 201, 204, 400, 404      | `PUT /users/42`<br>→ обновляет пользователя целиком                                                     | Если ресурса нет, может создать его (если URI известен клиенту).                                                                                                      |
| **PATCH**   | Частично обновить ресурс. Отправляет инструкции по изменению (не полное представление) |   ❌ Нет    | ⚠️ PATCH - единственный HTTP метод, идемпотентность которого не определена жестко в спецификации, а зависит от конкретной реализации операций. |   ❌ Нет    | 200, 204, 400, 404, 422      | `PATCH /users/42`<br>→ обновляет только поле email                                                      | Идемпотентность зависит от реализации:<br>• `{"op": "replace", "path": "/email", "value": "..."}` - идемпотентна<br>• `{"op": "increment", "path": "/counter"}` - нет |
| **DELETE**  | Удалить ресурс                                                                         |   ❌ Нет    |                                                                      ✅ Да                                                                      |   ❌ Нет    | 200, 204, 404, 410           | `DELETE /users/42`<br>→ удаляет пользователя                                                            | Повторный вызов не должен вызывать ошибку (возвращается 204 или 404).                                                                                                 |
| **OPTIONS** | Получить информацию о поддерживаемых методах для ресурса                               |    ✅ Да    |                                                                      ✅ Да                                                                      |    ✅ Да    | 200, 204                     | `OPTIONS /users`<br>→ возвращает `Allow: GET, POST, HEAD`                                               | Используется для проверки возможностей API и CORS preflight. Поддерживается в REST, но редко реализуется явно.                                                        |

### HTTP статус-коды в REST

|   Код   | Название              | Описание                                        | Пример использования                                           |
|:-------:|:----------------------|:------------------------------------------------|:---------------------------------------------------------------|
| **200** | OK                    | Успешный запрос с телом                         | `GET /users/42` → возвращает данные пользователя               |
| **201** | Created               | Ресурс успешно создан                           | `POST /users` → с заголовком `Location: /users/43`             |
| **202** | Accepted              | Запрос принят, но обработка асинхронна          | Запрос в очередь обработки (редко в синхронных REST API)       |
| **204** | No Content            | Успешно, но без тела                            | `DELETE /users/42` или `PUT`, если сервер не возвращает данные |
| **304** | Not Modified          | Кэш актуален (условный GET)                     | При использовании `If-None-Match` или `If-Modified-Since`      |
| **400** | Bad Request           | Ошибка в теле запроса/параметрах                | Некорректный JSON, отсутствует обязательное поле               |
| **401** | Unauthorized          | Требуется аутентификация                        | Отсутствует или недействителен токен                           |
| **403** | Forbidden             | Доступ запрещён (аутентифицирован, но нет прав) | Пользователь не может удалить чужой пост                       |
| **404** | Not Found             | Ресурс не существует                            | `GET /users/999` — пользователя нет                            |
| **405** | Method Not Allowed    | Метод не поддерживается для этого URI           | `DELETE /search` — нельзя удалять поиск                        |
| **409** | Conflict              | Конфликт состояния                              | Попытка создать пользователя с уже существующим email          |
| **422** | Unprocessable Entity  | Семантическая ошибка в данных                   | Валидный JSON, но нарушены бизнес-правила                      |
| **500** | Internal Server Error | Внутренняя ошибка сервера                       | Исключение в коде сервера                                      |

</details>