# Testing Theory

## 7 принципов тестирования

- Exhaustive testing is impossible (Исчерпывающее тестирование невозможно).
<br>Полный перебор всех возможных сценариев невозможен из-за бесконечного числа комбинаций данных и условий.

- Testing shows the presence of defects, not their absence (Тестирование демонстрирует наличие дефектов, а не их отсутствие)
<br>Тестирование может выявить ошибки, но не гарантирует их полного отсутствия в продукте.

- Absence-of-errors fallacy (Заблуждение об отсутствии ошибок)
<br>Даже после исправления многих дефектов нельзя утверждать, что продукт идеален и готов к использованию, так как требования пользователей могут различаться.

- Early testing saves time and money (Раннее тестирование сохраняет время и деньги)
<br>Чем раньше обнаружен дефект, тем дешевле и проще его исправить, предотвращая накопление проблем на поздних этапах.

- Defect clustering (Принцип скопления или кластеризация дефектов)
<br>Большинство дефектов обычно сосредоточено в небольшом количестве модулей, что требует к ним особого внимания при тестировании.

- Testing is context dependent (Тестирование зависит от контекста)
<br>Подход к тестированию зависит от типа продукта, его целей, команды, сроков и доступных инструментов, поэтому стратегия всегда адаптируется.

- Pesticide paradox (Парадокс пестицида)
<br>Повторение одних и тех же тестов со временем становится неэффективным для поиска новых дефектов, поэтому тестовые сценарии необходимо регулярно обновлять.

## ПОДХОДЫ К ТЕСТИРОВАНИЮ (Testing Approaches)

### По уровню доступа к коду/системе

- `Black Box` (Черный ящик): Тестирование без знания внутреннего устройства системы, основанное на требованиях и спецификациях.
- `White Box` (Белый ящик): Тестирование с полным знанием исходного кода (`source code`) и внутренней структуры системы.
- `Grey Box` (Серый ящик): Тестирование с частичным знанием внутреннего устройства, часто на уровне взаимодействия модулей или `API`.

### По исполнению кода

<details>
  <summary>
    <b>Static Testing (Статическое тестирование)</b>
  </summary>

> `Static Testing` (Статическое тестирование) - это анализ артефактов (код, требования, дизайн) без запуска программы.

## Основные понятия

- `Static Testing` (Статическое тестирование) - Тестирование без выполнения кода, направленное на выявление дефектов в программном обеспечении и сопроводительной документации на ранних этапах жизненного цикла.
- `Verification` (Верификация) - Процесс оценки того, соответствует ли продукт установленным требованиям на текущем этапе разработки; статическое тестирование является частью верификации.

> Верификация в тестировании ПО – процесс просмотра документации, дизайна, кода и программы для того, чтобы проверить, было ли программное обеспечение создано в соответствии с требованиями или нет. Основная цель процесса верификации – обеспечить качество приложения, дизайна, архитектуры и т.д. Процесс верификации включает в себя такие действия, как ревью, пошаговое руководство и инспекция.

## Основные типы

<details>
  <summary>
    <b>Review (Рецензирование)</b>
  </summary>

## Основные понятия

- `Review` (Рецензирование) - Статический метод анализа рабочих продуктов (документов, кода, требований) без их выполнения, направленный на выявление дефектов, улучшение качества и повышение общей осведомленности команды.
- `Static Testing` (Статическое тестирование) - Рецензирование является ключевой частью статического тестирования и проводится до этапа динамического тестирования.

## Цели рецензирования

- Выявление дефектов на ранних этапах жизненного цикла (когда их исправление дешевле).
- Повышение качества и согласованности рабочих продуктов.
- Обмен знаниями и опытом внутри команды.
- Обучение новых участников проекта.
- Улучшение коммуникации между разработчиками, тестировщиками и аналитиками.

## Типы рецензирования

### Неформальное рецензирование (`Informal Review`)
- Отсутствие строгой структуры и документации.
- Примеры: парное чтение кода, быстрая проверка коллегой, обсуждение в чате.
- Подходит для небольших изменений, гибких проектов, быстрой обратной связи.

### Формальное рецензирование (`Formal Review`)
- Строго регламентированный процесс с четкими ролями, этапами и отчетностью.
- **Основные виды**:
  - `Walkthrough` (Сквозной просмотр) - Автор ведет презентацию продукта для аудитории с целью получения отзывов.
  - `Technical Review` (Техническая оценка) - Коллективная экспертиза продукта специалистами для выявления дефектов и несоответствий.
  - `Inspection` (Инспекция) - Наиболее формальный тип, проводимый обученным модератором по заранее определенному чек-листу с фиксацией всех найденных дефектов.

## Процесс формального рецензирования

1. **Планирование** (`Planning`) - Определение целей, участников, критериев входа/выхода.
2. **Инициирование** (`Kick-off`) - Представление продукта, целей и распределение ролей.
3. **Подготовка** (`Individual Preparation`) - Участники самостоятельно изучают материал и фиксируют замечания.
4. **Обсуждение** (`Review Meeting`) - Коллективное обсуждение найденных дефектов (в некоторых форматах, например, в инспекции, может быть пропущено).
5. **Исправление** (`Rework`) - Автор вносит исправления на основе полученной обратной связи.
6. **Подтверждение** (`Follow-up`) - Проверка того, что все замечания были корректно устранены.

## Ключевые роли

- `Author` (Автор) - Создатель рабочего продукта, отвечающий за его исправление.
- `Moderator` / `Review Leader` (Модератор) - Руководит процессом, обеспечивает его соблюдение.
- `Reviewer` (Рецензент) - Участник, который анализирует продукт и находит дефекты.
- `Scribe` / `Recorder` (Секретарь) - Фиксирует все найденные дефекты и решения.

## Что подлежит рецензированию?

- Документация по требованиям (SRS, BRS)
- Дизайн-документы и архитектурные схемы
- Исходный код
- Тестовая документация (тест-кейсы, чек-листы, планы)
- Пользовательская документация (мануалы, справка)

## Преимущества для тестировщика

- Более глубокое понимание требований и бизнес-логики.
- Возможность найти дефекты до начала динамического тестирования.
- Лучшая подготовка к написанию качественных тест-кейсов.
- Укрепление взаимодействия с командой разработки и аналитиками.

## Факторы успеха

- Четко определенные цели рецензирования.
- Подготовленные и мотивированные участники.
- Качественные и доступные материалы для анализа.
- Фокус на продукте, а не на личности автора.
- Использование чек-листов и стандартов.
- Поддержка процесса со стороны менеджмента.

</details>

- `Static Analysis` (Статический анализ) - Анализ исходного кода без его выполнения для обнаружения структурных дефектов и нарушений стандартов.
  - `Data Flow Analysis` (Анализ потока данных) - Проверка корректности использования переменных (инициализация, использование, освобождение) в ходе выполнения программы.
  - `Control Flow Analysis` (Анализ потока управления) - Исследование последовательности выполнения операторов и инструкций для выявления недостижимого кода, бесконечных циклов и других аномалий.
  - `Cyclomatic Complexity` (Цикломатическая сложность) - Метрика, измеряющая количество линейно независимых путей в графе потока управления программы; используется для оценки тестируемости и поддерживаемости кода.

## Объекты статического тестирования

- `Requirements & Design Documents` (Документы требований и проектирования) - Спецификации, архитектурные схемы, модели данных.
- `Test Artifacts` (Тестовые артефакты) - Тест-кейсы, чек-листы, стратегии тестирования.
- `Source Code` (Исходный код) - Проверяется как вручную (code review), так и автоматически (статическими анализаторами).
- `UI Prototypes & Mockups` (Прототипы интерфейсов) - Эскизы и макеты пользовательского интерфейса.
- `Environment Configuration` (Параметры среды) - Настройки окружения, переменные окружения, конфигурационные файлы.
- `Test Data` (Тестовые данные) - Подготовленные наборы данных для проверки корректности их структуры и соответствия требованиям.

## Типичные дефекты, выявляемые статическим анализом

- `Unused Variables` (Неиспользуемые переменные) - Переменные, объявленные, но нигде не используемые.
- `Dead Code` (Мертвый код) - Участки кода, которые никогда не выполняются.
- `Infinite Loops` (Бесконечные циклы) - Циклы без корректного условия завершения.
- `Uninitialized Variables` (Переменные без инициализации) - Использование переменных до присвоения им значения.
- `Resource Leaks` (Утечки ресурсов) - Невысвобождаемые память, файловые дескрипторы, соединения.
- `Buffer Overflows` (Переполнение буфера) - Запись данных за пределы выделенного буфера.
- `Incomplete Error Handling` (Неполная обработка ошибок) - Отсутствие обработки возможных исключений или кодов ошибок.

## Преимущества статического тестирования 

- `Early Defect Detection` (Раннее выявление дефектов) - Обнаружение ошибок до запуска системы, что значительно снижает стоимость их исправления.
- `Process Improvement Feedback` (Обратная связь для улучшения процессов) - Выявленные дефекты помогают команде совершенствовать практики разработки и тестирования.
- `Enhanced Team Awareness` (Повышение осведомленности команды) - Участники лучше понимают качество продукта и потенциальные риски.
- `Knowledge Sharing` (Обмен знаниями) - Способствует передаче опыта и критической информации между членами команды.
- `Reduced Rework Effort` (Снижение объема переделок) - Минимизация затрат на исправление ошибок на поздних этапах разработки.

## Недостатки статического тестирования

- Процесс статического тестирования может занимать много времени, так как в основном он выполняется вручную.
- Препятствует обнаружению уязвимостей, представленных в среде выполнения.

</details>

<details>
  <summary>
    <b>Dynamic Testing (Динамическое тестирование)</b>
  </summary>

> `Dynamic Testing` (Динамическое тестирование) - Тестирование, при котором программный код исполняется для проверки его реального поведения при заданных входных данных.
> 
> `Validation` (Валидация) - Процесс подтверждения того, что продукт удовлетворяет заявленным требованиям и ожиданиям пользователей; динамическое тестирование является частью валидации.

> Валидация в разработке ПО – динамический механизм тестирования и проверки того, действительно ли программный продукт соответствует точным потребностям заказчика или нет. Этот процесс помогает гарантировать, что ПО выполняет желаемое использование в подходящей среде. Процесс валидации включает в себя такие действия, как модульное тестирование, интеграционное тестирование, системное тестирование и пользовательское приемочное тестирование.

## Методология динамического тестирования

- `Input Execution and Output Analysis` (Выполнение с входными данными и анализ выхода) - Подача заранее определённых входных данных и сравнение фактического результата с ожидаемым.
- `Real-Time Behavior Verification` (Проверка поведения в реальном времени) - Наблюдение за реакцией системы на действия пользователя или внешние события.
- `Test Execution Modes` (Режимы выполнения тестов) - Может выполняться вручную или с использованием автоматизированных средств.

## Цели и задачи динамического тестирования

- `Functional Correctness` (Функциональная корректность) - Подтверждение, что система выполняет заявленные функции правильно.
- `Non-Functional Validation` (Валидация нефункциональных характеристик) - Проверка производительности, надёжности, масштабируемости, безопасности и других качественных атрибутов.
- `Complex Defect Detection` (Обнаружение сложных дефектов) - Выявление ошибок, которые невозможно обнаружить без выполнения кода (например, гонки условий, ошибки синхронизации, проблемы с состоянием).

## Преимущества динамического тестирования

- `Comprehensive Functionality Coverage` (Полное покрытие функциональности) - Позволяет оценить систему в целом, как её воспринимает пользователь.
- `User-Centric Perspective` (Ориентация на пользователя) - Тестирование отражает реальный опыт взаимодействия с продуктом.
- `Detection of Runtime Defects` (Обнаружение ошибок времени выполнения) - Выявляет дефекты, проявляющиеся только при исполнении (например, утечки памяти, исключения).
- `Automation Support` (Поддержка автоматизации) - Широко поддаётся автоматизации с использованием специализированных фреймворков и инструментов.

## Недостатки динамического тестирования

- `High Time Consumption` (Высокая трудоёмкость) - Требует значительных временных затрат на подготовку, выполнение и анализ результатов.
- `High Cost` (Высокая стоимость) - Связано с необходимостью поддержки тестовой инфраструктуры, данных и окружений.
- `Late Defect Discovery` (Позднее обнаружение дефектов) - Обычно проводится после завершения разработки, что увеличивает стоимость исправления найденных ошибок.

</details>

## УРОВНИ ТЕСТИРОВАНИЯ (Testing Levels)

- `Unit Testing` (Модульное / Компонентное тестирование): Тестирование отдельных изолированных модулей или компонентов (обычно методов или классов) программы.
- `Integration Testing` (Интеграционное тестирование): Тестирование взаимодействия между несколькими модулями, компонентами или системами.
- `System Testing` (Системное тестирование): Тестирование полностью интегрированной системы на соответствие всем требованиям.
- `Acceptance Testing` (Приемочное тестирование): Финальное тестирование, проводимое с целью принятия решения о готовности системы к выпуску.

## ТИПЫ ТЕСТИРОВАНИЯ (Testing Types)

### По функциональности

- [`Functional Testing Types` (Типы функционального тестирования)](https://github.com/sergeev-alexander/sergeev-alexander/blob/main/tech_stack/testing/Functional_testing_types.md "Functional_testing_types.md")
  <br>
  Проверка соответствия функциональности системы заявленным требованиям.

  - [`Change-related Testing Types` (Типы тестирования основанные на изменениях)](https://github.com/sergeev-alexander/sergeev-alexander/blob/main/tech_stack/testing/Change-Related_testing_types.md "Change-Related_testing_types.md")
    <br>
    Проверка того, что недавние изменения в коде (исправления, новые функции) работают корректно и не сломали существующий функционал.

- [`Non-functional Testing Types` (Типы нефункционального тестирования)](https://github.com/sergeev-alexander/sergeev-alexander/blob/main/tech_stack/testing/Non-functional_testing_types.md "Non-functional_testing_types.md")
  <br>
  Проверка качественных характеристик системы (производительность, безопасность, удобство использования и т.д.).



### По степени автоматизации

- `Manual Testing` (Ручное тестирование): Выполнение тестовых сценариев (`test scenarios`) человеком без использования скриптов.
- `Automated Testing` (Автоматизированное тестирование): Выполнение тестов с помощью специальных программ и скриптов.

## ПРОЦЕССЫ И ЖИЗНЕННЫЕ ЦИКЛЫ

- [`STLC` (Software testing lifecycle)](...)
- [`Defects and Errors` (Дефекты и ошибки)](...)

## МЕТОДОЛОГИИ И ТЕХНИКИ ТЕСТИРОВАНИЯ

<details>
  <summary>
    <b>Test-Design technics (Техники тест-дизайна)</b>
  </summary>

> Тест-дизайн – это этап процесса тестирования ПО, на котором проектируются и создаются тест-кейсы, в соответствии с определёнными ранее критериями качества и целями тестирования.

## Ключевые концепции:

- Тест-аналитик: Определяет "Что тестировать?".
- Тест-дизайнер: Определяет "Как тестировать?".
- Тестовое покрытие (`Test Coverage`): Метрика, оценивающая полноту тестирования.
  - Покрытие требований (`Requirements Coverage`): Оценка по трассировке тестов к функциональным требованиям.
  - Покрытие кода (`Code Coverage`): Оценка по проценту исполненного кода в тестах.

## Классификация техник тест-дизайна (по источнику знаний)

1.  **Методы чёрного ящика (Black-box, спецификационные):** Фокусируются на поведении системы (вход -> выход) без знания внутреннего устройства.
2.  **Методы белого ящика (White-box, структурные):** Основаны на знании внутренней структуры кода, логики программы. (Требуют навыков программирования. *В вашем текущем блоке отсутствуют, стоит добавить ключевые*).
3.  **Методы, основанные на опыте (Experience-based):** Используют знания и интуицию тестировщиков, пользователей, экспертов.

## Основные техники тест-дизайна:

### Методы чёрного ящика (Black-box):

<details>
  <summary>
    <b>Equivalence Partitioning & Boundary Value Analysis (Эквивалентное разбиение и анализ граничных значений)</b>
  </summary>

## Основные понятия

- `Equivalence Partitioning` (`EP`) (Эквивалентное разбиение) - Техника чёрного ящика, при которой входные данные делятся на группы (классы эквивалентности), где все значения в группе ожидаются вызывать одинаковое поведение системы.
- `Boundary Value Analysis` (`BVA`) (Анализ граничных значений) - Техника тестирования, фокусирующаяся на проверке значений на границах классов эквивалентности, так как ошибки чаще всего возникают именно на границах.

## Принципы эквивалентного разбиения

- **Валидные классы** - Наборы входных данных, которые должны быть приняты системой.
- **Невалидные классы** - Наборы входных данных, которые должны быть отклонены системой.
- **Одно значение на класс** - Достаточно протестировать одно значение из каждого класса, так как все значения в классе считаются эквивалентными.

## Принципы анализа граничных значений

- **Минимум и максимум** - Проверяются минимальное и максимальное допустимые значения.
- **Границы +1 и -1** - Проверяются значения, непосредственно примыкающие к границам с обеих сторон (например, min-1, min, min+1, max-1, max, max+1).
- **Применимость** - Используется для любых упорядоченных типов данных: числа, даты, строки (по длине).

## Когда применять

- При наличии **ограничений на входные данные** (диапазоны, списки, форматы).
- Для **поля ввода с четкими правилами валидации**.
- На **любом уровне тестирования** (модульном, интеграционном, системном).
- В сочетании с другими техниками тест-дизайна для повышения покрытия.

## Алгоритм применения

1. **Определить все входные параметры** тестируемой функции.
2. **Выделить классы эквивалентности** для каждого параметра (валидные и невалидные).
3. **Определить граничные значения** для каждого класса.
4. **Создать тест-кейсы**:
  - По одному значению из каждого класса эквивалентности.
  - Все граничные значения и их соседи.
5. **Оптимизировать набор тестов**, удаляя дублирующиеся или избыточные проверки.

## Преимущества

- **Снижение количества тестов** - Значительно уменьшает объем тестовых данных без потери качества.
- **Фокус на рисках** - Концентрирует внимание на наиболее уязвимых местах (границах).
- **Простота и эффективность** - Легко понимается и применяется даже начинающими тестировщиками.
- **Систематический подход** - Обеспечивает структурированное и полное покрытие требований.

## Примеры классов эквивалентности

- **Числовые диапазоны**: [1-10] → валидный, [≤0], [11-99], [≥100] → невалидные.
- **Длина строки**: [6-10 символов] → валидная, [0-5], [11+] → невалидные.
- **Списки выбора**: Выбранный элемент из списка → валидный, ввод несуществующего значения → невалидный.
- **Форматы данных**: Корректный email → валидный, некорректный формат → невалидный.

## Лучшие практики

- Всегда использовать **BVA вместе с EP** для максимальной эффективности.
- Учитывать **специфические бизнес-правила**, которые могут создавать дополнительные классы.
- Проверять **комбинации входных параметров** с помощью других техник (например, таблиц решений), если параметры взаимозависимы.
- Документировать **логику выделения классов** для обеспечения прозрачности и прослеживаемости.

</details>

<details>
  <summary>
    <b>Decision Table Testing (Таблицы решений / Принятия решений): Формализация бизнес-логики, где комбинации входных условий (причин) определяют выходные действия (следствия). Более формализованная и полная версия Cause/Effect</b>
  </summary>

## Основные понятия

- `Decision Table` (Таблица решений) - Техника чёрного ящика для проектирования тестов, основанная на анализе комбинаций входных условий и соответствующих им действий или выходных результатов.
- `Combinatorial Testing` (Комбинаторное тестирование) - Подход, направленный на проверку различных комбинаций входных параметров для выявления сложных дефектов.

## Когда применять

- В бизнес-логике присутствуют **сложные правила**, зависящие от нескольких условий.
- Требования описывают **разные исходы** в зависимости от комбинации факторов.
- Необходимо обеспечить **полное покрытие** всех возможных сценариев принятия решений.
- Примеры: расчет скидок, определение тарифов, валидация форм с множеством зависимых полей, обработка заказов.

## Структура таблицы решений

1. **Condition Stubs** (Заголовки условий) - Список входных условий или предпосылок.
2. **Condition Entries** (Входные значения условий) - Комбинации значений (обычно "Да/Нет", "Истина/Ложь", "0/1").
3. **Action Stubs** (Заголовки действий) - Список возможных системных реакций или выходных результатов.
4. **Action Entries** (Выходные значения действий) - Указание, какое действие выполняется при каждой комбинации условий.

## Алгоритм построения

1. **Идентифицировать все условия** из требований.
2. **Определить все возможные действия** системы.
3. **Рассчитать количество комбинаций**: N = V₁ × V₂ × ... × Vₙ, где V — количество значений для каждого условия.
4. **Построить таблицу** и заполнить колонки всеми уникальными комбинациями условий.
5. **Определить действия** для каждой комбинации на основе бизнес-правил.
6. **Оптимизировать таблицу**:
  - Удалить невозможные или противоречивые комбинации.
  - Объединить столбцы с одинаковыми результатами.
  - Уточнить неоднозначные случаи у аналитиков.

## Преимущества

- **Полнота покрытия** - Гарантирует, что не будет упущена ни одна логическая комбинация.
- **Наглядность** - Сложная логика представляется в простой и структурированной форме.
- **Простота преобразования в тест-кейсы** - Каждый столбец таблицы напрямую соответствует одному тест-кейсу.
- **Универсальность** - Может быть реализована с помощью любых табличных инструментов (Excel, Google Sheets).

## Недостатки

- **Экспоненциальный рост** - При большом количестве условий число комбинаций становится непрактичным (проблема "комбинаторного взрыва").
- **Трудоёмкость** - Требует значительных временных затрат на анализ и построение.
- **Не подходит для простых сценариев** - Избыточна для линейных процессов с одним или двумя условиями.

## Лучшие практики

- Использовать технику **парного тестирования** (`Pairwise Testing`) для сокращения числа комбинаций при большом количестве входных параметров.
- Активно сотрудничать с **бизнес-аналитиками** для уточнения правил и устранения неоднозначностей.
- Интегрировать таблицы решений в **спецификации требований** как живую документацию.
- Рассматривать каждую строку таблицы как **спецификацию для автоматизированного теста**.

</details>

<details>
  <summary>
    <b>State Transition Testing (Тестирование перехода состояний)</b>
  </summary>

## Основные понятия

- `State Transition Testing` (Тестирование перехода состояний) - Техника чёрного ящика, используемая для тестирования систем, поведение которых зависит от текущего состояния и изменяется в ответ на события или входные данные.
- `State` (Состояние) - Условие или ситуация, в которой система находится в определённый момент времени.
- `Transition` (Переход) - Изменение состояния системы в ответ на событие или входное воздействие.
- `State Transition Diagram` (`STD`) (Диаграмма переходов состояний) - Визуальное представление всех возможных состояний системы и допустимых переходов между ними.
- `Event` (Событие) - Внешний или внутренний триггер, вызывающий переход между состояниями.

## Когда применять

- Система имеет **конечное число чётко определённых состояний**.
- Поведение системы **зависит от последовательности событий**, а не только от текущего ввода.
- Требования описывают **реакцию на события** в зависимости от текущего состояния.
- Примеры: авторизация (логин/логаут), заказ (создан → оплачен → отправлен → доставлен), лифт, игровой персонаж, конечные автоматы.

## Ключевые элементы диаграммы

- **Состояния** - Обозначаются прямоугольниками или закруглёнными блоками.
- **Начальное состояние** - Указывается стрелкой без источника.
- **Конечное состояние** - Может быть обозначено двойным кругом или специальным маркером.
- **Переходы** - Стрелки между состояниями, подписанные событием и/или действием (например, «Ввести пароль → Проверить»).
- **Условия перехода** - Логические выражения, определяющие, при каких условиях происходит переход.

## Подходы к тестированию

- **Покрытие всех состояний** - Убедиться, что каждое состояние может быть достигнуто.
- **Покрытие всех переходов** - Проверить каждый допустимый переход между состояниями.
- **Покрытие всех путей** - Протестировать все возможные последовательности переходов (часто ограничивают длину из-за комбинаторного взрыва).
- **Тестирование недопустимых переходов** - Попытаться выполнить переход, который не разрешён в текущем состоянии (например, повторный вход без выхода).

## Алгоритм создания тестов

1. **Анализ требований** для выявления состояний и событий.
2. **Построение диаграммы состояний** с указанием всех переходов.
3. **Создание таблицы состояний** (State Table) для формализации модели.
4. **Генерация тест-кейсов**:
  - Для каждого допустимого перехода
  - Для недопустимых переходов (негативные тесты)
  - Для граничных условий и исключительных ситуаций
5. **Оптимизация набора тестов** путем объединения в цепочки переходов.

## Преимущества

- **Наглядность** - Сложная логика состояний легко визуализируется.
- **Полнота** - Помогает выявить пропущенные или некорректные переходы.
- **Фокус на поведении** - Соответствует реальному пользовательскому опыту, где действия выполняются последовательно.
- **Раннее выявление дефектов** - Многие ошибки логики состояний обнаруживаются ещё на этапе проектирования диаграммы.

## Недостатки

- **Сложность при большом числе состояний** - Диаграмма становится громоздкой и трудной для анализа.
- **Не подходит для статических систем** - Неэффективна для систем, где состояние не играет ключевой роли.
- **Требует точных требований** - Необходимо чёткое понимание всех возможных состояний и событий.

## Лучшие практики

- Создавать диаграмму **совместно с аналитиками и разработчиками**.
- Использовать **стандартные нотации** (например, UML State Machine Diagrams).
- Интегрировать диаграммы в **спецификации требований** как живую документацию.
- Автоматизировать тесты на основе диаграммы, особенно для критических бизнес-процессов.
- Регулярно **обновлять диаграмму** при изменении бизнес-логики.

</details>

- `Use Case Testing` (Тестирование на основе сценариев использования): Тестирование типичных пользовательских сценариев (use cases) для проверки, удовлетворяет ли система своим целям и задачам.

### Методы белого ящика (White-box):
- `Statement Coverage` (Покрытие операторов/инструкций): Каждая строка кода должна быть выполнена хотя бы один раз.
- `Branch/Decision Coverage` (Покрытие ветвей/условий): Каждая возможная ветвь (true/false) в управляющих структурах (if, switch, циклы) должна быть выполнена хотя бы один раз.
- `Path Coverage` (Покрытие путей): Проверка всех возможных уникальных путей выполнения через блок кода. Часто нереализуемо на практике из-за комбинаторного взрыва.

### Методы, основанные на опыте (Experience-based):
- `Error Guessing` - `EG` (Предугадывание Ошибки): Использование опыта тестировщика, интуиции и знания системы для предположения о потенциальных дефектах и создание тестов под эти сценарии.
- `Exploratory Testing` - `ET` (Исследовательское тестирование): Одновременное изучение системы, проектирование тестов и их выполнение. Активность тестирования управляется идеями тестировщика, а не заранее написанными тест-кейсами.
- `Checklist-Based Testing` (Тестирование на основе чек-листов): Использование списка контрольных пунктов (чек-листа) для направления тестовой активности, но без строго прописанных шагов.

## Техники оптимизации и комбинирования:

<details>
  <summary>
    <b>Pairwise Testing (Попарное тестирование)</b>
  </summary>

## Основные понятия

- `Pairwise Testing` (Попарное тестирование) - Техника комбинаторного тестирования, основанная на предположении, что большинство дефектов вызывается взаимодействием значений **двух** параметров, а не всей их совокупности.
- `Combinatorial Testing` (Комбинаторное тестирование) - Общий класс методов, направленных на проверку различных комбинаций входных параметров.
- `All-Pairs Testing` (Тестирование всех пар) - Синоним попарного тестирования.

## Принцип работы

Вместо тестирования **всех возможных комбинаций** (что приводит к экспоненциальному росту числа тестов), попарное тестирование генерирует минимальный набор тестовых случаев, в котором **каждая возможная пара значений любых двух параметров встречается хотя бы один раз**.

### Пример

Допустим, у нас есть 3 параметра:
- Браузер: Chrome, Firefox, Safari
- ОС: Windows, macOS, Linux
- Язык: EN, RU

**Полный перебор**: 3 × 3 × 2 = **18 тестов**  
**Попарное тестирование**: ~**9–12 тестов** (в зависимости от алгоритма), при этом каждая пара (Браузер-ОС, Браузер-Язык, ОС-Язык) покрыта полностью.

## Когда применять

- При наличии **многих входных параметров** с несколькими значениями.
- Когда **полный перебор** непрактичен из-за времени или ресурсов.
- Для **конфигурационного тестирования** (разные ОС, браузеры, устройства).
- При **тестировании форм** с множеством зависимых полей.
- В **API-тестировании** с большим числом параметров запроса.

## Преимущества

- **Значительное сокращение** количества тест-кейсов (часто на 70–90%).
- **Высокая эффективность** — обнаруживает до 90% дефектов, вызванных взаимодействием двух параметров.
- **Ускорение** как создания, так и выполнения тестов.
- **Снижение затрат** на тестирование без существенной потери качества.
- **Лучшее покрытие**, чем случайный или интуитивный выбор тестов.

## Недостатки

- **Не гарантирует** обнаружение дефектов, вызванных взаимодействием **трёх и более** параметров.
- **Требует специальных инструментов** для генерации оптимальных наборов (вручную сложно).
- Может быть **избыточным** для простых систем с малым числом параметров.

## Популярные инструменты

- **PICT** (Microsoft) — консольный генератор тестовых наборов.
- **AllPairs** — простой скрипт для генерации попарных комбинаций.
- **Hexawise** — коммерческий инструмент с визуальным интерфейсом и расширенными возможностями.
- **TestRail**, **Xray**, **qTest** — системы управления тестами с поддержкой интеграции попарного тестирования.

## Лучшие практики

- Использовать **только после анализа требований** — не все параметры взаимодействуют.
- Исключать **несовместимые комбинации** (например, Safari на Windows).
- Комбинировать с **анализом граничных значений** и **эквивалентным разбиением**.
- Применять **иерархию приоритетов** — критические параметры можно тестировать с покрытием троек (`3-wise`).
- Интегрировать в **CI/CD pipeline** для автоматического генерирования и запуска тестов.

## Расширения метода

- `N-wise Testing` — обобщение метода для N параметров (например, 3-wise, 4-wise).
- `Orthogonal Arrays` (Ортогональные массивы) — математический подход к построению сбалансированных наборов комбинаций.
- `Risk-Based Pairwise Testing` — фокус на парах параметров с высоким риском.

</details>

- `Exhaustive Testing` (Исчерпывающее Тестирование): Теоретическая техника, предполагающая проверку ВСЕХ возможных комбинаций входных данных. На практике неприменима для нетривиальных систем.

</details>

<details>
  <summary>
    <b>Risk-based Testing (Тестирование на основе рисков)</b>
  </summary>

## Основные понятия

- `Risk-based Testing` (`RBT`) (Тестирование на основе рисков) - Методология, при которой объем, глубина и приоритеты тестирования определяются на основе анализа потенциальных рисков для продукта и проекта.
- `Risk Assessment` / `Risk Analysis` (Оценка / Анализ рисков) - Процесс идентификации, анализа и приоритизации рисков для определения их потенциального воздействия и вероятности возникновения.

## Основные категории рисков

- `Product Risks` / `Quality Risks` (Риски продукта / Риски качества) - Риски, связанные непосредственно с качеством и характеристиками разрабатываемого продукта (например, дефекты, уязвимости, низкая производительность).
- `Project Risks` (Риски проекта) - Риски, связанные с управлением и реализацией проекта (например, срывы сроков, превышение бюджета, нехватка квалифицированных ресурсов).

## Ключевые виды рисков продукта (Product Risks)

- `Functional Risks` (Функциональные риски) - Риск некорректной реализации или невыполнения ключевых функций продукта, что делает его непригодным для использования.
- `Security Risks` (Риски безопасности) - Риск наличия уязвимостей, которые могут привести к утечке данных, несанкционированному доступу или атакам на систему.
- `Performance Risks` (Риски производительности) - Риск, что система не будет соответствовать требованиям по скорости, времени отклика, стабильности или масштабируемости под нагрузкой.
- `Technical Risks` / `Architectural Risks` (Технические / Архитектурные риски) - Риски, вызванные сложностью, новизной технологий, ошибками в проектировании или интеграцией со сторонними системами.
- `Usability & UX Risks` (Риски удобства использования) - Риск создания продукта с плохим пользовательским интерфейсом, что приведет к неудовлетворенности и оттоку пользователей.
- `Compliance & Legal Risks` (Риски соответствия / Правовые риски) - Риск несоответствия продукта законодательным нормам, отраслевым стандартам или лицензионным соглашениям.

## Ключевые виды рисков проекта (Project Risks)

- `Schedule & Time Risks` (Риски графика) - Риск срыва сроков релиза из-за переоценки возможностей, изменения требований или технических сложностей.
- `Budget & Financial Risks` (Бюджетные / Финансовые риски) - Риск превышения бюджета проекта из-за доработок, увеличения команды или внешних факторов.
- `Resource & People Risks` (Ресурсные / Кадровые риски) - Риск, связанный с нехваткой, недостаточной квалификацией или текучестью членов команды (тестировщиков, разработчиков).
- `Requirements & Scope Risks` (Риски требований / Объема работ) - Риск нечетких, постоянно меняющихся или противоречивых требований, ведущих к непониманию и ошибкам.

## Процесс и практики

- `Risk Priority Number` (`RPN`) (Приоритетное число риска) - Числовая оценка риска, часто рассчитываемая как произведение его Вероятности (Probability) и Влияния (Impact).
- `Risk Mitigation` (Смягчение рисков) - Действия, направленные на снижение вероятности возникновения риска или минимизацию его негативных последствий.
- `Test Prioritization` (Приоритизация тестирования) - Распределение усилий по тестированию: высокоприоритетные тесты покрывают области с наибольшим уровнем риска.
- `Residual Risk` (Остаточный риск) - Риск, который остается после применения всех запланированных мер по его смягчению. Осознанное решение, принимаемое заинтересованными сторонами.

</details>

<details>
  <summary>
    <b>Root Cause Analysis (RCA) (Анализ первопричин)</b>
  </summary>

## Основные понятия

- `Root Cause Analysis` (`RCA`) (Анализ первопричин) - Систематический подход к выявлению фундаментальных (корневых) причин инцидентов, дефектов или сбоев с целью их устранения и предотвращения повторного возникновения.
- `Incident` (Инцидент) - Любое нежелательное событие, нарушающее нормальное функционирование системы (например, сбой в production, утечка данных, критический баг).

## Цели и значение RCA

- `Prevent Recurrence` (Предотвращение повторения) - Главная цель — не просто исправить проявление проблемы, а устранить её источник, чтобы она больше не возникала.
- `Improve Quality` (Повышение качества) - Устранение системных недостатков напрямую ведет к повышению надежности и стабильности продукта.
- `Enhance Processes` (Совершенствование процессов) - Выявленные причины часто указывают на слабые места в процессах разработки, тестирования или эксплуатации, что дает возможность их улучшить.
- `Reduce Costs` (Снижение затрат) - Решение проблемы на корню гораздо дешевле, чем постоянная борьба с её последствиями.

## Процесс проведения RCA (5 этапов)

1. **Определение проблемы и её влияния**  
   Четко сформулируйте, что пошло не так, и оцените воздействие на бизнес-цели (финансы, репутация, пользователи).

2. **Поиск вероятных причин**  
   Проведите мозговой штурм или используйте структурированные методы (например, диаграмму Исикавы) для генерации списка потенциальных причин.

3. **Сбор информации и анализ**  
   Соберите данные (логи, метрики, отчеты, свидетельства), чтобы подтвердить или опровергнуть каждую из вероятных причин.

4. **Причинно-следственный анализ**  
   Используйте техники вроде «5 Почему» или FMEA, чтобы углубиться от симптомов к истинной первопричине.

5. **Разработка и внедрение решений**  
   Выберите наиболее эффективные корректирующие и превентивные действия, назначьте ответственных и сроки, а затем отслеживайте их эффективность.

## Преимущества RCA

- Создает культуру ответственности и непрерывного улучшения.
- Повышает прозрачность и предсказуемость процессов разработки.
- Снижает количество инцидентов в production-среде.
- Повышает доверие клиентов и заинтересованных сторон к продукту и команде.

## Когда проводить RCA

- После критических сбоев в production.
- При обнаружении повторяющихся или хронических дефектов.
- В рамках ретроспективы спринта или завершения проекта.
- При значительном отклонении от плановых показателей качества или сроков.

</details>