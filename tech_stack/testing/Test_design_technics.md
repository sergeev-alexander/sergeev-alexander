# Test-Design technics (Техники тест-дизайна)

> Тест-дизайн – это этап процесса тестирования ПО, на котором проектируются и создаются тест-кейсы, в соответствии с определёнными ранее критериями качества и целями тестирования.

## Ключевые концепции:

- Тест-аналитик: Определяет "Что тестировать?".
- Тест-дизайнер: Определяет "Как тестировать?".
- Тестовое покрытие (`Test Coverage`): Метрика, оценивающая полноту тестирования.
    - Покрытие требований (`Requirements Coverage`): Оценка по трассировке тестов к функциональным требованиям.
    - Покрытие кода (`Code Coverage`): Оценка по проценту исполненного кода в тестах.

## Классификация техник тест-дизайна (по источнику знаний)

1.  **Методы чёрного ящика (Black-box, спецификационные):** Фокусируются на поведении системы (вход -> выход) без знания внутреннего устройства.
2.  **Методы белого ящика (White-box, структурные):** Основаны на знании внутренней структуры кода, логики программы. (Требуют навыков программирования. *В вашем текущем блоке отсутствуют, стоит добавить ключевые*).
3.  **Методы, основанные на опыте (Experience-based):** Используют знания и интуицию тестировщиков, пользователей, экспертов.

## Основные техники тест-дизайна:

### Методы чёрного ящика (Black-box):

<details>
  <summary>
    <b>Equivalence Partitioning & Boundary Value Analysis (Эквивалентное разбиение и анализ граничных значений)</b>
  </summary>

## Основные понятия

- `Equivalence Partitioning` (`EP`) (Эквивалентное разбиение) - Техника чёрного ящика, при которой входные данные делятся на группы (классы эквивалентности), где все значения в группе ожидаются вызывать одинаковое поведение системы.
- `Boundary Value Analysis` (`BVA`) (Анализ граничных значений) - Техника тестирования, фокусирующаяся на проверке значений на границах классов эквивалентности, так как ошибки чаще всего возникают именно на границах.

## Принципы эквивалентного разбиения

- **Валидные классы** - Наборы входных данных, которые должны быть приняты системой.
- **Невалидные классы** - Наборы входных данных, которые должны быть отклонены системой.
- **Одно значение на класс** - Достаточно протестировать одно значение из каждого класса, так как все значения в классе считаются эквивалентными.

## Принципы анализа граничных значений

- **Минимум и максимум** - Проверяются минимальное и максимальное допустимые значения.
- **Границы +1 и -1** - Проверяются значения, непосредственно примыкающие к границам с обеих сторон (например, min-1, min, min+1, max-1, max, max+1).
- **Применимость** - Используется для любых упорядоченных типов данных: числа, даты, строки (по длине).

## Когда применять

- При наличии **ограничений на входные данные** (диапазоны, списки, форматы).
- Для **поля ввода с четкими правилами валидации**.
- На **любом уровне тестирования** (модульном, интеграционном, системном).
- В сочетании с другими техниками тест-дизайна для повышения покрытия.

## Алгоритм применения

1. **Определить все входные параметры** тестируемой функции.
2. **Выделить классы эквивалентности** для каждого параметра (валидные и невалидные).
3. **Определить граничные значения** для каждого класса.
4. **Создать тест-кейсы**:
- По одному значению из каждого класса эквивалентности.
- Все граничные значения и их соседи.
5. **Оптимизировать набор тестов**, удаляя дублирующиеся или избыточные проверки.

## Преимущества

- **Снижение количества тестов** - Значительно уменьшает объем тестовых данных без потери качества.
- **Фокус на рисках** - Концентрирует внимание на наиболее уязвимых местах (границах).
- **Простота и эффективность** - Легко понимается и применяется даже начинающими тестировщиками.
- **Систематический подход** - Обеспечивает структурированное и полное покрытие требований.

## Примеры классов эквивалентности

- **Числовые диапазоны**: [1-10] → валидный, [≤0], [11-99], [≥100] → невалидные.
- **Длина строки**: [6-10 символов] → валидная, [0-5], [11+] → невалидные.
- **Списки выбора**: Выбранный элемент из списка → валидный, ввод несуществующего значения → невалидный.
- **Форматы данных**: Корректный email → валидный, некорректный формат → невалидный.

## Лучшие практики

- Всегда использовать **BVA вместе с EP** для максимальной эффективности.
- Учитывать **специфические бизнес-правила**, которые могут создавать дополнительные классы.
- Проверять **комбинации входных параметров** с помощью других техник (например, таблиц решений), если параметры взаимозависимы.
- Документировать **логику выделения классов** для обеспечения прозрачности и прослеживаемости.

</details>

<details>
  <summary>
    <b>Decision Table Testing (Таблицы решений / Принятия решений): Формализация бизнес-логики, где комбинации входных условий (причин) определяют выходные действия (следствия). Более формализованная и полная версия Cause/Effect</b>
  </summary>

## Основные понятия

- `Decision Table` (Таблица решений) - Техника чёрного ящика для проектирования тестов, основанная на анализе комбинаций входных условий и соответствующих им действий или выходных результатов.
- `Combinatorial Testing` (Комбинаторное тестирование) - Подход, направленный на проверку различных комбинаций входных параметров для выявления сложных дефектов.

## Когда применять

- В бизнес-логике присутствуют **сложные правила**, зависящие от нескольких условий.
- Требования описывают **разные исходы** в зависимости от комбинации факторов.
- Необходимо обеспечить **полное покрытие** всех возможных сценариев принятия решений.
- Примеры: расчет скидок, определение тарифов, валидация форм с множеством зависимых полей, обработка заказов.

## Структура таблицы решений

1. **Condition Stubs** (Заголовки условий) - Список входных условий или предпосылок.
2. **Condition Entries** (Входные значения условий) - Комбинации значений (обычно "Да/Нет", "Истина/Ложь", "0/1").
3. **Action Stubs** (Заголовки действий) - Список возможных системных реакций или выходных результатов.
4. **Action Entries** (Выходные значения действий) - Указание, какое действие выполняется при каждой комбинации условий.

## Алгоритм построения

1. **Идентифицировать все условия** из требований.
2. **Определить все возможные действия** системы.
3. **Рассчитать количество комбинаций**: N = V₁ × V₂ × ... × Vₙ, где V — количество значений для каждого условия.
4. **Построить таблицу** и заполнить колонки всеми уникальными комбинациями условий.
5. **Определить действия** для каждой комбинации на основе бизнес-правил.
6. **Оптимизировать таблицу**:
- Удалить невозможные или противоречивые комбинации.
- Объединить столбцы с одинаковыми результатами.
- Уточнить неоднозначные случаи у аналитиков.

## Преимущества

- **Полнота покрытия** - Гарантирует, что не будет упущена ни одна логическая комбинация.
- **Наглядность** - Сложная логика представляется в простой и структурированной форме.
- **Простота преобразования в тест-кейсы** - Каждый столбец таблицы напрямую соответствует одному тест-кейсу.
- **Универсальность** - Может быть реализована с помощью любых табличных инструментов (Excel, Google Sheets).

## Недостатки

- **Экспоненциальный рост** - При большом количестве условий число комбинаций становится непрактичным (проблема "комбинаторного взрыва").
- **Трудоёмкость** - Требует значительных временных затрат на анализ и построение.
- **Не подходит для простых сценариев** - Избыточна для линейных процессов с одним или двумя условиями.

## Лучшие практики

- Использовать технику **парного тестирования** (`Pairwise Testing`) для сокращения числа комбинаций при большом количестве входных параметров.
- Активно сотрудничать с **бизнес-аналитиками** для уточнения правил и устранения неоднозначностей.
- Интегрировать таблицы решений в **спецификации требований** как живую документацию.
- Рассматривать каждую строку таблицы как **спецификацию для автоматизированного теста**.

</details>

<details>
  <summary>
    <b>State Transition Testing (Тестирование перехода состояний)</b>
  </summary>

## Основные понятия

- `State Transition Testing` (Тестирование перехода состояний) - Техника чёрного ящика, используемая для тестирования систем, поведение которых зависит от текущего состояния и изменяется в ответ на события или входные данные.
- `State` (Состояние) - Условие или ситуация, в которой система находится в определённый момент времени.
- `Transition` (Переход) - Изменение состояния системы в ответ на событие или входное воздействие.
- `State Transition Diagram` (`STD`) (Диаграмма переходов состояний) - Визуальное представление всех возможных состояний системы и допустимых переходов между ними.
- `Event` (Событие) - Внешний или внутренний триггер, вызывающий переход между состояниями.

## Когда применять

- Система имеет **конечное число чётко определённых состояний**.
- Поведение системы **зависит от последовательности событий**, а не только от текущего ввода.
- Требования описывают **реакцию на события** в зависимости от текущего состояния.
- Примеры: авторизация (логин/логаут), заказ (создан → оплачен → отправлен → доставлен), лифт, игровой персонаж, конечные автоматы.

## Ключевые элементы диаграммы

- **Состояния** - Обозначаются прямоугольниками или закруглёнными блоками.
- **Начальное состояние** - Указывается стрелкой без источника.
- **Конечное состояние** - Может быть обозначено двойным кругом или специальным маркером.
- **Переходы** - Стрелки между состояниями, подписанные событием и/или действием (например, «Ввести пароль → Проверить»).
- **Условия перехода** - Логические выражения, определяющие, при каких условиях происходит переход.

## Подходы к тестированию

- **Покрытие всех состояний** - Убедиться, что каждое состояние может быть достигнуто.
- **Покрытие всех переходов** - Проверить каждый допустимый переход между состояниями.
- **Покрытие всех путей** - Протестировать все возможные последовательности переходов (часто ограничивают длину из-за комбинаторного взрыва).
- **Тестирование недопустимых переходов** - Попытаться выполнить переход, который не разрешён в текущем состоянии (например, повторный вход без выхода).

## Алгоритм создания тестов

1. **Анализ требований** для выявления состояний и событий.
2. **Построение диаграммы состояний** с указанием всех переходов.
3. **Создание таблицы состояний** (State Table) для формализации модели.
4. **Генерация тест-кейсов**:
- Для каждого допустимого перехода
- Для недопустимых переходов (негативные тесты)
- Для граничных условий и исключительных ситуаций
5. **Оптимизация набора тестов** путем объединения в цепочки переходов.

## Преимущества

- **Наглядность** - Сложная логика состояний легко визуализируется.
- **Полнота** - Помогает выявить пропущенные или некорректные переходы.
- **Фокус на поведении** - Соответствует реальному пользовательскому опыту, где действия выполняются последовательно.
- **Раннее выявление дефектов** - Многие ошибки логики состояний обнаруживаются ещё на этапе проектирования диаграммы.

## Недостатки

- **Сложность при большом числе состояний** - Диаграмма становится громоздкой и трудной для анализа.
- **Не подходит для статических систем** - Неэффективна для систем, где состояние не играет ключевой роли.
- **Требует точных требований** - Необходимо чёткое понимание всех возможных состояний и событий.

## Лучшие практики

- Создавать диаграмму **совместно с аналитиками и разработчиками**.
- Использовать **стандартные нотации** (например, UML State Machine Diagrams).
- Интегрировать диаграммы в **спецификации требований** как живую документацию.
- Автоматизировать тесты на основе диаграммы, особенно для критических бизнес-процессов.
- Регулярно **обновлять диаграмму** при изменении бизнес-логики.

</details>

- `Use Case Testing` (Тестирование на основе сценариев использования): Тестирование типичных пользовательских сценариев (use cases) для проверки, удовлетворяет ли система своим целям и задачам.

### Методы белого ящика (White-box):
- `Statement Coverage` (Покрытие операторов/инструкций): Каждая строка кода должна быть выполнена хотя бы один раз.
- `Branch/Decision Coverage` (Покрытие ветвей/условий): Каждая возможная ветвь (true/false) в управляющих структурах (if, switch, циклы) должна быть выполнена хотя бы один раз.
- `Path Coverage` (Покрытие путей): Проверка всех возможных уникальных путей выполнения через блок кода. Часто нереализуемо на практике из-за комбинаторного взрыва.

### Методы, основанные на опыте (Experience-based):
- `Error Guessing` - `EG` (Предугадывание Ошибки): Использование опыта тестировщика, интуиции и знания системы для предположения о потенциальных дефектах и создание тестов под эти сценарии.
- `Exploratory Testing` - `ET` (Исследовательское тестирование): Одновременное изучение системы, проектирование тестов и их выполнение. Активность тестирования управляется идеями тестировщика, а не заранее написанными тест-кейсами.
- `Checklist-Based Testing` (Тестирование на основе чек-листов): Использование списка контрольных пунктов (чек-листа) для направления тестовой активности, но без строго прописанных шагов.

## Техники оптимизации и комбинирования:

<details>
  <summary>
    <b>Pairwise Testing (Попарное тестирование)</b>
  </summary>

## Основные понятия

- `Pairwise Testing` (Попарное тестирование) - Техника комбинаторного тестирования, основанная на предположении, что большинство дефектов вызывается взаимодействием значений **двух** параметров, а не всей их совокупности.
- `Combinatorial Testing` (Комбинаторное тестирование) - Общий класс методов, направленных на проверку различных комбинаций входных параметров.
- `All-Pairs Testing` (Тестирование всех пар) - Синоним попарного тестирования.

## Принцип работы

Вместо тестирования **всех возможных комбинаций** (что приводит к экспоненциальному росту числа тестов), попарное тестирование генерирует минимальный набор тестовых случаев, в котором **каждая возможная пара значений любых двух параметров встречается хотя бы один раз**.

### Пример

Допустим, у нас есть 3 параметра:
- Браузер: Chrome, Firefox, Safari
- ОС: Windows, macOS, Linux
- Язык: EN, RU

**Полный перебор**: 3 × 3 × 2 = **18 тестов**  
**Попарное тестирование**: ~**9–12 тестов** (в зависимости от алгоритма), при этом каждая пара (Браузер-ОС, Браузер-Язык, ОС-Язык) покрыта полностью.

## Когда применять

- При наличии **многих входных параметров** с несколькими значениями.
- Когда **полный перебор** непрактичен из-за времени или ресурсов.
- Для **конфигурационного тестирования** (разные ОС, браузеры, устройства).
- При **тестировании форм** с множеством зависимых полей.
- В **API-тестировании** с большим числом параметров запроса.

## Преимущества

- **Значительное сокращение** количества тест-кейсов (часто на 70–90%).
- **Высокая эффективность** — обнаруживает до 90% дефектов, вызванных взаимодействием двух параметров.
- **Ускорение** как создания, так и выполнения тестов.
- **Снижение затрат** на тестирование без существенной потери качества.
- **Лучшее покрытие**, чем случайный или интуитивный выбор тестов.

## Недостатки

- **Не гарантирует** обнаружение дефектов, вызванных взаимодействием **трёх и более** параметров.
- **Требует специальных инструментов** для генерации оптимальных наборов (вручную сложно).
- Может быть **избыточным** для простых систем с малым числом параметров.

## Популярные инструменты

- **PICT** (Microsoft) — консольный генератор тестовых наборов.
- **AllPairs** — простой скрипт для генерации попарных комбинаций.
- **Hexawise** — коммерческий инструмент с визуальным интерфейсом и расширенными возможностями.
- **TestRail**, **Xray**, **qTest** — системы управления тестами с поддержкой интеграции попарного тестирования.

## Лучшие практики

- Использовать **только после анализа требований** — не все параметры взаимодействуют.
- Исключать **несовместимые комбинации** (например, Safari на Windows).
- Комбинировать с **анализом граничных значений** и **эквивалентным разбиением**.
- Применять **иерархию приоритетов** — критические параметры можно тестировать с покрытием троек (`3-wise`).
- Интегрировать в **CI/CD pipeline** для автоматического генерирования и запуска тестов.

## Расширения метода

- `N-wise Testing` — обобщение метода для N параметров (например, 3-wise, 4-wise).
- `Orthogonal Arrays` (Ортогональные массивы) — математический подход к построению сбалансированных наборов комбинаций.
- `Risk-Based Pairwise Testing` — фокус на парах параметров с высоким риском.

</details>

- `Exhaustive Testing` (Исчерпывающее Тестирование): Теоретическая техника, предполагающая проверку ВСЕХ возможных комбинаций входных данных. На практике неприменима для нетривиальных систем.