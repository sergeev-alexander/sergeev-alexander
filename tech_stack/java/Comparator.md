<details>
    <summary>
        <b>Type Inference с Comparator</b>
    </summary>

# Type Inference с Comparator

## Type Inference (Вывод типов)

> Type Inference - это механизм вывода типов в Java, позволяющий
компилятору автоматически определять параметры обобщений
(generic-параметры) без явного указания. 
> 
> Механизм включается при вызове обобщённых методов, использовании
лямбда-выражений, method references, Stream API и многих других
конструкций, где тип может быть выведен из окружающего контекста.

### Основные характеристики Type Inference

-   Вывод ограничен **контекстом конкретного вызова метода** (invocation
    type inference).
-   Не распространяется на цепочку вызовов целиком.
-   Не выполняет повторный вывод типов после получения новых данных из
    последующих вызовов.
-   Method references требуют максимально полного контекста для
    успешного вывода типа.
-   Если контекст неполный или неоднозначный - вывод типов
    прекращается с ошибкой.

---

## Примеры с Comparator и Map.Entry<String, Double>

``` java
Map.Entry<String, Double> entry = ...
```

### Работает:

``` java
.sorted(Comparator.comparing(Map.Entry::getValue))
```

### Не работает:

``` java
.sorted(Comparator.comparing(Map.Entry::getValue).reversed())
```

---

## Почему первый вариант компилируется

Метод `comparing` имеет сигнатуру:

``` java
static <T, U extends Comparable<? super U>> Comparator<T> comparing(Function<? super T, ? extends U> keyExtractor)
```

Компилятор успешно выводит: - `T = Map.Entry<String, Double>` -
`U = Double`

Метод `Map.Entry::getValue` интерпретируется как
`Function<Map.Entry<String, Double>, Double>`, поскольку в момент вызова
`comparing(...)` уже известен контекст - тип элементов стрима.

Вывод типа консистентен, ограничений нет, метод подходит.

------------------------------------------------------------------------

## Почему `.reversed()` ломает вывод типов

``` java
Comparator.comparing(Map.Entry::getValue).reversed()
```

### Ключевые моменты:

1.  `Map.Entry::getValue` **не имеет собственного типа** --- его тип
    выводится из контекста.
2.  Вывод типа происходит **только в рамках вызова comparing(...)**, а
    не всего выражения.
3.  После того как тип `Comparator<T>` должен передаваться дальше, Java
    не выполняет повторный анализ типа `Map.Entry::getValue`.
4.  Метод `.reversed()` вызывается уже после завершения inference для
    `comparing(...)`.
5.  Контекст, доступный для вывода типа на втором шаге, неполон, и Java
    не может реконструировать `T`.

>`.reversed()` требует, чтобы тип `Comparator<T>` был уже полностью
определён. Однако `T` был выведен только в рамках одного вызова
`comparing`, и компилятор не переносит inferred типы между вызовами -
они локальны, а не глобальны.

---

## Почему альтернативные варианты работают

Все рабочие варианты из примеров имеют общее свойство - они помогают компилятору получить недостающие сведения о типе.

### Пример 1: Явное указание типа

``` java
Comparator.<Map.Entry<String, Double>>comparing(Map.Entry::getValue).reversed()
```

Вывод типа полностью определён пользователем.

### Пример 2: Специализированный comparingDouble

``` java
Comparator.comparingDouble(Map.Entry::getValue).reversed()
```

Этот метод принимает `ToDoubleFunction`, а не `Function<T, U>`, поэтому
generic-вывода почти нет.

### Пример 3: comparingByValue

``` java
Map.Entry.<String, Double>comparingByValue().reversed()
```

Типы указаны явно в сигнатуре.

---

    Вызов #1: comparing(...)
        |
        |— method reference (не имеет типа сам по себе)
        |— вывод T и U
        V
    Получен Comparator<T>

    Вызов #2: reversed()
        |
        |— компилятор требует "готовый" Comparator<T>
        |— повторный вывод T невозможен
        X ошибка inference

---

## Другие области, где Type Inference часто ломается

### Stream API

- Цепочки вызовов `map`, `collect`, `flatMap`, `groupingBy` и др. могут давать ошибки, если типы производных функций неочевидны.

### Optional

- Возврат разных типов в ветвях `map / orElse` приводит к неоднозначности типов.

### Collections API (`List.of`, `Map.of`)

- Если типы элементов различны - inference невозможен.

### Лямбды с перегруженными методами

- Контекст может быть недостаточным, чтобы решить, под какую сигнатуру подходит лямбда.

### Method references в generic-контекстах

Например, `Function.identity()` часто ломает вывод типов в цепочках,
если тип не указан явно.

---

## Type Inference

> Type Inference выполняется **строго на уровне одиночного вызова**.

- Контекст subsequent-инструкций не пересматривает inferred типы предыдущих выражений.
- Java не делает global inference для выражений вида `A().B().C()`.
- Лямбда и method reference не являются полноценными типизированными выражениями - они требуют target-type для вывода.

### Method Invocation Expressions

Определяет: 
- как выбирается перегруженный метод 
- как применяется generic-метод 
- как работает applicability testing

Ключевое следствие: **каждый вызов метод-инструкции рассматривается
отдельно**, что объясняет невозможность использовать контекст вызова
`.reversed()` для уточнения типа в `comparing`.

---

## Ограничения

-   inferencing в Java работает только локально на уровне вызова метода;
-   method references требуют точного target type в момент вызова;
-   повторный вывод типов для последующих методов невозможен;
-   цепочки вызовов generic-методов без явного контекста приводят к потере информации о типах.

</details>