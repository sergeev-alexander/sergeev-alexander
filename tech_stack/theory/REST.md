# `REST` (Representational State Transfer)

REST - это архитектурный стиль для проектирования распределённых гипермедиа-систем, впервые описанный Роем Филдингом в
его диссертации 2000 года.

Он не является протоколом или стандартом, а представляет собой набор ограничений (constraints), соблюдение которых
приводит к системам с желаемыми свойствами: масштабируемостью, простотой, надёжностью и возможностью кэширования.

<details>
    <summary>
        <b>Шесть основных ограничений REST</b>
    </summary>

Чтобы система считалась truly RESTful, она должна удовлетворять шести ограничениям:

### 1. Client–Server (Клиент–Сервер)

- Разделение ответственности: клиент отвечает за UI/UX, сервер - за хранение данных и бизнес-логику.
- Позволяет масштабировать клиенты и серверы независимо.
- Взаимодействие происходит только через единый интерфейс.

### 2. Stateless (Без состояния)

- Каждый запрос от клиента к серверу должен содержать всю информацию, необходимую для его обработки.
- Сервер не хранит контекст между запросами (например, сессии в памяти).
- Состояние сеанса (если нужно) хранится на клиенте и передаётся явно (например, через токен).
- Преимущества: упрощает масштабирование, повышает надёжность.

### 3. Cacheable (Кэшируемость)

- Ответы от сервера должны быть явно помечены как кэшируемые или некэшируемые.
- Клиент (или промежуточный прокси) может повторно использовать кэшированные ответы, уменьшая задержки и нагрузку.
- REST опирается на встроенные механизмы кэширования HTTP (заголовки Cache-Control, ETag, Last-Modified и др.).

### 4. Uniform Interface (Единый интерфейс)

Самое важное и отличительное ограничение REST.<br>
Достигается через четыре подограничения:

- **Идентификация ресурсов**<br>
  Каждый ресурс (например, пользователь, заказ) идентифицируется URI (например, /users/123).
- **Манипуляция ресурсами через представления**<br>
  Клиент получает представление ресурса (например, JSON-объект), а не сам ресурс.
  На основе этого представления он может изменить состояние ресурса, отправив новое представление.
- **Самоописываемые сообщения**<br>
  Каждое сообщение содержит достаточно информации для его обработки: HTTP-метод, URI, заголовки (включая Content-Type,
  Accept) и тело.
- **Гипермедиа как движок состояния приложения (HATEOAS)**<br>
  Клиент переходит от состояния к состоянию, следуя гиперссылкам, возвращаемым сервером (например, _links в ответе).
  Это позволяет эволюционировать API без жёсткой привязки клиента к URI.

Почему HATEOAS редко используют?

- Сложность на клиенте: клиент должен "парсить" действия, а не вызывать жёстко заданные методы.
- Отладка и документирование: Swagger/OpenAPI плохо описывают динамические ссылки.
- Привычки разработчиков: проще "знать URI заранее".
- Мобильные и фронтенд-команды часто предпочитают стабильный контракт поверх гибкости.

### 5. Layered System (Многоуровневая система)

- Клиент не знает, взаимодействует ли он напрямую с сервером или через промежуточные слои (прокси, шлюзы,
  балансировщики).
- Позволяет внедрять безопасность, кэширование, мониторинг без изменения клиентского кода.

### 6. Code on Demand (опционально)

- Сервер может передавать клиенту исполняемый код (например, JavaScript), чтобы расширить его функциональность.
- Это единственное необязательное ограничение.
- Редко используется в современных REST API (чаще в веб-приложениях с динамическим UI).

</details>

<details>
    <summary>
        <b>Ключевые понятия REST</b>
    </summary>

### Ресурс (Resource)

Любая информация, которая может быть названа и идентифицирована URI: документ, изображение, коллекция, сервис и т.д.

Любая концепция или сущность, которая может быть идентифицирована с помощью URI.

Примеры:

- Пользователь (`/users/42`)
- Коллекция заказов (`/orders`)
- Изображение (`/images/logo.png`)
- Служба или абстрактная операция (`/search`, если она ведёт себя как ресурс-коллекция результатов)

В REST всё - это ресурс.
Даже поиск или вычисление может быть представлено как ресурс-коллекция, параметры которого передаются через
query-строку (`/search?q=java`).

### Представление (Representation)

Конкретная сериализованная форма ресурса в определённый момент времени (например, JSON, XML, HTML).

Один и тот же ресурс может иметь множество представлений: JSON для мобильного клиента, XML для legacy-системы, HTML для
браузера.

Клиент указывает желаемый формат через заголовок Accept (content negotiation).

Сервер указывает формат в Content-Type.

```
Запрос:

GET /users/42
Accept: application/json

Ответ:

HTTP/1.1 200 OK
Content-Type: application/json

{
    "id": 42, 
    "name": "Alex"
}
```

### HTTP-методы как глаголы

HTTP-методы в REST (Uniform Interface)
REST использует стандартные HTTP-методы как единый интерфейс для манипуляции ресурсами.

Каждый метод имеет чёткую семантику, безопасность и идемпотентность.

- Безопасный метод - не изменяет состояние сервера (например, GET).
- Идемпотентный метод - повторный вызов даёт тот же результат, что и первый (GET, PUT, DELETE).

REST-совместимость требует соблюдения этой семантики.

| Метод       | Семантика                                                                              | Безопасный |                                                                 Идемпотентный                                                                  | Кэшируемый | Типичные коды ответов        | Пример                                                                                                  | Примечания                                                                                                                                                            |
|:------------|:---------------------------------------------------------------------------------------|:----------:|:----------------------------------------------------------------------------------------------------------------------------------------------:|:----------:|:-----------------------------|:--------------------------------------------------------------------------------------------------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **GET**     | Получить представление ресурса или коллекции                                           |    ✅ Да    |                                                                      ✅ Да                                                                      |    ✅ Да    | 200, 404, 304 (Not Modified) | `GET /users/42`<br>→ получает данные пользователя                                                       | Не должен изменять состояние. Может кэшироваться.                                                                                                                     |
| **HEAD**    | То же, что GET, но без тела ответа - только заголовки                                  |    ✅ Да    |                                                                      ✅ Да                                                                      |    ✅ Да    | 200, 404, 304                | `HEAD /documents/report.pdf`<br>→ проверить существование и размер                                      | Используется для проверки метаданных (например, Content-Length, ETag) без передачи данных.                                                                            |
| **POST**    | Создать новый ресурс внутри коллекции ИЛИ выполнить неидемпотентную обработку          |   ❌ Нет    |                                                                     ❌ Нет                                                                      |   ❌ Нет    | 201, 200, 202, 400, 409      | `POST /users`<br>→ создаёт нового пользователя<br><br>`POST /orders/123/cancel`<br>→ выполняет действие | В классическом REST: создание подресурса. В прагматичном REST: также используется для "действий", если нет лучшего способа.                                           |
| **PUT**     | Полностью заменить ресурс по указанному URI. Клиент отправляет полное представление    |   ❌ Нет    |                                                                      ✅ Да                                                                      |   ❌ Нет    | 200, 201, 204, 400, 404      | `PUT /users/42`<br>→ обновляет пользователя целиком                                                     | Если ресурса нет, может создать его (если URI известен клиенту).                                                                                                      |
| **PATCH**   | Частично обновить ресурс. Отправляет инструкции по изменению (не полное представление) |   ❌ Нет    | ⚠️ PATCH - единственный HTTP метод, идемпотентность которого не определена жестко в спецификации, а зависит от конкретной реализации операций. |   ❌ Нет    | 200, 204, 400, 404, 422      | `PATCH /users/42`<br>→ обновляет только поле email                                                      | Идемпотентность зависит от реализации:<br>• `{"op": "replace", "path": "/email", "value": "..."}` - идемпотентна<br>• `{"op": "increment", "path": "/counter"}` - нет |
| **DELETE**  | Удалить ресурс                                                                         |   ❌ Нет    |                                                                      ✅ Да                                                                      |   ❌ Нет    | 200, 204, 404, 410           | `DELETE /users/42`<br>→ удаляет пользователя                                                            | Повторный вызов не должен вызывать ошибку (возвращается 204 или 404).                                                                                                 |
| **OPTIONS** | Получить информацию о поддерживаемых методах для ресурса                               |    ✅ Да    |                                                                      ✅ Да                                                                      |    ✅ Да    | 200, 204                     | `OPTIONS /users`<br>→ возвращает `Allow: GET, POST, HEAD`                                               | Используется для проверки возможностей API и CORS preflight. Поддерживается в REST, но редко реализуется явно.                                                        |

### HTTP статус-коды в REST

|   Код   | Название              | Описание                                        | Пример использования                                           |
|:-------:|:----------------------|:------------------------------------------------|:---------------------------------------------------------------|
| **200** | OK                    | Успешный запрос с телом                         | `GET /users/42` → возвращает данные пользователя               |
| **201** | Created               | Ресурс успешно создан                           | `POST /users` → с заголовком `Location: /users/43`             |
| **202** | Accepted              | Запрос принят, но обработка асинхронна          | Запрос в очередь обработки (редко в синхронных REST API)       |
| **204** | No Content            | Успешно, но без тела                            | `DELETE /users/42` или `PUT`, если сервер не возвращает данные |
| **304** | Not Modified          | Кэш актуален (условный GET)                     | При использовании `If-None-Match` или `If-Modified-Since`      |
| **400** | Bad Request           | Ошибка в теле запроса/параметрах                | Некорректный JSON, отсутствует обязательное поле               |
| **401** | Unauthorized          | Требуется аутентификация                        | Отсутствует или недействителен токен                           |
| **403** | Forbidden             | Доступ запрещён (аутентифицирован, но нет прав) | Пользователь не может удалить чужой пост                       |
| **404** | Not Found             | Ресурс не существует                            | `GET /users/999` — пользователя нет                            |
| **405** | Method Not Allowed    | Метод не поддерживается для этого URI           | `DELETE /search` — нельзя удалять поиск                        |
| **409** | Conflict              | Конфликт состояния                              | Попытка создать пользователя с уже существующим email          |
| **422** | Unprocessable Entity  | Семантическая ошибка в данных                   | Валидный JSON, но нарушены бизнес-правила                      |
| **500** | Internal Server Error | Внутренняя ошибка сервера                       | Исключение в коде сервера                                      |

</details>

<details>
    <summary>
        <b>REST в Spring Boot</b>
    </summary>

### Ресурс-ориентированная модель

В Spring REST-контроллеры создаются через аннотации, где каждый метод — операция над ресурсом.

- URI выражают ресурсы, а не действия.
- HTTP-методы соответствуют семантике.

```java

@RestController
@RequestMapping("/users")
public class UserController {

    @GetMapping("/{id}")        // GET /users/42
    public User getUser(@PathVariable Long id) { ...}

    @PostMapping                // POST /users
    public ResponseEntity<User> createUser(@RequestBody User user) { ...}

    @PutMapping("/{id}")        // PUT /users/42
    public User updateUser(@PathVariable Long id, @RequestBody User user) { ...}

    @DeleteMapping("/{id}")     // DELETE /users/42
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) { ...}
}
```

### Поддержка HTTP-статусов

Spring позволяет легко управлять статусами через ResponseEntity

```java

@PostMapping
public ResponseEntity<User> createUser(@RequestBody User user) {
    User saved = userService.save(user);
    URI location = ServletUriComponentsBuilder
            .fromCurrentRequest()          // 1. Берем URL текущего запроса (например, /api/users)
            .path("/{id}")                 // 2. Добавляем к нему путь "/" и placeholder для ID
            .buildAndExpand(saved.getId()) // 3. Подставляем реальный ID (напр., 123) вместо {id}
            .toUri();                      // 4. Собираем все в итоговый URI
    return ResponseEntity.created(location).body(saved); // Создает объект ResponseEntity со статусом кодом 201 Created и устанавливает заголовок Location: http://ваш-сервер/api/users/123
}
```

Или через исключения и @ControllerAdvice:

```java
// Аннотация Spring, которая "ловит" указанное исключение
// в рамках текущего контроллера (или глобально, если в @ControllerAdvice)
@ExceptionHandler(UserNotFoundException.class)
// Метод возвращает полный HTTP-ответ с кастомной структурой ошибки
public ResponseEntity<ErrorResponse> handleNotFound() {
    // Строим ответ:
    return ResponseEntity.status(HttpStatus.NOT_FOUND)  // 1. Устанавливаем статус 404
            .body(new ErrorResponse("User not found")); // 2. Создаем тело ответа
}

// Пример класса для тела ошибки
public class ErrorResponse {
    private String message;
    private LocalDateTime timestamp;

    public ErrorResponse(String message) {
        this.message = message;
        this.timestamp = LocalDateTime.now();
    }
}
```

Пример ответа (body):

```json
{
  "message": "User not found",
  "timestamp": "2025-10-05T14:30:00.123Z"
}
```

### Content Negotiation (разные представления)

Достаточно добавить зависимости (jackson-dataformat-xml), и Spring сам выберет сериализатор.

```java

@GetMapping(produces = "application/json")    // по умолчанию
public User getUserJson(...) { ...}

@GetMapping(produces = "application/xml")
public User getUserXml(...) { ...}
```

### HATEOAS (опционально)

Хотя HATEOAS поддерживается, в реальных проектах его часто не используют из-за сложности на фронтенде.

С помощью Spring HATEOAS:

```java

@GetMapping("/{id}")
public EntityModel<User> getUser(@PathVariable Long id) {
    User user = userService.findById(id);
    return EntityModel.of(user,
            linkTo(methodOn(UserController.class).getUser(id)).withSelfRel(),
            linkTo(methodOn(UserController.class).deleteUser(id)).withRel("delete")
    );
}
```

Ответ:

```json
{
  "id": 42,
  "name": "Alex",
  "_links": {
    "self": {
      "href": "/users/42"
    },
    "delete": {
      "href": "/users/42"
    }
  }
}
```

### Stateless и безопасность

Токены (JWT, OAuth2) передаются в заголовке - сервер не хранит сессию.

Spring Security легко интегрируется и поддерживает stateless-аутентификацию:

```java

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
                .csrf().disable()
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .and()
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/users/**").authenticated()
                )
                .httpBasic(); // или .oauth2ResourceServer() для JWT
        return http.build();
    }
}
```

### Валидация и ошибки

При ошибке валидации можно вернуть 400 Bad Request с деталями.

```java

@PostMapping
public User createUser(@Valid @RequestBody User user) { ...}

// В User:
public class User {
    @NotBlank
    private String name;

    @Email
    private String email;
}
```

### Типичные антипаттерны в Java REST API

| Проблема                           | Неправильно                            | Правильно                                                      | Объяснение                                                            |
|:-----------------------------------|:---------------------------------------|:---------------------------------------------------------------|:----------------------------------------------------------------------|
| **Глагольные методы**              | `@PostMapping("/cancelOrder")`         | `POST /cancellations`<br>или<br>`DELETE /orders/{id}`          | Нарушает uniform interface. Моделировать как ресурс.                  |
| **Неправильные статус-коды**       | Всегда `200 OK` с `{"success": false}` | Использовать правильные статусы:<br>`400`, `404`, `409` и т.д. | Игнорирует HTTP-семантику. Клиент не может полагаться на статус-коды. |
| **Нарушение Stateless**            | Хранение сессии в `HttpSession`        | Использовать JWT или токены в заголовке                        | Нарушает принцип stateless. Усложняет масштабирование.                |
| **Отсутствие Location**            | `201 Created` без заголовка `Location` | Всегда возвращать `Location: /users/123`                       | Клиент не знает URI нового ресурса.                                   |
| **Отсутствие Content Negotiation** | Жёсткая привязка к JSON                | Разрешить XML/JSON через `produces`, использовать `Accept`     | Нет гибкости в форматах данных.                                       |
| **Неправильная обработка ошибок**  | `try-catch` в каждом методе            | `@ExceptionHandler` и `@ControllerAdvice`                      | Дублирование кода обработки ошибок.                                   |
| **Отсутствие валидации**           | Проверка данных в контроллере          | `@Valid` и Bean Validation аннотации                           | Ручная валидация в контроллере.                                       |

### Полезные Spring-инструменты для REST

| Инструмент                 | Назначение                                                        | Пример использования                        |
|:---------------------------|:------------------------------------------------------------------|:--------------------------------------------|
| **Spring Data REST**       | Автоматическая генерация HATEOAS-совместимого API из репозиториев | `@RepositoryRestResource(path = "users")`   |
| **OpenAPI (Swagger)**      | Генерация документации API                                        | `springdoc-openapi-starter-webmvc-ui`       |
| **Jackson**                | Сериализация/десериализация JSON                                  | `@JsonView`, `@JsonIgnore`, `@JsonProperty` |
| **WebMvc.fn / WebFlux.fn** | Функциональный стиль определения маршрутов                        | Альтернатива аннотациям `@RequestMapping`   |
| **Spring Boot Actuator**   | Мониторинг и управление приложением                               | `/actuator/health`, `/actuator/metrics`     |
| **Spring HATEOAS**         | Поддержка гипермедиа-ссылок                                       | `EntityModel.of(user).add(linkTo(...))`     |
| **Spring Security**        | Аутентификация и авторизация                                      | JWT, OAuth2, Basic Auth                     |
| **Spring Boot DevTools**   | Автоперезагрузка при разработке                                   | Автоматический restart при изменениях       |
</details>