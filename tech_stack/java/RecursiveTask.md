# RecursiveTask<V>

> `RecursiveTask<V>` — это абстрактный класс из пакета java.util.concurrent, предназначенный для реализации разделяй-и-властвуй (divide-and-conquer) алгоритмов в рамках Fork/Join Framework. 
>
> Он наследуется от `ForkJoinTask<V>` и отличается от RecursiveAction тем, что возвращает результат (`V` — generic-тип результата).

- Предназначен для вычислений, возвращающих значение (в отличие от `RecursiveAction`, который возвращает `void`).
- Работает в связке с `ForkJoinPool`.
- Метод `compute()` должен быть реализован и рекурсивно разбивать задачу на подзадачи, пока не будет достигнут базовый случай (threshold).
- Поддерживает work-stealing — эффективную балансировку нагрузки между потоками.

## Структура и ключевые методы:

```java
public abstract class RecursiveTask<V> extends ForkJoinTask<V> {
    protected abstract V compute();  // основной метод — должен быть переопределён
}
```

- `fork()` — асинхронно запускает задачу (в текущем ForkJoinPool).
- `join()` — блокирующий вызов, возвращает результат выполнения задачи (аналог `get()`, но без `InterruptedException` / `ExecutionException`).
- `invoke()` — синхронный запуск и ожидание результата (обычно вызывается у корневой задачи).

### Пример: сумма элементов массива

```java
/**
 * Рекурсивная задача для вычисления суммы long[] с использованием Fork/Join Framework.
 *
 * <p>Важно: этот класс НЕ потокобезопасен для повторного использования — каждый экземпляр
 * должен обрабатывать свой уникальный диапазон [lo, hi) массива. Это не нарушает FJ-контракт,
 * потому что каждый экземпляр task создаётся и используется ровно одним потоком до вызова fork().
 * После fork() объект становится "активной задачей" и больше не модифицируется (immutability by convention).
 */
class SumTask extends RecursiveTask<Long> {

    /**
     * Порог, при котором перестаём делить задачу и переходим к последовательной обработке.
     *
     * <p>Значение подобрано эвристически:
     * — Слишком малое → высокие накладные расходы на создание/планирование задач (task overhead).
     * — Слишком большое → недостаточное распараллеливание.
     *
     * <p>В реальности оптимальный порог зависит от:
     * — стоимости операции (здесь: сложение long — ~1 такт),
     * — размера кэш-линии (64 байта = 8 long'ов), т.е. 10_000 long = 80 КБ → вероятно, не помещается в L2/L3,
     * — количества ядер (для 8 ядер: задач не должно быть << 8, но и не >> 1000).
     *
     * <p>Рекомендация от Doug Lea: чтобы время выполнения листовой задачи было ~1–10 мкс.
     * При ~3 ГГц и 1 такте на +: 1 мкс = ~3000 операций → ~3000 элементов. Но из-за prefetching и OoO,
     * в практике часто берут 1K–100K.
     */
    private static final int THRESHOLD = 10_000;

    /**
     * Исходный массив данных. Он final и неизменяемый.
     * Это критично для потокобезопасности: задачи только читают данные, не модифицируют.
     *
     * <p>Если бы массив был изменяемым — возможна data race при параллельных чтениях
     * (если кто-то вне FJ-пула пишет в него). В данном случае safe-by-construction.
     */
    private final long[] array;

    /**
     * Нижняя граница полуоткрытого диапазона [lo, hi).
     * Inclusive (включительно): элемент array[lo] участвует в вычислении.
     *
     * <p>lo не валидируется при создании — это сделано намеренно:
     * — Fork/Join задачи предполагают корректное использование;
     * — проверки (asserts) можно включить в debug-сборке, но в продакшене они — overhead.
     */
    private final int lo;

    /**
     * Верхняя граница полуоткрытого диапазона [lo, hi).
     * Exclusive (исключительно): элемент array[hi] НЕ участвует.
     *
     * <p>Инвариант (должен выполняться всегда):
     *     0 ≤ lo ≤ hi ≤ array.length
     * Нарушение → ArrayIndexOutOfBoundsException в compute() (и это нормально — fail-fast).
     */
    private final int hi;

    /**
     * Конструктор. Принимает массив и диапазон.
     * <p>
     * — Нет проверок на null/array.length — это сделано для производительности.
     * — В production-коде такие проверки часто выносят в фабричный метод (например, invokeSum(long[])).
     *
     * @param array массив, не null
     * @param lo начало диапазона, 0 ≤ lo ≤ array.length
     * @param hi конец диапазона, lo ≤ hi ≤ array.length
     */
    SumTask(long[] array, int lo, int hi) {
        this.array = array;
        this.lo = lo;
        this.hi = hi;
    }

    /**
     * Главный метод — логика вычисления. Должен быть переопределён.
     * <p>
     * Семантика:
     * — Вызывается ОДИН раз каждым потоком FJ-пула на "активной" задаче.
     * — Поток, вызвавший compute(), "владеет" задачей до завершения compute().
     * — Внутри compute() можно:
     *     → вызывать fork() для дочерних задач,
     *     → вызывать compute() напрямую (для одного потомка — чтобы избежать fork overhead),
     *     → вызывать join() для получения результатов fork’нутых задач.
     *
     * <p>Критически важно:
     * — compute() ДОЛЖЕН быть чистой функцией (side-effect free) относительно внешнего состояния.
     * — Все побочные эффекты допустимы ТОЛЬКО через:
     *     а) возврат результата (V),
     *     б) изменение состояния самой задачи (но только до fork()!),
     *     в) использование потокобезопасных коллекций (ConcurrentHashMap и т.п.).
     *
     * @return сумма элементов array[lo..hi-1]
     */
    @Override
    protected Long compute() {
        // Рассчитываем длину текущего поддиапазона.
        // По инварианту: len >= 0, и если len == 0 — сумма = 0 (нейтральный элемент).
        int len = hi - lo;

        // Базовый случай рекурсии: если размер поддиапазона ≤ порога — обрабатываем последовательно.
        if (len <= THRESHOLD) {
            long sum = 0L;
            // Обычный цикл: компилятор может его векторизовать (например, через AVX2/AVX-512).
            // JIT может применить loop unrolling — особенно если len известен на этапе компиляции (но здесь — нет).
            for (int i = lo; i < hi; i++) {
                sum += array[i];
            }
            return sum; // Возвращаем примитив long, который будет упакован в Long (boxing)
        }

        // Рекурсивный случай: делим задачу пополам.

        // Вычисляем середину без риска integer overflow (lo + (hi - lo) / 2 безопаснее чем (lo + hi) / 2).
        // Почему? При hi ≈ Integer.MAX_VALUE и lo > 0: lo + hi может переполниться → отрицательное mid → AIOOBE.
        int mid = lo + (hi - lo) / 2;

        // Создаём две новые задачи — НО ПОКА НЕ ЗАПУСКАЕМ ИХ.
        // Конструкторы вызываются в текущем потоке — это cheap (обычно allocation в TLAB, без синхронизации).
        SumTask left  = new SumTask(array, lo, mid);    // [lo, mid)
        SumTask right = new SumTask(array, mid, hi);    // [mid, hi)

        // Стратегия выполнения: "одна вилка, одна прямая обработка" (dual submission).
        // — left.fork(): помещает задачу в deque текущего потока (work-stealing queue) и возвращает управление.
        //   Это async-операция: управление возвращается сразу, но задача НЕ выполняется немедленно.
        //   ForkJoinPool гарантирует, что задача будет выполнена "как можно скорее" этим или другим потоком.
        left.fork();

        // — right.compute(): текущий поток САМ рекурсивно обрабатывает правую половину.
        //   Это важно: если сделать fork() и для right, то текущий поток простаивал бы в join'ах.
        //   Вместо этого он продолжает работу → повышает utilization.
        Long rightResult = right.compute();     // Мы не вызываем join() на right, потому что right.compute() — это прямой вызов, 
                                                // а не асинхронный запуск. 
                                                // Текущий поток сам выполняет правую подзадачу, 
                                                // и результат получается напрямую — без посредников, без ожидания, без overhead’а синхронизации.

        // — left.join(): БЛОКИРУЮЩИЙ вызов, возвращает результат left.compute().
        //   НО: join() в FJ — это НЕ обычный wait(). Реализация использует work-stealing:
        //       — если left уже завершена — сразу возвращает результат;
        //       — если нет — поток "крадёт" задачи из других deques и выполняет их,
        //         пока left не завершится. Это предотвращает idle и deadlock.
        //
        //   join() НЕ кидает InterruptedException — ForkJoinTask специально спроектирован так,
        //   чтобы избежать checked exceptions в compute().
        Long leftResult = left.join();

        // Складываем результаты. Если overflow — будет wrap-around (long overflow — defined behavior в Java).
        return leftResult + rightResult;
    }
}

// ========= Использование =========

public class SumExample {
    public static void main(String[] args) {
        // Создаём массив. Размер выбран > THRESHOLD, чтобы задействовать параллелизм.
        long[] data = new long[1_000_000];
        for (int i = 0; i < data.length; i++) {
            data[i] = i + 1; // 1, 2, 3, ..., 1_000_000
        }

        // Получаем общий пул (common pool).
        // — Это singleton, инициализируется при первом обращении.
        // — Размер пула = max(1, Runtime.getRuntime().availableProcessors() - 1) по умолчанию,
        //   но может варьироваться в зависимости от JVM (например, если async-mode включен).
        ForkJoinPool pool = ForkJoinPool.commonPool();

        // Создаём корневую задачу: обработка всего массива [0, data.length).
        SumTask root = new SumTask(data, 0, data.length);

        // Запускаем и ждём результата.
        // — invoke() = fork() + join(), но для корневой задачи оптимизировано:
        //   текущий поток вызывает compute() напрямую (без fork), т.е. работает как worker.
        //   Это экономит один уровень fork/join overhead.
        long result = pool.invoke(root);

        // Проверка: сумма 1..n = n*(n+1)/2
        long expected = (long) data.length * (data.length + 1) / 2;
        System.out.println("Result: " + result + ", Expected: " + expected + ", Match: " + (result == expected));
    }
}
```

### Важные замечания:

- Не следует вызывать `fork()` на всех подзадачах подряд, иначе может возникнуть "взрыв задач" (excessive task creation). 
Рекомендуется одну из подзадач обрабатывать напрямую через `compute()`, а остальные — через `fork()` + `join()` (см. dual submission подход).
- `join()` блокирует, но не приводит к `deadlock`, так как `ForkJoinPool` реализует work-stealing: поток, вызвавший `join()`, переключается на выполнение другой задачи из пула.
- Нельзя использовать `RecursiveTask` вне `ForkJoinPool`, иначе `fork()` / `join()` не будут работать корректно.