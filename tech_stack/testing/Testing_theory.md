# Testing Theory

## 7 принципов тестирования

- Exhaustive testing is impossible (Исчерпывающее тестирование невозможно).
<br>Полный перебор всех возможных сценариев невозможен из-за бесконечного числа комбинаций данных и условий.

- Testing shows the presence of defects, not their absence (Тестирование демонстрирует наличие дефектов, а не их отсутствие)
<br>Тестирование может выявить ошибки, но не гарантирует их полного отсутствия в продукте.

- Absence-of-errors fallacy (Заблуждение об отсутствии ошибок)
<br>Даже после исправления многих дефектов нельзя утверждать, что продукт идеален и готов к использованию, так как требования пользователей могут различаться.

- Early testing saves time and money (Раннее тестирование сохраняет время и деньги)
<br>Чем раньше обнаружен дефект, тем дешевле и проще его исправить, предотвращая накопление проблем на поздних этапах.

- Defect clustering (Принцип скопления или кластеризация дефектов)
<br>Большинство дефектов обычно сосредоточено в небольшом количестве модулей, что требует к ним особого внимания при тестировании.

- Testing is context dependent (Тестирование зависит от контекста)
<br>Подход к тестированию зависит от типа продукта, его целей, команды, сроков и доступных инструментов, поэтому стратегия всегда адаптируется.

- Pesticide paradox (Парадокс пестицида)
<br>Повторение одних и тех же тестов со временем становится неэффективным для поиска новых дефектов, поэтому тестовые сценарии необходимо регулярно обновлять.

## ПОДХОДЫ К ТЕСТИРОВАНИЮ (Testing Approaches)

### По уровню доступа к коду/системе

- `Black Box` (Черный ящик): Тестирование без знания внутреннего устройства системы, основанное на требованиях и спецификациях.
- `White Box` (Белый ящик): Тестирование с полным знанием исходного кода (`source code`) и внутренней структуры системы.
- `Grey Box` (Серый ящик): Тестирование с частичным знанием внутреннего устройства, часто на уровне взаимодействия модулей или `API`.

### По исполнению кода

<details>
  <summary>
    <b>Static Testing (Статическое тестирование)</b>
  </summary>

> `Static Testing` (Статическое тестирование) - это анализ артефактов (код, требования, дизайн) без запуска программы.

## Основные понятия

- `Static Testing` (Статическое тестирование) - Тестирование без выполнения кода, направленное на выявление дефектов в программном обеспечении и сопроводительной документации на ранних этапах жизненного цикла.
- `Verification` (Верификация) - Процесс оценки того, соответствует ли продукт установленным требованиям на текущем этапе разработки; статическое тестирование является частью верификации.

## Основные типы

<details>
  <summary>
    <b>Review (Рецензирование)</b>
  </summary>

## Основные понятия

- `Review` (Рецензирование) - Статический метод анализа рабочих продуктов (документов, кода, требований) без их выполнения, направленный на выявление дефектов, улучшение качества и повышение общей осведомленности команды.
- `Static Testing` (Статическое тестирование) - Рецензирование является ключевой частью статического тестирования и проводится до этапа динамического тестирования.

## Цели рецензирования

- Выявление дефектов на ранних этапах жизненного цикла (когда их исправление дешевле).
- Повышение качества и согласованности рабочих продуктов.
- Обмен знаниями и опытом внутри команды.
- Обучение новых участников проекта.
- Улучшение коммуникации между разработчиками, тестировщиками и аналитиками.

## Типы рецензирования

### Неформальное рецензирование (`Informal Review`)
- Отсутствие строгой структуры и документации.
- Примеры: парное чтение кода, быстрая проверка коллегой, обсуждение в чате.
- Подходит для небольших изменений, гибких проектов, быстрой обратной связи.

### Формальное рецензирование (`Formal Review`)
- Строго регламентированный процесс с четкими ролями, этапами и отчетностью.
- **Основные виды**:
  - `Walkthrough` (Сквозной просмотр) - Автор ведет презентацию продукта для аудитории с целью получения отзывов.
  - `Technical Review` (Техническая оценка) - Коллективная экспертиза продукта специалистами для выявления дефектов и несоответствий.
  - `Inspection` (Инспекция) - Наиболее формальный тип, проводимый обученным модератором по заранее определенному чек-листу с фиксацией всех найденных дефектов.

## Процесс формального рецензирования

1. **Планирование** (`Planning`) - Определение целей, участников, критериев входа/выхода.
2. **Инициирование** (`Kick-off`) - Представление продукта, целей и распределение ролей.
3. **Подготовка** (`Individual Preparation`) - Участники самостоятельно изучают материал и фиксируют замечания.
4. **Обсуждение** (`Review Meeting`) - Коллективное обсуждение найденных дефектов (в некоторых форматах, например, в инспекции, может быть пропущено).
5. **Исправление** (`Rework`) - Автор вносит исправления на основе полученной обратной связи.
6. **Подтверждение** (`Follow-up`) - Проверка того, что все замечания были корректно устранены.

## Ключевые роли

- `Author` (Автор) - Создатель рабочего продукта, отвечающий за его исправление.
- `Moderator` / `Review Leader` (Модератор) - Руководит процессом, обеспечивает его соблюдение.
- `Reviewer` (Рецензент) - Участник, который анализирует продукт и находит дефекты.
- `Scribe` / `Recorder` (Секретарь) - Фиксирует все найденные дефекты и решения.

## Что подлежит рецензированию?

- Документация по требованиям (SRS, BRS)
- Дизайн-документы и архитектурные схемы
- Исходный код
- Тестовая документация (тест-кейсы, чек-листы, планы)
- Пользовательская документация (мануалы, справка)

## Преимущества для тестировщика

- Более глубокое понимание требований и бизнес-логики.
- Возможность найти дефекты до начала динамического тестирования.
- Лучшая подготовка к написанию качественных тест-кейсов.
- Укрепление взаимодействия с командой разработки и аналитиками.

## Факторы успеха

- Четко определенные цели рецензирования.
- Подготовленные и мотивированные участники.
- Качественные и доступные материалы для анализа.
- Фокус на продукте, а не на личности автора.
- Использование чек-листов и стандартов.
- Поддержка процесса со стороны менеджмента.

</details>

- `Static Analysis` (Статический анализ) - Анализ исходного кода без его выполнения для обнаружения структурных дефектов и нарушений стандартов.
  - `Data Flow Analysis` (Анализ потока данных) - Проверка корректности использования переменных (инициализация, использование, освобождение) в ходе выполнения программы.
  - `Control Flow Analysis` (Анализ потока управления) - Исследование последовательности выполнения операторов и инструкций для выявления недостижимого кода, бесконечных циклов и других аномалий.
  - `Cyclomatic Complexity` (Цикломатическая сложность) - Метрика, измеряющая количество линейно независимых путей в графе потока управления программы; используется для оценки тестируемости и поддерживаемости кода.

## Объекты статического тестирования

- `Requirements & Design Documents` (Документы требований и проектирования) - Спецификации, архитектурные схемы, модели данных.
- `Test Artifacts` (Тестовые артефакты) - Тест-кейсы, чек-листы, стратегии тестирования.
- `Source Code` (Исходный код) - Проверяется как вручную (code review), так и автоматически (статическими анализаторами).
- `UI Prototypes & Mockups` (Прототипы интерфейсов) - Эскизы и макеты пользовательского интерфейса.
- `Environment Configuration` (Параметры среды) - Настройки окружения, переменные окружения, конфигурационные файлы.
- `Test Data` (Тестовые данные) - Подготовленные наборы данных для проверки корректности их структуры и соответствия требованиям.

## Типичные дефекты, выявляемые статическим анализом

- `Unused Variables` (Неиспользуемые переменные) - Переменные, объявленные, но нигде не используемые.
- `Dead Code` (Мертвый код) - Участки кода, которые никогда не выполняются.
- `Infinite Loops` (Бесконечные циклы) - Циклы без корректного условия завершения.
- `Uninitialized Variables` (Переменные без инициализации) - Использование переменных до присвоения им значения.
- `Resource Leaks` (Утечки ресурсов) - Невысвобождаемые память, файловые дескрипторы, соединения.
- `Buffer Overflows` (Переполнение буфера) - Запись данных за пределы выделенного буфера.
- `Incomplete Error Handling` (Неполная обработка ошибок) - Отсутствие обработки возможных исключений или кодов ошибок.

## Преимущества статического тестирования 

- `Early Defect Detection` (Раннее выявление дефектов) - Обнаружение ошибок до запуска системы, что значительно снижает стоимость их исправления.
- `Process Improvement Feedback` (Обратная связь для улучшения процессов) - Выявленные дефекты помогают команде совершенствовать практики разработки и тестирования.
- `Enhanced Team Awareness` (Повышение осведомленности команды) - Участники лучше понимают качество продукта и потенциальные риски.
- `Knowledge Sharing` (Обмен знаниями) - Способствует передаче опыта и критической информации между членами команды.
- `Reduced Rework Effort` (Снижение объема переделок) - Минимизация затрат на исправление ошибок на поздних этапах разработки.

## Недостатки статического тестирования

- Процесс статического тестирования может занимать много времени, так как в основном он выполняется вручную.
- Препятствует обнаружению уязвимостей, представленных в среде выполнения.

</details>

<details>
  <summary>
    <b>Dynamic Testing (Динамическое тестирование)</b>
  </summary>

> `Dynamic Testing` (Динамическое тестирование) - Тестирование, при котором программный код исполняется для проверки его реального поведения при заданных входных данных.
> 
> `Validation` (Валидация) - Процесс подтверждения того, что продукт удовлетворяет заявленным требованиям и ожиданиям пользователей; динамическое тестирование является частью валидации.

## Методология динамического тестирования

- `Input Execution and Output Analysis` (Выполнение с входными данными и анализ выхода) - Подача заранее определённых входных данных и сравнение фактического результата с ожидаемым.
- `Real-Time Behavior Verification` (Проверка поведения в реальном времени) - Наблюдение за реакцией системы на действия пользователя или внешние события.
- `Test Execution Modes` (Режимы выполнения тестов) - Может выполняться вручную или с использованием автоматизированных средств.

## Цели и задачи динамического тестирования

- `Functional Correctness` (Функциональная корректность) - Подтверждение, что система выполняет заявленные функции правильно.
- `Non-Functional Validation` (Валидация нефункциональных характеристик) - Проверка производительности, надёжности, масштабируемости, безопасности и других качественных атрибутов.
- `Complex Defect Detection` (Обнаружение сложных дефектов) - Выявление ошибок, которые невозможно обнаружить без выполнения кода (например, гонки условий, ошибки синхронизации, проблемы с состоянием).

## Преимущества динамического тестирования

- `Comprehensive Functionality Coverage` (Полное покрытие функциональности) - Позволяет оценить систему в целом, как её воспринимает пользователь.
- `User-Centric Perspective` (Ориентация на пользователя) - Тестирование отражает реальный опыт взаимодействия с продуктом.
- `Detection of Runtime Defects` (Обнаружение ошибок времени выполнения) - Выявляет дефекты, проявляющиеся только при исполнении (например, утечки памяти, исключения).
- `Automation Support` (Поддержка автоматизации) - Широко поддаётся автоматизации с использованием специализированных фреймворков и инструментов.

## Недостатки динамического тестирования

- `High Time Consumption` (Высокая трудоёмкость) - Требует значительных временных затрат на подготовку, выполнение и анализ результатов.
- `High Cost` (Высокая стоимость) - Связано с необходимостью поддержки тестовой инфраструктуры, данных и окружений.
- `Late Defect Discovery` (Позднее обнаружение дефектов) - Обычно проводится после завершения разработки, что увеличивает стоимость исправления найденных ошибок.

</details>

## УРОВНИ ТЕСТИРОВАНИЯ (Testing Levels)

- `Unit Testing` (Модульное / Компонентное тестирование): Тестирование отдельных изолированных модулей или компонентов (обычно методов или классов) программы.
- `Integration Testing` (Интеграционное тестирование): Тестирование взаимодействия между несколькими модулями, компонентами или системами.
- `System Testing` (Системное тестирование): Тестирование полностью интегрированной системы на соответствие всем требованиям.
- `Acceptance Testing` (Приемочное тестирование): Финальное тестирование, проводимое с целью принятия решения о готовности системы к выпуску.

## ТИПЫ ТЕСТИРОВАНИЯ (Testing Types)

### По функциональности

- `Functional Testing` (Функциональное тестирование): Проверка соответствия функциональности системы заявленным требованиям.
- `Non-Functional Testing` (Нефункциональное тестирование): Проверка качественных характеристик системы (производительность, безопасность, удобство использования и т.д.).

### По степени автоматизации

- `Manual Testing` (Ручное тестирование): Выполнение тестовых сценариев (`test scenarios`) человеком без использования скриптов.
- `Automated Testing` (Автоматизированное тестирование): Выполнение тестов с помощью специальных программ и скриптов.

## ТИПЫ ТЕСТИРОВАНИЯ (Testing Types)

- `Functional Testing` (Функциональное тестирование): Проверка соответствия функциональности системы заявленным требованиям.

### Нефункциональные виды

<details>
  <summary>
    <b>Performance Testing (Тестирование производительности)</b>
  </summary>

> Performance Testing (Тестирование производительности) - Нефункциональный вид тестирования, оценивающий скорость, время отклика, стабильность, масштабируемость и использование ресурсов системы под определённой нагрузкой.
>
> Performance Engineering (Инжиниринг производительности) - Более широкая дисциплина, включающая тестирование, но сфокусированная на проактивном проектировании, архитектуре и постоянном улучшении производительности системы.

## Key Goals & Problems

- `Bottleneck` (Узкое место / "Бутылочное горлышко") - Единая точка в системе, ограничивающая общую производительность, часто связанная с ЦП, памятью, дисковым вводом/выводом или сетью.
- `Scalability` (Масштабируемость) - Способность системы выдерживать увеличение нагрузки путём добавления ресурсов (например, серверов) без ухудшения производительности.

## Core Performance Metrics

- `Response Time` / `Latency` (Время отклика / Задержка) - Временной интервал между запросом пользователя и получением первого символа ответа от системы.
- `Throughput` (Пропускная способность) - Количество транзакций или запросов, которые система может обработать за единицу времени (например, запросов в секунду `RPS`).
- `Bandwidth` (Пропускная способность сети / Ширина канала) - Максимальная скорость передачи данных по сети или каналу связи.
- `CPU Usage` (Использование ЦП) - Процент времени, которое процессор тратит на выполнение полезных (не простаивающих) потоков.
- `Memory Usage` (Использование памяти) Объем физической памяти (`RAM` (`ОЗУ`)), активно используемой приложением или системой.

## Types of Performance Testing

<details>
  <summary>
    <b>Load Testing (Нагрузочное тестирование)</b>
  </summary>

> `Load Testing` (Нагрузочное тестирование) - Тестирование поведения приложения под ожидаемой нормальной и пиковой пользовательской нагрузкой.

## Основные понятия

- `Load Testing` (Нагрузочное тестирование) - Вид тестирования производительности, направленный на оценку поведения системы под ожидаемой и увеличивающейся нагрузкой (число пользователей, транзакций) для определения её способности удовлетворять заданным критериям производительности.
- `Performance Efficiency` (Эффективность производительности) - Способность программного обеспечения обеспечивать адекватную производительность при заданной нагрузке и доступных ресурсах (в соответствии со стандартом ISO/IEC 25010).

## Цели и задачи

- `Baseline Performance Measurement` (Измерение базовой производительности) - Установление эталонных показателей (время отклика, пропускная способность) в нормальных условиях.
- `Capacity Planning` (Планирование мощностей) - Определение максимально допустимой нагрузки, которую система может обрабатывать без нарушения SLA.
- `Bottleneck Identification` (Выявление узких мест) - Обнаружение компонентов системы (БД, сеть, CPU), ограничивающих общую производительность.
- `Resource Utilization Monitoring` (Мониторинг использования ресурсов) - Анализ потребления процессорного времени, памяти, дискового I/O и сетевой пропускной способности под нагрузкой.

## Ключевые метрики

- `Response Time` (Время отклика) - Интервал между отправкой запроса и получением полного ответа.
- `Throughput` (Пропускная способность) - Количество обработанных транзакций или запросов в единицу времени (например, транзакций в секунду).
- `Error Rate` (Частота ошибок) - Процент неудачных транзакций относительно общего числа попыток.
- `Concurrent Users` (Количество одновременных пользователей) - Число виртуальных пользователей, активно взаимодействующих с системой в один момент времени.
- `CPU / Memory / Network Utilization` (Использование ресурсов) - Процент загрузки ключевых системных ресурсов.

## Подход к проведению

- `Acceptance Criteria Definition` (Определение критериев приемки) - Формулировка целевых значений для метрик (например, «время отклика ≤ 5 сек при 5000 пользователей»).
- `Business Flow Identification` (Идентификация бизнес-потоков) - Выбор ключевых сценариев использования, основанных на реальных данных или бизнес-требованиях.
- `Workload Modeling` (Моделирование рабочей нагрузки) - Создание профиля нагрузки, имитирующего реальное поведение пользователей, включая:
  - `Ramp-up` (Нарастание нагрузки)
  - `Steady State` (Устойчивое состояние)
  - `Ramp-down` (Снижение нагрузки)
  - `Think Time` (Время «размышлений» между действиями пользователя)
- `Test Environment Setup` (Настройка тестовой среды) - Обеспечение максимального соответствия production-окружению.
- `Result Analysis & Reporting` (Анализ результатов и отчетность) - Сравнение с baseline, выявление корневых причин проблем и формулирование рекомендаций.

## Виды нагрузочного тестирования

- `Standard Load Testing` (Стандартное нагрузочное тестирование) - Проверка системы под ожидаемой пиковой нагрузкой.
- `Stress Testing` (Стресс-тестирование) - Тестирование за пределами нормальной рабочей нагрузки для оценки поведения системы в экстремальных условиях и выявления точки отказа.
- `Soak Testing` / `Endurance Testing` (Тестирование стабильности / Выдержки) - Длительное тестирование под высокой нагрузкой для выявления проблем, проявляющихся со временем (например, утечки памяти).
- `Spike Testing` (Тестирование на всплески нагрузки) - Моделирование резких скачков нагрузки для проверки устойчивости и скорости восстановления системы.
- `Scalability Testing` (Тестирование масштабируемости) - Оценка способности системы сохранять или улучшать производительность при добавлении ресурсов (CPU, RAM, узлов).
- `Resource Utilization Testing` (Тестирование использования ресурсов) - Измерение и анализ потребления системных ресурсов под нагрузкой.
- `Reliability Testing` (Тестирование надёжности) - Проверка способности системы непрерывно выполнять функции в течение заданного периода под нагрузкой.
- `Background Testing` (Фоновое тестирование) - Проверка влияния фоновой нагрузки на пользовательский опыт в обычных сценариях.
- `Tip-over Testing` (Опрокидывающее тестирование) - Целенаправленное насыщение системы нагрузкой до полного отказа для выявления самого слабого звена.

</details>

- `Stress Testing` (Стресс-тестирование) - Тестирование приложения за пределами ожидаемой максимальной нагрузки для поиска точки сбоя и наблюдения за поведением восстановления.
- `Endurance` / `Soak Testing` (Тестирование на выносливость) - Тестирование приложения под значительной нагрузкой в течение длительного периода для обнаружения утечек памяти или снижения производительности со временем).
- `Spike Testing` (Тестирование на скачкообразную нагрузку) - Тестирование приложения при внезапном, резком увеличении пользовательской нагрузки, чтобы увидеть, как оно справляется с резкими скачками трафика.
- `Capacity Testing` (Тестирование ёмкости) - Определение максимального количества пользователей или транзакций, которое система может поддерживать при выполнении целевых показателей производительности.

##  Testing Process & Environment

- `Test Environment` (Тестовая среда) - Отдельное окружение, имитирующее производственную среду по аппаратному, программному обеспечению и конфигурации сети для выполнения нагрузочных тестов.
- `Test Scenario` / `Workload Model` (Тестовый сценарий / Модель нагрузки) - Определённый набор пользовательских действий (транзакций) и их соотношение, которые будут выполнять виртуальные пользователи во время теста.
- `Virtual User` / `(VU)` (Виртуальный пользователь) - Программно симулированный пользователь, имитирующий поведение реального человека при взаимодействии с приложением.
- `Ramp-Up` (Наращивание нагрузки) - Период во время теста, когда количество активных виртуальных пользователей постепенно увеличивается до целевой нагрузки.
- `Steady State` (Установившееся состояние) - Основная фаза нагрузочного теста, в которой нагрузка поддерживается постоянной в течение длительного периода для сбора стабильных метрик.

</details>

- `Volume Testing` (Объемное тестирование): Проверка работы системы с большими объемами данных (`data volumes`).
- `Usability Testing` (Тестирование удобства использования): Оценка того, насколько продукт понятен, удобен и привлекателен для пользователя.

<details>
  <summary>
    <b>A/B Testing (A/B-тестирование)</b>
  </summary>

## Основные понятия

- `A/B Testing` (A/B-тестирование) - Метод сравнительного исследования, при котором пользователям случайным образом показываются две (или более) версии одного и того же элемента (веб-страницы, экрана приложения, CTA-кнопки и т.д.) для определения, какая из них лучше достигает заданной цели.
- `Split Testing` / `Bucket Testing` (Сплит-тестирование / Групповое тестирование) - Синонимы A/B-тестирования, подчеркивающие разделение аудитории на группы.
- `Control Group` (Контрольная группа) - Группа пользователей, которой показывается текущая, эталонная версия (вариант A).
- `Experimental Group` (Экспериментальная группа) - Группа пользователей, которой показывается новая, тестируемая версия (вариант B).

## Цели и задачи

- `Conversion Rate Optimization` (`CRO`) (Оптимизация коэффициента конверсии) - Повышение процента пользователей, совершающих целевое действие (покупка, регистрация, подписка).
- `Data-Driven Decision Making` (Принятие решений на основе данных) - Замена догадок и субъективных мнений объективными статистическими данными.
- `Risk Mitigation` (Снижение рисков) - Проверка гипотез на ограниченной аудитории перед полномасштабным внедрением изменений.

## Объекты тестирования

- `Landing Pages` (Лендинги) - Страницы, на которые пользователь попадает после клика по рекламе или ссылке.
- `Headlines & Copy` (Заголовки и текст) - Текстовый контент, влияющий на первое впечатление и вовлеченность.
- `Call to Action` (`CTA`) (Призыв к действию) - Кнопки и ссылки, побуждающие пользователя к целевому действию.
- `Page Layout & Design` (Макет и дизайн страницы) - Визуальная организация контента и элементов интерфейса.
- `Navigation` (Навигация) - Структура и простота перемещения по сайту или приложению.
- `Forms` (Формы) - Элементы сбора информации от пользователя (регистрация, заказ, обратная связь).
- `Media Content` (Медиаконтент) - Изображения, видео, аудио, используемые для привлечения внимания и передачи информации.
- `User Flows & Funnels` (Пользовательские потоки и воронки) - Последовательности действий, ведущих пользователя к цели.

## Этапы проведения A/B-теста

- `Hypothesis Formulation` (Формулирование гипотезы) - Создание предположения о том, как конкретное изменение повлияет на целевую метрику (например, «Изменение цвета CTA-кнопки с синего на красный увеличит конверсию на 5%»).
- `Metric Definition` (Определение метрик) - Выбор количественных показателей для оценки успеха (CTR, конверсия, LTV, средний чек, отказы).
- `Sample Size Calculation` (Расчет размера выборки) - Определение необходимого количества пользователей для получения статистически значимых результатов.
- `Test Implementation` (Реализация теста) - Настройка эксперимента с помощью специализированных платформ (Optimizely, Google Optimize), фреймворков или собственной разработки.
- `Result Analysis` (Анализ результатов) - Применение статистических методов для определения, есть ли достоверная разница между вариантами, и какой из них является победителем.

## Ключевые принципы

- `One Variable at a Time` (Один изменяемый параметр) - Для точного определения причины эффекта рекомендуется изменять только один элемент за раз (например, только текст кнопки, но не ее цвет и размер одновременно).
- `Statistical Significance` (Статистическая значимость) - Результат считается достоверным, если вероятность его случайного возникновения (p-value) ниже заданного порога (обычно 5%).
- `Practical Significance` (Практическая значимость) - Даже статистически значимый результат должен быть экономически оправдан (выгода от изменения должна превышать затраты на его внедрение).

## Преимущества

- `Objective Insights` (Объективные инсайты) - Позволяет понять реальное поведение пользователей, а не их заявленные предпочтения.
- `Continuous Improvement` (Непрерывное улучшение) - Создает культуру экспериментов и постоянной оптимизации продукта.
- `Resource Efficiency` (Эффективность ресурсов) - Помогает сосредоточить усилия на изменениях, которые действительно работают.

## Ограничения и трудности

- `Novelty Effect` (Эффект новизны) - Пользователи могут временно реагировать на любое изменение, даже негативное, просто из-за его новизны.
- `Change Aversion` (Отторжение изменений) - Постоянные пользователи могут негативно воспринимать даже улучшения, если они привыкли к старому интерфейсу.
- `Traffic Requirements` (Требования к трафику) - Для получения быстрых и надежных результатов требуется достаточный объем пользователей.
- `Time Sensitivity` (Временная зависимость) - Результаты могут искажаться сезонностью, днями недели или временем суток, поэтому тест должен длиться достаточно долго.
- `Multiple Testing Problem` (Проблема множественных сравнений) - При одновременном запуске многих тестов возрастает вероятность ложноположительных результатов.

</details>

- `Compatibility Testing` (Тестирование совместимости): Проверка работы системы на различном окружении (ОС, браузеры, устройства и т.д.).
- `Cross-Browser` / `Cross-Platform Testing` (Кросс-браузерное / Кроссплатформенное тестирование): Частный случай конфигурационного тестирования для веб и мобильных приложений.
- `Installation`/`Deployment Testing` (Тестирование установки/развертывания): Проверка корректности процессов установки, настройки, обновления и удаления ПО.
- `Failover and Recovery Testing` (Тестирование на отказ и восстановление): Проверка способности системы восстанавливаться после аппаратных или программных сбоев.
- `Containerization Testing` (e.g., `Docker`) (Тестирование в контейнерах): Проверка работы приложения в изолированных контейнерных средах.

### Связанные с изменениями (Change-Related)

<details>
  <summary>
    <b>Smoke Testing (Дымовое тестирование)</b>
  </summary>

## Основные понятия

- `Smoke Testing` — начальный уровень функционального тестирования, направленный на быструю проверку жизнеспособности сборки (build) или новой версии приложения. 
<br>Не предназначено для глубокой проверки функциональности, а служит «воротами» для дальнейшего тестирования.

## Цели и задачи

- Подтвердить, что критически важные функции работают корректно.
- Убедиться, что приложение стабильно запускается и не содержит блокирующих дефектов.
- Предотвратить трату ресурсов на полноценное тестирование нерабочей сборки.
- Обеспечить быструю обратную связь разработчикам.

## Область применения

- После каждой новой сборки (в том числе в CI/CD pipeline).
- Перед передачей сборки QA-команде.
- В начале регрессионного или системного тестирования.

## Основной фокус

- Ключевые пользовательские сценарии (например: вход в систему, открытие основной страницы, выполнение базовой операции).
- Компоненты, без которых дальнейшее тестирование невозможно.
- Отсутствие критических сбоев (падения, зависания, ошибки 5xx и т.п.).

## Скорость выполнения

- Должно занимать минимальное время (обычно от нескольких минут до получаса в зависимости от сложности системы).
- Часто полностью автоматизируется для интеграции в пайплайн сборки.

## Реакция на ошибки

- При обнаружении любого блокирующего дефекта тестирование прекращается.
- Сборка считается «непроходной» (failed build) и не передаётся на дальнейшее тестирование.
- Разработчики получают уведомление и исправляют проблему до повторной сборки.

## Лучшие практики

- Автоматизировать набор smoke-тестов и запускать их на каждом коммите или nightly-сборке.
- Поддерживать минимальный, но достаточный набор сценариев — только самые критичные пути.
- Чётко определять критерии прохождения/провала.
- Избегать дублирования с sanity- или регрессионным тестированием — smoke-тесты должны быть максимально поверхностными, но значимыми.
- Использовать как часть «качественного шлюза» (quality gate) в DevOps-процессах.
- 
</details>

<details>
  <summary>
    <b>Regression Testing (Регрессионное тестирование)</b>
  </summary>

## Основные понятия

- `Regression Testing` (Регрессионное тестирование) - Тип функционального тестирования, направленный на подтверждение того, что недавно внесённые изменения в код (исправления, новые функции, оптимизация) не вызвали непреднамеренных побочных эффектов и не нарушили существующую функциональность.

## Цели и задачи

- `Side Effect Detection` (Обнаружение побочных эффектов) - Выявление дефектов, которые появились в ранее работающем коде из-за изменений в другом месте системы.
- `Stability Assurance` (Гарантия стабильности) - Обеспечение того, что основной функционал системы остаётся работоспособным после каждого изменения.
- `Confidence in Releases` (Уверенность в релизах) - Предоставление команде разработки и заинтересованным сторонам уверенности в том, что новый выпуск не сломает существующие возможности продукта.

## Триггеры для проведения

- Исправление дефектов (bug fixes).
- Добавление новой функциональности.
- Изменение требований к существующей функции.
- Рефакторинг или оптимизация исходного кода.
- Применение патчей и обновлений зависимостей.
- Изменения в конфигурации системы или окружения.

## Стратегии отбора тестов

- `Full Regression` (Полный регресс) - Запуск всего набора тестов. Используется при крупных изменениях или перед важными релизами.
- `Partial / Selective Regression` (Частичный / Избирательный регресс) - Запуск только тех тестов, которые связаны с изменёнными модулями и их зависимостями.
- `Prioritized Regression` (Приоритезированный регресс) - Запуск тестов в порядке их важности (например, сначала критические и высоко приоритетные).

## Подходы к организации

- `Test Suite Maintenance` (Поддержка тестового набора) - Регулярное обновление и актуализация тест-кейсов в соответствии с изменениями в требованиях и функционале.
- `Impact Analysis` (Анализ влияния) - Определение областей системы, которые могут быть затронуты внесёнными изменениями, для фокусировки тестирования.
- `Smoke & Sanity Testing` (Дымовое и sanity-тестирование) - Быстрая проверка основных функций перед запуском полного регрессионного цикла.

## Преимущества автоматизации

- `Speed` (Скорость) - Автоматизированные тесты выполняются значительно быстрее ручных.
- `Repeatability` (Повторяемость) - Гарантирует одинаковые условия выполнения при каждом запуске.
- `Cost Efficiency` (Экономическая эффективность) - Снижает долгосрочные затраты на повторяющиеся проверки, особенно в проектах с частыми релизами.
- `CI/CD Integration` (Интеграция с CI/CD) - Позволяет запускать регрессионные тесты автоматически при каждом коммите или сборке, обеспечивая быструю обратную связь.

## Лучшие практики

- `Automate Repetitive Tests` (Автоматизируйте повторяющиеся тесты) - Все тесты, которые нужно запускать часто, должны быть автоматизированы.
- `Maintain a Living Test Repository` (Поддерживайте актуальный репозиторий тестов) - Удаляйте устаревшие тесты и добавляйте новые по мере развития продукта.
- `Combine Manual and Automated` (Комбинируйте ручное и автоматизированное тестирование) - Используйте ручное тестирование для исследовательских и UX-аспектов, а автоматизацию — для проверки стабильности.
- `Run Tests Early and Often` (Запускайте тесты как можно раньше и чаще) - Интегрируйте регрессионное тестирование в ежедневный процесс разработки.

</details>

<details>
  <summary>
    <b>Sanity Testing (Санитарное тестирование)</b>
  </summary>

## Основные понятия

- `Sanity Testing` — узконаправленное функциональное тестирование, выполняемое для проверки корректности реализации конкретных изменений (новых функций, исправлений или улучшений) после их интеграции в основную кодовую базу.
<br>Не охватывает всю систему, а фокусируется только на затронутых участках.

## Цели и задачи

- Убедиться, что новые или изменённые функции работают в соответствии с требованиями.
- Подтвердить, что изменения не содержат явных логических или функциональных ошибок.
- Принять решение: достаточно ли стабильно поведение новой функциональности для перехода к более глубокому тестированию (например, регрессии).

## Область применения

- После слияния feature-ветки в основную ветку разработки.
- Перед запуском полного цикла регрессионного тестирования.
- В условиях ограниченного времени, когда нужно быстро оценить качество изменений.

## Основной фокус

- Поведение новых или модифицированных компонентов.
- Корректность логики, обработки данных и взаимодействия с зависимыми модулями.
- Отсутствие критических дефектов в зоне изменений.

## Скорость выполнения

- Быстрее регрессионного тестирования, но может быть медленнее smoke-тестирования из-за более детальной проверки.
- Часто выполняется вручную, хотя ключевые сценарии могут быть автоматизированы.

## Реакция на ошибки

- При выявлении критической или блокирующей ошибки в зоне изменений тестирование приостанавливается.
- Сборка может быть отклонена для повторной доработки без запуска дальнейших тестов.

## Лучшие практики

- Выполнять только после успешного прохождения smoke-тестирования.
- Тестировать не только «счастливый путь», но и основные граничные и негативные сценарии в рамках изменённой логики.
- Не стремиться к полному покрытию — цель не в исчерпывающей проверке, а в подтверждении разумности поведения.
- Чётко отделять от регрессионного тестирования: sanity не проверяет влияние изменений на старую функциональность.
- Документировать результаты, особенно если тестирование выполняется вручную.

</details>

- `Build Verification Test` / `BVT` (Тестирование сборки): Аналог дымового тестирования для принятия решения о приемке новой версии в работу.

## ПРОЦЕССЫ И ЖИЗНЕННЫЕ ЦИКЛЫ

<details>
  <summary>
    <b>Software Testing Lifecycle (STLC) (Жизненный цикл тестирования ПО)</b>
  </summary>

## Основные понятия

- `Software Testing Lifecycle` (`STLC`) (Жизненный цикл тестирования ПО) - Структурированный процесс, состоящий из последовательных фаз, каждая из которых имеет четкие цели, входные и выходные критерии для обеспечения систематического и эффективного достижения целей качества.
- `Entry Criteria` (Критерии входа) - Набор условий, которые должны быть выполнены перед началом фазы, чтобы гарантировать ее результативность и избежать потери ресурсов.
- `Exit Criteria` (Критерии выхода) - Набор условий, которые должны быть выполнены для официального завершения фазы и перехода к следующей.

## Фазы STLC

### 1. Анализ требований (`Requirement Analysis`)
- **Цель**: Понимание, интерпретация и верификация требований с точки зрения тестируемости и качества.
- **Входные критерии**:
  - Документация по требованиям (BRS, SRS)
  - Описание архитектуры приложения
  - Критерии приемки
- **Выходные артефакты**:
  - `RTM` (`Requirements Traceability Matrix`) (Матрица трассируемости требований)
  - Отчет о тестируемости требований
  - Технико-экономическое обоснование автоматизации

<details>
<summary>
  <b>Requirements Traceability Matrix (RTM) (Матрица трассируемости требований)</b>
</summary>

## Основные понятия

- `Traceability` (Трассируемость) - Способность идентифицировать и отслеживать взаимосвязи между связанными артефактами на всех этапах жизненного цикла ПО.
- `Requirements Traceability Matrix` (`RTM`) (Матрица трассируемости требований) - Двумерная таблица, устанавливающая связи между требованиями и другими артефактами проекта (дизайном, кодом, тестами).

## Цели и преимущества RTM

- **Обеспечение полного покрытия** - Гарантирует, что каждое требование покрыто соответствующими тестами.
- **Управление изменениями** - Позволяет быстро оценить влияние изменений в требованиях на другие компоненты системы.
- **Предотвращение "золотого покрытия"** - Выявляет функциональность, которая не была запрошена заказчиком.
- **Поддержка регуляторных требований** - Обеспечивает доказательства соответствия стандартам (ISO, CMMI, FDA).
- **Упрощение сопровождения** - Ускоряет диагностику и исправление дефектов за счет быстрой навигации по связям.

## Виды трассируемости

- `Vertical Traceability` (Вертикальная трассируемость) - Отслеживание требования через уровни разработки: от бизнес-требования к пользовательскому, системному, дизайну, коду и тестам.
- `Horizontal Traceability` (Горизонтальная трассируемость) - Связь между артефактами одного уровня, например, между требованиями и тестовой документацией.
- `Forward Traceability` (Прямая трассируемость) - Отслеживание от требований к реализации и тестам ("куда ведет это требование?").
- `Backward Traceability` (Обратная трассируемость) - Отслеживание от реализации или тестов к исходным требованиям ("откуда взялся этот код/тест?").
- `Bi-Directional Traceability` (Двунаправленная трассируемость) - Комбинация прямой и обратной трассируемости для полного контроля.

## Структура RTM

Типичная матрица включает следующие столбцы:
- Идентификатор требования
- Описание требования
- Источник требования
- Приоритет / Критичность
- Ссылка на дизайн / архитектуру
- Ссылка на модуль кода / репозиторий
- Идентификаторы связанных тест-кейсов
- Статус покрытия (Полное / Частичное / Отсутствует)
- Статус реализации

## Применение на этапах SDLC

- **Сбор требований** - Создание первоначальной структуры матрицы.
- **Проектирование** - Связывание требований с архитектурными решениями.
- **Разработка** - Привязка требований к конкретным модулям и единицам кода.
- **Тестирование** - Обеспечение покрытия каждого требования тестами и отслеживание результатов.
- **Внедрение и поддержка** - Использование матрицы для анализа инцидентов и планирования улучшений.

## Лучшие практики

- **Раннее создание** - Начинать заполнение RTM сразу после фиксации требований.
- **Живой документ** - Поддерживать матрицу в актуальном состоянии на протяжении всего проекта.
- **Использование инструментов** - Применять специализированные системы управления требованиями (Jira, IBM DOORS, ReqSuite, TestRail).
- **Интеграция с процессами** - Включать обновление RTM в стандартные рабочие процессы команды.
- **Регулярный аудит** - Проводить проверки полноты и корректности связей.

## Владение и ответственность

- **Основной владелец** - Бизнес-аналитик или менеджер продукта.
- **Участники** - Архитекторы, разработчики, тестировщики.
- **Аудиторы** - В организациях с высоким уровнем зрелости (CMMI) — команда TQM или QA.

</details>

### 2. Планирование тестирования (`Test Planning`)
- **Цель**: Определение стратегии, подхода, ресурсов, инструментов и графика для достижения целей тестирования.
- **Входные критерии**:
  - Утвержденные требования
  - Матрица RTM
  - Отчет о возможности автоматизации
- **Выходные артефакты**:
  - `Test Strategy` (Тестовая стратегия)
  - `Test Plan` (План тестирования)
  - Оценка трудозатрат на тестирование

### 3. Разработка тестовой документации (`Test Case Development`)
- **Цель**: Создание детальных инструкций (тест-кейсов и скриптов) для проверки функциональности в соответствии с требованиями.
- **Входные критерии**:
  - Обновленная документация по требованиям
  - План тестирования
  - Матрица RTM
- **Выходные артефакты**:

<details>
  <summary>
    <b>Test Case (Тест-кейс)</b>
  </summary>

## Основные понятия

> `Test Case` — структурированный документ, предназначенный для проверки соответствия функциональности системы требованиям. 
> 
> Содержит предусловия, входные данные, последовательность шагов, ожидаемый результат и постусловия.

## Цели и задачи

- Обеспечение воспроизводимости тестирования.
- Верификация реализации требований.
- Поддержка аудита и трассируемости.
- Упрощение передачи знаний внутри команды.

## Типы тест-кейсов

- **Позитивные** — проверяют корректную работу системы при вводе валидных данных.
- **Негативные** — проверяют корректную обработку невалидных или нестандартных данных, включая срабатывание механизмов валидации.

## Структура тест-кейса

1. **Предусловия** — начальное состояние системы, необходимое для выполнения теста.
2. **Входные данные** — значения, используемые в ходе выполнения теста.
3. **Шаги** — последовательность действий, выполняемых тестировщиком или автоматизированным скриптом.
4. **Ожидаемый результат** — чётко определённое поведение системы после выполнения шагов.
5. **Постусловия** — конечное состояние системы после завершения теста.

## Лучшие практики

- Атомарность: один тест-кейс — одна проверяемая логическая единица.
- Независимость: тест-кейсы не должны зависеть друг от друга.
- Ясность: формулировки должны быть однозначными и легко читаемыми.
- Поддерживаемость: тест-кейсы должны регулярно актуализироваться при изменении требований.
- Полнота покрытия: набор тест-кейсов должен включать как позитивные, так и негативные сценарии, включая граничные случаи.

</details>

  - Тестовые скрипты (для автоматизированного тестирования)
  - Подготовленные тестовые данные

### 4. Настройка тестовой среды (`Test Environment Setup`)
- **Цель**: Создание и конфигурирование стабильной и репрезентативной среды для выполнения тестов.
- **Входные критерии**:
  - План тестирования
  - Смоук-тесты
  - Тестовые данные
- **Выходные артефакты**:
  - Готовая и проверенная тестовая среда
  - Результаты смоук-тестирования
  - Документация по настройке окружения

### 5. Выполнение тестов (`Test Execution`)
- **Цель**: Проведение тестов, регистрация результатов и управление дефектами.
- **Входные критерии**:
  - Готовая тестовая среда
  - Утвержденные тест-кейсы и/или скрипты
  - Подготовленные тестовые данные
- **Выходные артефакты**:
  - Отчет о выполнении тестов
  - Дефект-репорты (баг-репорты)
  - Обновленная матрица RTM

### 6. Завершение тестового цикла (`Test Cycle Closure`)
- **Цель**: Формализация итогов тестирования, анализ эффективности процесса и выработка рекомендаций для будущих проектов.
- **Входные критерии**:
  - Завершенное тестирование
  - Все результаты тестирования собраны
  - Нет открытых критических дефектов
- **Выходные артефакты**:
  - `Test Closure Report` (Отчет о завершении тестирования)
  - Метрики тестирования (покрытие, плотность дефектов, эффективность и т.д.)
  - Отчет об уроках, извлеченных из проекта (`Lessons Learned`)

<details>
  <summary>
    <b>Test Completion Criteria (Критерии завершения тестирования)</b>
  </summary>

## Основные понятия

- `Test Completion Criteria` (Критерии завершения тестирования) - Заранее определённый набор условий, выполнение которых сигнализирует о том, что цели тестирования достигнуты и дальнейшее тестирование нецелесообразно или не требуется.

## Ключевые критерии завершения

- `Planned Test Execution` (Выполнение запланированных тестов) - Все тест-кейсы из утверждённого тестового набора (включая функциональные, нефункциональные и регрессионные) успешно пройдены.
- `Coverage Thresholds Met` (Достижение пороговых значений покрытия) - Покрытие соответствует установленным целевым показателям:
  - `Requirements Coverage` (Покрытие требований) - Все функциональные и нефункциональные требования протестированы.
  - `Code Coverage` (Покрытие кода) - Достигнут целевой процент покрытия (например, по строкам, ветвлениям, путям).
  - `Risk Coverage` (Покрытие рисков) - Протестированы все области с высоким и средним уровнем риска.
- `Defect Convergence` (Сходимость дефектов) - Количество новых найденных дефектов за единицу времени стабильно снижается, что указывает на стабилизацию качества.
- `Zero Critical/Blocker Defects` (Отсутствие критических/блокирующих дефектов) - В системе не осталось дефектов, которые делают продукт непригодным для использования или нарушают ключевые бизнес-процессы.
- `Acceptable Defect Backlog` (Приемлемый бэклог дефектов) - Все оставшиеся дефекты имеют низкий или средний приоритет, их влияние оценено, и принято осознанное решение об их отложении.
- `Stakeholder Approval` (Утверждение заинтересованными сторонами) - Заказчик, менеджмент или другие ключевые стейкхолдеры официально подтверждают готовность продукта к выпуску.
- `Exit Criteria Fulfillment` (Выполнение критериев выхода) - Все условия, определённые в тест-плане как необходимые для завершения фазы тестирования, выполнены.

## Факторы, влияющие на решение

- `Project Timeline & Deadlines` (Сроки проекта) - Достижение жёстких дедлайнов может быть весомым аргументом для завершения, даже если не все цели достигнуты.
- `Budget Constraints` (Бюджетные ограничения) - Исчерпание выделенных ресурсов при достижении приемлемого уровня качества.
- `Risk-Based Decision` (Решение на основе рисков) - Окончательное решение принимается после взвешивания оставшихся рисков против выгоды от дальнейшего тестирования.
- `Regression Stability` (Стабильность регрессии) - Новые изменения не вызывают появления новых дефектов в уже протестированных областях.

## Важные принципы

- `Defined in Test Plan` (Определены в тест-плане) - Критерии завершения должны быть чётко сформулированы и согласованы на этапе планирования, а не определяться спонтанно.
- `Quantifiable and Measurable` (Измеримы и количественны) - Критерии должны быть объективными и проверяемыми (например, «95% тестов пройдено», а не «почти все тесты пройдены»).
- `Not Just "All Tests Passed"` (Не только «все тесты пройдены») - Прохождение тестов — лишь один из факторов; важно также учитывать качество самих тестов, покрытие и контекст проекта.

</details>

## Отличие от SDLC

- `SDLC` (`Software Development Lifecycle`) (Жизненный цикл разработки ПО) фокусируется на создании продукта: сбор требований, проектирование, разработка, внедрение.
- `STLC` является неотъемлемой частью SDLC, но его фокус — на верификации и валидации: анализ требований, планирование проверки, выполнение тестов и подтверждение качества.

</details>

<details>
  <summary>
    <b>Defects and Errors (Дефекты и ошибки)</b>
  </summary>

## Основные термины (ISTQB)

- `Error` (Ошибка) - Действие человека, которое приводит к неправильному результату.
- `Defect` / `Fault` / `Bug` (Дефект / Недочет / Баг) - Изъян в компоненте или системе, который может привести к невозможности выполнить требуемую функцию. Термины используются как синонимы.
- `Failure` (Отказ / Сбой) - Отклонение компонента или системы от ожидаемого результата, наблюдаемое при выполнении.

## Классификация дефектов

### По источнику возникновения
- `Requirements Defects` (Дефекты требований) - Двусмысленность, противоречия, неполнота в спецификациях.
- `Design Defects` (Дефекты проектирования) - Ошибки в архитектуре, алгоритмах, логике взаимодействия компонентов.
- `Coding Defects` (Дефекты кодирования) - Синтаксические, логические ошибки, проблемы с обработкой данных, управлением памятью.
- `Testing Defects` (Дефекты тестирования) - Ошибки в тест-кейсах, тестовых данных или тестовой обвязке.

### По типу проявления
- `Functional Defects` (Функциональные дефекты) - Нарушение бизнес-логики или требований.
- `UI/UX Defects` (Дефекты интерфейса) - Проблемы с отображением, навигацией, удобством использования.
- `Performance Defects` (Дефекты производительности) - Медленная работа, утечки памяти, низкая пропускная способность.
- `Security Defects` (Дефекты безопасности) - Уязвимости, позволяющие несанкционированный доступ или действия.
- `Compatibility Defects` (Дефекты совместимости) - Проблемы на разных платформах, браузерах, устройствах.
- `Localization Defects` (Дефекты локализации) - Ошибки перевода, форматирования дат/валют, культурные несоответствия.

## Ключевые концепции

- `Bug Leakage` (Утечка дефектов) - Ситуация, когда дефект не был обнаружен на этапе тестирования и найден конечным пользователем в production-среде.
- `Bug Release` (Выпуск с дефектами) - Осознанное решение выпустить продукт с известными, но низкоприоритетными дефектами, которые задокументированы в release notes.
- `Defect Masking` (Маскировка дефектов) - Случай, когда один дефект скрывает другой, не позволяя ему проявиться.
- `Latent Defect` (Скрытый дефект) - Существующий в системе дефект, который еще не вызвал отказа из-за отсутствия подходящих условий для его проявления.
- `Defect Triage` (Сортировка дефектов) - Процесс приоритизации дефектов на основе их серьезности (`Severity`), срочности (`Priority`), риска и влияния на бизнес.
- `Fault Seeding` (Подсев дефектов) - Намеренное внесение известных дефектов в систему для оценки эффективности процесса тестирования.

## Severity vs Priority

- `Severity` (Серьезность) - Техническое влияние дефекта на систему:
  - `Critical` / `Blocker`: Система неработоспособна.
  - `Major` / `High`: Основная функция нарушена.
  - `Minor` / `Medium`: Второстепенная функция нарушена.
  - `Trivial` / `Low`: Косметические ошибки (опечатки, цвета).
- `Priority` (Приоритет) - Бизнес-срочность исправления:
  - `Urgent` / `High`: Исправить немедленно.
  - `Medium`: Исправить в ближайшем релизе.
  - `Low`: Исправить, когда будет время.

## Жизненный цикл дефекта (Defect Life Cycle)

- `New` (Новый) - Дефект зарегистрирован тестировщиком.
- `Assigned` (Назначен) - Дефект подтвержден и передан команде разработки.
- `Open` (Открыт) - Разработчик анализирует и работает над исправлением.
- `Fixed` (Исправлен) - Разработчик внёс изменения и проверил их.
- `Pending Retest` (Ожидает повторного тестирования) - Исправление готово к верификации.
- `Retest` (Повторное тестирование) - Тестировщик проверяет исправление.
- `Verified` (Проверен) - Дефект успешно устранён.
- `Closed` (Закрыт) - Цикл завершён.
- `Reopen` (Переоткрыт) - Дефект не устранён и возвращается на доработку.
- `Rejected` (Отклонён) - Разработчик не согласен, что это дефект.
- `Duplicate` (Дубликат) - Такой дефект уже зарегистрирован.
- `Deferred` (Отложен) - Исправление перенесено на будущий релиз.
- `Not a Bug` (Не является багом) - Поведение соответствует требованиям, даже если кажется нелогичным.

## Отладка (Debugging) vs Тестирование (Testing)

- `Testing` (Тестирование) - Процесс выявления дефектов путем выполнения программного обеспечения.
- `Debugging` (Отладка) - Процесс анализа, локализации и устранения причины дефекта, обнаруженного в ходе тестирования. Выполняется разработчиком.

</details>

<details>
  <summary>
    <b>Test Documentation (Тестовая документация)</b>
  </summary>

## Основные понятия

- `Test Documentation` (Тестовая документация) - Совокупность артефактов, создаваемых на всех этапах тестирования для планирования, проектирования, выполнения и отчетности. Является неотъемлемой частью процесса обеспечения качества.

## Цели и важность

- **Обеспечение прозрачности и прослеживаемости** - Связывает требования с тестами и результатами через RTM.
- **Повышение эффективности** - Служит ориентиром для команды, снижает дублирование усилий.
- **Снижение рисков и затрат** - Позволяет выявлять и исправлять дефекты на ранних этапах.
- **Упрощение онбординга** - Выступает в качестве учебного материала для новых сотрудников.
- **Юридическая и регуляторная защита** - Подтверждает, что продукт был протестирован в соответствии со стандартами.
- **Непрерывное улучшение** - Предоставляет данные для анализа и оптимизации процессов тестирования.

## Классификация тестовой документации

### Внутренняя документация (для команды)

- `Test Policy` (Политика тестирования) - Стратегический документ, определяющий общие принципы и правила тестирования в организации.
- `Test Strategy` (Тестовая стратегия) - Документ высокого уровня, описывающий подход к тестированию на уровне проекта или продукта.

<details>
  <summary>
    <b>Requirements (Требования)</b>
  </summary>

## Основные понятия

- `Requirement` (Требование) - Условие или возможность, необходимая пользователю для решения задачи или достижения цели, а также обязательное для выполнения в соответствии с контрактом, стандартом или спецификацией.
- `Specification` (Спецификация) - Документ, который однозначно и исчерпывающе описывает требования, дизайн, поведение или другие характеристики системы или компонента.

## Источники и методы выявления требований

- **Интервью** - Прямое общение с заинтересованными сторонами.
- **Фокус-группы** - Обсуждение с группой представителей целевой аудитории.
- **Анкетирование** - Сбор информации от большого числа респондентов.
- **Семинары и мозговой штурм** - Коллективная генерация идей и решений.
- **Наблюдение** - Изучение реальных процессов и поведения пользователей.
- **Прототипирование** - Создание и обсуждение предварительных версий продукта.
- **Анализ документов** - Изучение существующей регламентирующей и технической документации.
- **Моделирование** - Визуализация бизнес- и технических процессов.

## Уровни и типы требований

### По уровню абстракции
- `Business Requirements` (Бизнес-требования) - Цели и причины создания продукта.
- `User Requirements` (Пользовательские требования) - Задачи, которые пользователь должен выполнять с помощью системы.
- `System Requirements` (Системные требования) - Технические детали реализации функциональности.

### По характеру
- `Functional Requirements` (Функциональные требования) - Что система должна делать.
- `Non-Functional Requirements` (Нефункциональные требования) - Как система должна это делать (качество, производительность, безопасность и т.д.).

### Специализированные типы
- `Business Rules` (Бизнес-правила) - Ограничения и условия, регулирующие бизнес-процессы.
- `Constraints` (Ограничения) - Факторы, ограничивающие выбор технологий и подходов.
- `External Interface Requirements` (Требования к интерфейсам) - Описание взаимодействия с другими системами.
- `Data Requirements` (Требования к данным) - Структура и особенности хранения данных.

## Ключевые свойства качественных требований (SMART)

- `Correctness` (Корректность) - Требование точно отражает потребность.
- `Completeness` (Полнота) - Все необходимые аспекты учтены.
- `Consistency` (Непротиворечивость) - Отсутствие внутренних и внешних противоречий.
- `Unambiguity` (Однозначность) - Требование допускает только одну интерпретацию.
- `Atomicity` (Атомарность) - Каждое требование описывает одну и только одну функцию или свойство.
- `Verifiability` (Проверяемость) - Возможность объективно подтвердить выполнение требования.
- `Feasibility` (Выполнимость) - Требование реализуемо в рамках бюджета, сроков и технологий.
- `Traceability` (Прослеживаемость) - Возможность связать требование с источником, дизайном, кодом и тестами.
- `Modifiability` (Модифицируемость) - Простота внесения изменений без нарушения целостности.
- `Prioritization` (Приоритезация) - Четкое определение важности, срочности и стабильности.

## Типы документов с требованиями

- `BRD` (`Business Requirements Document`) - Определяет бизнес-задачи и цели проекта.
- `MRD` (`Market Requirements Document`) - Описывает рыночные потребности и конкурентную среду.
- `PRD` (`Product Requirements Document`) - Детализирует функциональные возможности продукта.
- `BRS` (`Business Requirement Specification`) - Широкое описание бизнес-потребностей.
- `SRS` (`Software Requirements Specification`) - Полный набор функциональных и нефункциональных требований к ПО.
- `FRS` / `FSD` (`Functional Requirement/Specification Document`) - Подробное описание поведения системы с точки зрения пользователя.
- `TDS` (`Technical Design Specification`) - Техническое описание архитектуры и реализации.

## Роль требований в тестировании

- **Основа для тест-дизайна** - Каждый тест-кейс должен быть связан с конкретным требованием.
- **Критерии приемки** - Требования формируют основу для определения, когда продукт готов к выпуску.
- **Матрица трассируемости (RTM)** - Инструмент для обеспечения полного покрытия требований тестами и отслеживания их статуса.
- **Управление изменениями** - Любое изменение в требованиях должно приводить к пересмотру соответствующих тестов.

## Лучшие практики работы с требованиями

- Активное участие тестировщиков в процессе сбора и анализа требований.
- Ранняя проверка требований на соответствие свойствам SMART.
- Использование специализированных инструментов для управления требованиями (Jira, Confluence, ReqSuite, IBM DOORS).
- Постоянное обновление и актуализация требований по мере развития проекта.
- Регулярная коммуникация между аналитиками, разработчиками и тестировщиками для уточнения неясных моментов.

</details>

<details>
  <summary>
    <b>Test Plan (План тестирования) - Детальный план, охватывающий цели, объем, ресурсы, расписание, риски и критерии завершения</b>
  </summary>

## Основные понятия

- `Test Plan` (Тест-план) - Ключевой артефакт тестирования, описывающий стратегию, цели, ресурсы, расписание и методологию для достижения целей качества в рамках проекта или релиза.
- `Living Document` (Живой документ) - Тест-план должен регулярно обновляться по мере изменения требований, рисков и условий проекта.

## Цели тест-плана

- Определить **объем и фокус** тестирования.
- Служить **единой точкой согласования** между всеми заинтересованными сторонами.
- Обеспечить **прозрачность** процесса тестирования.
- Служить основой для **оценки рисков** и планирования их смягчения.
- Обеспечить **основу для отчетности** и измерения прогресса.

## Структура тест-плана (IEEE 829)

### 1. Идентификация и административная информация
- Название проекта и документа
- Версия документа
- Авторы и дата создания
- Утверждение заинтересованными сторонами

### 2. История изменений
- Таблица с датой, версией, описанием изменений и автором.

### 3. Введение
- Краткое описание проекта, его целей и бизнес-ценности.
- Ссылки на исходные документы (SRS, BRS).

### 4. Цели тестирования
- Конкретные, измеримые цели, которые должны быть достигнуты в результате тестирования.

### 5. Область тестирования
- **Включено**: Перечень функций, модулей и компонентов, подлежащих тестированию.
- **Не включено**: Явное указание того, что не будет тестироваться и почему.

### 6. Стратегия и подход к тестированию
- Уровни тестирования (модульное, интеграционное, системное, приемочное).
- Типы тестирования (функциональное, нефункциональное, регрессионное и т.д.).
- Методы тест-дизайна (эквивалентное разбиение, граничные значения и др.).
- Подход к автоматизации (что, как и когда будет автоматизировано).

### 7. Ресурсы
- **Люди**: Команда тестирования, их роли и ответственности.
- **Инструменты**: Средства управления тестами, автоматизации, баг-трекинга.
- **Окружение**: Описание необходимых тестовых сред и их доступность.

### 8. Расписание и вехи
- Ключевые даты и зависимости.
- Длительность каждого этапа тестирования.
- Интеграция с общим графиком проекта.

### 9. Критерии
- **Входа (Entry Criteria)**: Условия, при которых можно начинать тестирование.
- **Выхода (Exit Criteria)**: Условия, при которых тестирование считается завершенным.
- **Приостановки/Возобновления**: Условия для паузы и возобновления тестирования.
- **Приемки**: Условия, при которых продукт считается готовым к выпуску.

### 10. Риски и предположения
- **Риски**: Потенциальные проблемы, которые могут повлиять на тестирование.
- **Стратегии смягчения**: Планы по устранению или снижению влияния рисков.
- **Предположения**: Факторы, которые считаются истинными на момент написания плана.

### 11. Организация и коммуникации
- Роли и обязанности всех участников.
- Каналы и частота коммуникации.
- Формат и получатели отчетов.

### 12. Метрики и отчетность
- Ключевые метрики для отслеживания прогресса и качества.
- Формат и периодичность отчетов.

## Лучшие практики

- **Согласование**: Тест-план должен быть утвержден всеми ключевыми стейкхолдерами.
- **Краткость**: Документ должен быть достаточно подробным, но не избыточным.
- **Актуальность**: Регулярно пересматривайте и обновляйте план.
- **Доступность**: Храните документ в централизованном и доступном месте.
- **Гибкость**: Особенно в Agile-проектах, план должен быть адаптивным, а не жестким.

</details>

- `Test Scenario` (Тестовый сценарий) - Описание функциональной области или бизнес-потока, подлежащего тестированию.
- `Test Case` (Тест-кейс) - Набор условий, входных данных, шагов и ожидаемых результатов для проверки конкретного требования.
  - `High-Level Test Case` (Высокоуровневый тест-кейс): Тест-кейс без конкретных входных данных и ожидаемых результатов. Описывает общие идеи и операции, часто используется в интеграционном и системном тестировании.
  - `Low-Level` / `Detailed Test Case` (Низкоуровневый / Детальный тест-кейс): Тест-кейс с конкретными входными данными и ожидаемыми результатами. Готовый к выполнению сценарий.
- `Test Suite` (Набор тестов) - Набор тестовых случаев, собранных вместе для выполнения определенной цели (например, регрессия, smoke test).
- `Test Data` (Тестовые данные) - Набор данных, необходимых для выполнения тест-кейсов.
- `Test Execution Log` (Журнал выполнения тестов) - Запись результатов выполнения каждого тест-кейса (пройден/провален/заблокирован).
- `Requirements Traceability Matrix` (`RTM`) (Матрица трассируемости требований) - Таблица, связывающая требования с соответствующими тест-кейсами.
- `Test Design Specification` (Спецификация тест-дизайна) - Документ, описывающий условия тестирования для компонента или системы, охватываемые набором тестов, и высокоуровневый подход к их тестированию.
- `Test Case Specification` (Спецификация тест-кейсов) - Документ, описывающий набор тест-кейсов (включая их цели, входные данные, шаги и ожидаемые результаты) для тестируемого элемента.
- `Test Procedure Specification` (Спецификация тестовых процедур) - Документ, определяющий последовательность действий для выполнения теста (часто синоним тестового сценария или скрипта).

### Внешняя документация (для стейкхолдеров)

<details>
  <summary>
    <b>Defect/Bug Report (Баг-репорт) - Детальное описание обнаруженного дефекта, включая шаги воспроизведения, серьезность, приоритет и окружение</b>
  </summary>

- `ID` / `Identifier` (Идентификатор): Уникальный номер (например, `BUG-12345`), однозначно идентифицирующий отчет в баг трекере.
- `Title` / `Summary` (Заголовок / Краткое описание): Лаконичное описание, отвечающее на вопросы: Что? Где? При каких условиях?
- `Description` (Подробное описание): Развернутое описание проблемы. Обязательно включает:
  - `Actual Result` (Фактический результат): Что происходит на самом деле.
  - `Expected Result` (Ожидаемый результат): Что должно было произойти согласно требованиям или здравому смыслу.
  - `Link to Requirement` (Ссылка на требование): Если применимо.
- `Steps to Reproduce` / `STR` (Шаги воспроизведения): Детальная, пошаговая инструкция для однозначного воспроизведения дефекта с указанием конкретных тестовых данных.
- `Reproducibility` (Воспроизводимость): Показывает, как часто дефект проявляется: `Always` (Всегда) или `Sometimes` (Иногда).
- `Severity` (Серьезность / Важность): Степень влияния дефекта на работу системы или пользователя.
  - `Critical` / `Blocker` (Критический): Приводит к краху (crash), потере данных, блокирует ключевую функциональность.
  - `Major` / `High` (Высокий): Существенная потеря функциональности без обходного пути.
  - `Medium` / `Normal` (Средний): Проблема с обходным путем или незначительная функциональная ошибка.
  - `Minor` / `Low` (Низкий): Незначительная проблема, не влияющая на функциональность (например, опечатка, косметический дефект (cosmetic flaw)).
- `Priority` (Приоритет / Срочность): Очередность исправления дефекта с точки зрения бизнеса/проекта.
  - `ASAP` / `P0 - Highest` (Наивысший): Требует немедленного исправления.
  - `High` / `P1` (Высокий): Должен быть исправлен в ближайшем билде (build) или спринте (sprint).
  - `Medium` / `P2`(Средний): Исправляется в обычном порядке.
  - `Low` / `P3` (Низкий): Может быть исправлен, когда будет время.
- `Environment` (Окружение): Информация о среде, где был найден баг: ОС, браузер, версия приложения, устройство и т.д.
- `Attachments` (Вложения): Скриншоты, логи, видео, которые помогают понять проблему.
- `Status` (Статус): Текущий этап жизненного цикла бага.
- `Assignee` (Исполнитель): Пользователь, ответственный за работу с отчетом на текущем этапе.
- `Comments` / `Notes` (Комментарии): История обсуждения между тестировщиком, разработчиком и другими участниками.

---

- `Bug Type` / `Symptom` (Тип бага / Симптом): Классификация по характеру проявления: 
  - `Functional` (Функциональный)
  - `UI` (Интерфейс)
  - `Performance` (Производительность)
  - `Security` (Безопасность)
  - `Localization` (Локализация) и т.д.
- `Root Cause` (Коренная причина): Истинная причина дефекта в коде или дизайне, а не его симптом.
- `Reporter` / `Created By` (Автор): Тестировщик или пользователь, создавший отчет.
- `Duplicate` (Дубликат): Статус или ссылка, указывающая, что данный дефект уже был зарегистрирован в другом отчете.
- `Related Issues` / `Linked Items` (Связанные задачи): Ссылки на связанные user stories, задачи или другие баги.

</details>

- `Test Summary Report` (Сводный отчет о тестировании) - Итоговый документ, содержащий метрики, статус тестирования, риски и рекомендации по выпуску.
- `User Acceptance Test (UAT) Report` (Отчет о приемочном тестировании) - Документ, подтверждающий соответствие продукта ожиданиям заказчика и готовность к эксплуатации.

## Структура тест-кейса

- `Test Case ID` (Идентификатор тест-кейса): Уникальный номер или код для идентификации (например, `TC-API-LOGIN-01`).
- `Title` / `Summary` (Название / Заголовок): Краткое, понятное описание того, что проверяет тест.
- `Description` / `Objective` (Описание / Цель): Более подробное описание цели теста и/или функциональности, которую он проверяет.
- `Preconditions` / `Prerequisites` (Предусловия): Условия, которые должны быть выполнены до начала теста (например, "Пользователь зарегистрирован", "Данные загружены в систему").
- `Test Data` (Тестовые данные): Конкретные значения (значения полей, файлы), которые будут использоваться в тесте.
- `Test Steps` / `Procedure` (Шаги теста / Процедура): Пронумерованная последовательность конкретных действий для выполнения теста.
  - `Step Action` (Действие): Что делает тестировщик.
  - `Test Data` (Тестовые данные): Данные для этого шага (если не вынесены отдельно).
  - `Expected Result` (Ожидаемый результат): Как система должна отреагировать на это действие.
- `Postconditions` (Постусловия): Состояние системы после выполнения теста (например, "Сессия пользователя завершена").
- `Actual Result` (Фактический результат): Поле для записи того, что произошло на самом деле во время выполнения. Заполняется тестировщиком.
- `Status` (Статус): Результат выполнения теста: 
  - `Passed` (Пройден)
  - `Failed` (Провален)
  - `Blocked` (Заблокирован)
  - `Not Executed` (Не выполнен)
- `Priority` (Приоритет): Важность выполнения данного теста:
  - `High`
  - `Medium`
  - `Low`
- `Severity` (Серьезность): Применимо к багу, найденному этим тестом. Чаще является атрибутом баг-репорта.
- `Author` / `Created By` (Автор): Создатель тест-кейса.
- `Linked Requirements` (Связанные требования): Ссылка на требование или user story, которое проверяется этим тестом (например, REQ-123).

## Смежные понятия

- `Checklist` (Чек-лист): Список пунктов, которые необходимо проверить. Менее формален, чем тест-кейс, и не содержит подробных шагов.
- `Test Charter` (Чартер теста): Краткое описание целей, объема и подхода для сессии исследовательского тестирования (`exploratory testing`).
- `Test Script` (Тест-скрипт): Автоматизированный сценарий тестирования, написанный на языке программирования (например, код на Java для Selenium).
- `Bug Report` / `Defect Report` (Отчет об ошибке): Отчет о несоответствии, обнаруженном во время тестирования. Создается при провале тест-кейса.

## Лучшие практики создания

- **Актуальность** - Документация должна постоянно обновляться в соответствии с изменениями в требованиях и коде.
- **Централизованное хранение** - Все документы должны быть доступны в едином, защищенном и надежном месте (например, Confluence, TestRail, Jira).
- **Использование шаблонов** - Применение стандартных шаблонов обеспечивает согласованность и экономит время.
- **Детализация** - Документы должны содержать достаточно информации для полного понимания, но избегать избыточности.
- **Читаемость и структура** - Информация должна быть четко организована, легко читаема и понятна целевой аудитории.
- **Регулярный аудит** - Периодический пересмотр документации для удаления устаревших и добавления новых артефактов.

## Преимущества качественной документации

- Ускорение процесса тестирования за счет четкого понимания требований.
- Повышение качества тест-кейсов и покрытия.
- Облегчение коммуникации между всеми участниками проекта.
- Создание базы знаний, независимой от конкретных сотрудников.
- Обеспечение повторяемости и воспроизводимости тестов.

</details>

<details>
  <summary>
    <b>Software Test Metrics (Метрики тестирования)</b>
  </summary>

## Основные понятия

- `Test Metric` (Метрика тестирования) - Количественная мера, используемая для оценки процесса тестирования, его эффективности и качества продукта.
- `Process Metrics` (Метрики процесса) - Измеряют эффективность и производительность самого процесса тестирования.
- `Product Metrics` (Метрики продукта) - Измеряют качество программного обеспечения через характеристики обнаруженных дефектов и покрытия.

## Ключевые метрики процесса

- `Test Case Preparation Productivity` (Продуктивность подготовки тест-кейсов) - Количество тест-кейсов, созданных за единицу времени.
- `Test Design Coverage` (Покрытие тестовым дизайном) - Процент требований, для которых созданы тест-кейсы.
- `Test Execution Productivity` (Продуктивность выполнения тестов) - Количество тест-кейсов, выполняемых за единицу времени.
- `Test Execution Coverage` (Покрытие выполнением тестов) - Процент запланированных тест-кейсов, которые были фактически выполнены.
- `Test Pass/Fail/Block Rate` (Процент пройденных/проваленных/заблокированных тестов) - Распределение результатов выполнения тестового набора.

## Ключевые метрики продукта

- `Defect Density` (Плотность дефектов) - Количество дефектов на единицу размера продукта (требования, строки кода).
- `Defect Detection Percentage` (`DDP`) (Процент обнаружения дефектов) - Доля дефектов, найденных на текущем этапе, от общего числа дефектов, обнаруженных на этом и всех последующих этапах.
- `Defect Leakage` (Утечка дефектов) - Процент дефектов, найденных на более поздних этапах (например, в UAT или production), по отношению к тем, что были найдены ранее.
- `Defect Removal Efficiency` (Эффективность устранения дефектов) - Способность процесса тестирования находить дефекты до выпуска продукта.
- `Error Discovery Rate` (Скорость обнаружения ошибок) - Количество дефектов, обнаруженных на единицу выполненных тестов.

## Тестовое покрытие (Test Coverage)

- `Requirements Coverage` (Покрытие требований) - Процент требований, связанных с хотя бы одним тест-кейсом (обычно отслеживается через RTM).
- `Code Coverage` (Покрытие кода) - Процент исполняемого кода, который был задействован при выполнении тестов. Основные типы:
  - Покрытие по строкам (Line coverage)
  - Покрытие по ветвлениям (Branch coverage)
  - Покрытие по путям (Path coverage)
- `Risk Coverage` (Покрытие рисков) - Процент выявленных рисков, для которых разработаны тесты.

## Альтернативные метрики качества тестов (CTM)

- `PDWT` (`Percentage of Developers Writing Tests`) - Процент разработчиков, которые пишут автоматизированные тесты.
- `PBCNT` (`Percentage of Bugs Creating New Tests`) - Процент багов, после исправления которых был написан регрессионный тест.
- `PTVB` (`Percentage of Tests Verifying Behavior`) - Процент тестов, проверяющих поведение системы, а не её внутреннюю реализацию (устойчивые к рефакторингу).
- `PTD` (`Percentage of Test Determinism`) - Процент детерминированных (стабильных, непрерывистых) тестов в общем наборе.

## Важные принципы

- Метрики — это инструмент для принятия решений, а не цель сама по себе.
- Слепое стремление к 100% покрытию кода может привести к написанию бесполезных тестов.
- Главная ценность метрик — в их способности выявлять тренды и проблемы, а не в абсолютных цифрах.
- Необходимо использовать комплекс метрик, так как ни одна из них не даёт полной картины качества.

</details>

## МЕТОДОЛОГИИ И ТЕХНИКИ ТЕСТИРОВАНИЯ

<details>
  <summary>
    <b>Test-Design technics (Техники тест-дизайна</b>
  </summary>

> Тест-дизайн – это этап процесса тестирования ПО, на котором проектируются и создаются тест-кейсы, в соответствии с определёнными ранее критериями качества и целями тестирования.

## Ключевые концепции:

- Тест-аналитик: Определяет "Что тестировать?".
- Тест-дизайнер: Определяет "Как тестировать?".
- Тестовое покрытие (`Test Coverage`): Метрика, оценивающая полноту тестирования.
  - Покрытие требований (`Requirements Coverage`): Оценка по трассировке тестов к функциональным требованиям.
  - Покрытие кода (`Code Coverage`): Оценка по проценту исполненного кода в тестах.

## Классификация техник тест-дизайна (по источнику знаний)

1.  **Методы чёрного ящика (Black-box, спецификационные):** Фокусируются на поведении системы (вход -> выход) без знания внутреннего устройства.
2.  **Методы белого ящика (White-box, структурные):** Основаны на знании внутренней структуры кода, логики программы. (Требуют навыков программирования. *В вашем текущем блоке отсутствуют, стоит добавить ключевые*).
3.  **Методы, основанные на опыте (Experience-based):** Используют знания и интуицию тестировщиков, пользователей, экспертов.

## Основные техники тест-дизайна:

### Методы чёрного ящика (Black-box):

<details>
  <summary>
    <b>Equivalence Partitioning & Boundary Value Analysis (Эквивалентное разбиение и анализ граничных значений)</b>
  </summary>

## Основные понятия

- `Equivalence Partitioning` (`EP`) (Эквивалентное разбиение) - Техника чёрного ящика, при которой входные данные делятся на группы (классы эквивалентности), где все значения в группе ожидаются вызывать одинаковое поведение системы.
- `Boundary Value Analysis` (`BVA`) (Анализ граничных значений) - Техника тестирования, фокусирующаяся на проверке значений на границах классов эквивалентности, так как ошибки чаще всего возникают именно на границах.

## Принципы эквивалентного разбиения

- **Валидные классы** - Наборы входных данных, которые должны быть приняты системой.
- **Невалидные классы** - Наборы входных данных, которые должны быть отклонены системой.
- **Одно значение на класс** - Достаточно протестировать одно значение из каждого класса, так как все значения в классе считаются эквивалентными.

## Принципы анализа граничных значений

- **Минимум и максимум** - Проверяются минимальное и максимальное допустимые значения.
- **Границы +1 и -1** - Проверяются значения, непосредственно примыкающие к границам с обеих сторон (например, min-1, min, min+1, max-1, max, max+1).
- **Применимость** - Используется для любых упорядоченных типов данных: числа, даты, строки (по длине).

## Когда применять

- При наличии **ограничений на входные данные** (диапазоны, списки, форматы).
- Для **поля ввода с четкими правилами валидации**.
- На **любом уровне тестирования** (модульном, интеграционном, системном).
- В сочетании с другими техниками тест-дизайна для повышения покрытия.

## Алгоритм применения

1. **Определить все входные параметры** тестируемой функции.
2. **Выделить классы эквивалентности** для каждого параметра (валидные и невалидные).
3. **Определить граничные значения** для каждого класса.
4. **Создать тест-кейсы**:
  - По одному значению из каждого класса эквивалентности.
  - Все граничные значения и их соседи.
5. **Оптимизировать набор тестов**, удаляя дублирующиеся или избыточные проверки.

## Преимущества

- **Снижение количества тестов** - Значительно уменьшает объем тестовых данных без потери качества.
- **Фокус на рисках** - Концентрирует внимание на наиболее уязвимых местах (границах).
- **Простота и эффективность** - Легко понимается и применяется даже начинающими тестировщиками.
- **Систематический подход** - Обеспечивает структурированное и полное покрытие требований.

## Примеры классов эквивалентности

- **Числовые диапазоны**: [1-10] → валидный, [≤0], [11-99], [≥100] → невалидные.
- **Длина строки**: [6-10 символов] → валидная, [0-5], [11+] → невалидные.
- **Списки выбора**: Выбранный элемент из списка → валидный, ввод несуществующего значения → невалидный.
- **Форматы данных**: Корректный email → валидный, некорректный формат → невалидный.

## Лучшие практики

- Всегда использовать **BVA вместе с EP** для максимальной эффективности.
- Учитывать **специфические бизнес-правила**, которые могут создавать дополнительные классы.
- Проверять **комбинации входных параметров** с помощью других техник (например, таблиц решений), если параметры взаимозависимы.
- Документировать **логику выделения классов** для обеспечения прозрачности и прослеживаемости.

</details>

<details>
  <summary>
    <b>Decision Table Testing (Таблицы решений / Принятия решений): Формализация бизнес-логики, где комбинации входных условий (причин) определяют выходные действия (следствия). Более формализованная и полная версия Cause/Effect</b>
  </summary>

## Основные понятия

- `Decision Table` (Таблица решений) - Техника чёрного ящика для проектирования тестов, основанная на анализе комбинаций входных условий и соответствующих им действий или выходных результатов.
- `Combinatorial Testing` (Комбинаторное тестирование) - Подход, направленный на проверку различных комбинаций входных параметров для выявления сложных дефектов.

## Когда применять

- В бизнес-логике присутствуют **сложные правила**, зависящие от нескольких условий.
- Требования описывают **разные исходы** в зависимости от комбинации факторов.
- Необходимо обеспечить **полное покрытие** всех возможных сценариев принятия решений.
- Примеры: расчет скидок, определение тарифов, валидация форм с множеством зависимых полей, обработка заказов.

## Структура таблицы решений

1. **Condition Stubs** (Заголовки условий) - Список входных условий или предпосылок.
2. **Condition Entries** (Входные значения условий) - Комбинации значений (обычно "Да/Нет", "Истина/Ложь", "0/1").
3. **Action Stubs** (Заголовки действий) - Список возможных системных реакций или выходных результатов.
4. **Action Entries** (Выходные значения действий) - Указание, какое действие выполняется при каждой комбинации условий.

## Алгоритм построения

1. **Идентифицировать все условия** из требований.
2. **Определить все возможные действия** системы.
3. **Рассчитать количество комбинаций**: N = V₁ × V₂ × ... × Vₙ, где V — количество значений для каждого условия.
4. **Построить таблицу** и заполнить колонки всеми уникальными комбинациями условий.
5. **Определить действия** для каждой комбинации на основе бизнес-правил.
6. **Оптимизировать таблицу**:
  - Удалить невозможные или противоречивые комбинации.
  - Объединить столбцы с одинаковыми результатами.
  - Уточнить неоднозначные случаи у аналитиков.

## Преимущества

- **Полнота покрытия** - Гарантирует, что не будет упущена ни одна логическая комбинация.
- **Наглядность** - Сложная логика представляется в простой и структурированной форме.
- **Простота преобразования в тест-кейсы** - Каждый столбец таблицы напрямую соответствует одному тест-кейсу.
- **Универсальность** - Может быть реализована с помощью любых табличных инструментов (Excel, Google Sheets).

## Недостатки

- **Экспоненциальный рост** - При большом количестве условий число комбинаций становится непрактичным (проблема "комбинаторного взрыва").
- **Трудоёмкость** - Требует значительных временных затрат на анализ и построение.
- **Не подходит для простых сценариев** - Избыточна для линейных процессов с одним или двумя условиями.

## Лучшие практики

- Использовать технику **парного тестирования** (`Pairwise Testing`) для сокращения числа комбинаций при большом количестве входных параметров.
- Активно сотрудничать с **бизнес-аналитиками** для уточнения правил и устранения неоднозначностей.
- Интегрировать таблицы решений в **спецификации требований** как живую документацию.
- Рассматривать каждую строку таблицы как **спецификацию для автоматизированного теста**.

</details>

- `State Transition Testing` (Тестирование переходов состояний): Используется, когда система по-разному реагирует на одни и те же события в зависимости от текущего состояния. Тесты строятся на основе диаграммы состояний и переходов.
- `Use Case Testing` (Тестирование на основе сценариев использования): Тестирование типичных пользовательских сценариев (use cases) для проверки, удовлетворяет ли система своим целям и задачам.

### Методы белого ящика (White-box):
- `Statement Coverage` (Покрытие операторов/инструкций): Каждая строка кода должна быть выполнена хотя бы один раз.
- `Branch/Decision Coverage` (Покрытие ветвей/условий): Каждая возможная ветвь (true/false) в управляющих структурах (if, switch, циклы) должна быть выполнена хотя бы один раз.
- `Path Coverage` (Покрытие путей): Проверка всех возможных уникальных путей выполнения через блок кода. Часто нереализуемо на практике из-за комбинаторного взрыва.

### Методы, основанные на опыте (Experience-based):
- `Error Guessing` - `EG` (Предугадывание Ошибки): Использование опыта тестировщика, интуиции и знания системы для предположения о потенциальных дефектах и создание тестов под эти сценарии.
- `Exploratory Testing` - `ET` (Исследовательское тестирование): Одновременное изучение системы, проектирование тестов и их выполнение. Активность тестирования управляется идеями тестировщика, а не заранее написанными тест-кейсами.
- `Checklist-Based Testing` (Тестирование на основе чек-листов): Использование списка контрольных пунктов (чек-листа) для направления тестовой активности, но без строго прописанных шагов.

## Техники оптимизации и комбинирования:

<details>
  <summary>
    <b>Pairwise Testing (Попарное тестирование)</b>
  </summary>

## Основные понятия

- `Pairwise Testing` (Попарное тестирование) - Техника комбинаторного тестирования, основанная на предположении, что большинство дефектов вызывается взаимодействием значений **двух** параметров, а не всей их совокупности.
- `Combinatorial Testing` (Комбинаторное тестирование) - Общий класс методов, направленных на проверку различных комбинаций входных параметров.
- `All-Pairs Testing` (Тестирование всех пар) - Синоним попарного тестирования.

## Принцип работы

Вместо тестирования **всех возможных комбинаций** (что приводит к экспоненциальному росту числа тестов), попарное тестирование генерирует минимальный набор тестовых случаев, в котором **каждая возможная пара значений любых двух параметров встречается хотя бы один раз**.

### Пример

Допустим, у нас есть 3 параметра:
- Браузер: Chrome, Firefox, Safari
- ОС: Windows, macOS, Linux
- Язык: EN, RU

**Полный перебор**: 3 × 3 × 2 = **18 тестов**  
**Попарное тестирование**: ~**9–12 тестов** (в зависимости от алгоритма), при этом каждая пара (Браузер-ОС, Браузер-Язык, ОС-Язык) покрыта полностью.

## Когда применять

- При наличии **многих входных параметров** с несколькими значениями.
- Когда **полный перебор** непрактичен из-за времени или ресурсов.
- Для **конфигурационного тестирования** (разные ОС, браузеры, устройства).
- При **тестировании форм** с множеством зависимых полей.
- В **API-тестировании** с большим числом параметров запроса.

## Преимущества

- **Значительное сокращение** количества тест-кейсов (часто на 70–90%).
- **Высокая эффективность** — обнаруживает до 90% дефектов, вызванных взаимодействием двух параметров.
- **Ускорение** как создания, так и выполнения тестов.
- **Снижение затрат** на тестирование без существенной потери качества.
- **Лучшее покрытие**, чем случайный или интуитивный выбор тестов.

## Недостатки

- **Не гарантирует** обнаружение дефектов, вызванных взаимодействием **трёх и более** параметров.
- **Требует специальных инструментов** для генерации оптимальных наборов (вручную сложно).
- Может быть **избыточным** для простых систем с малым числом параметров.

## Популярные инструменты

- **PICT** (Microsoft) — консольный генератор тестовых наборов.
- **AllPairs** — простой скрипт для генерации попарных комбинаций.
- **Hexawise** — коммерческий инструмент с визуальным интерфейсом и расширенными возможностями.
- **TestRail**, **Xray**, **qTest** — системы управления тестами с поддержкой интеграции попарного тестирования.

## Лучшие практики

- Использовать **только после анализа требований** — не все параметры взаимодействуют.
- Исключать **несовместимые комбинации** (например, Safari на Windows).
- Комбинировать с **анализом граничных значений** и **эквивалентным разбиением**.
- Применять **иерархию приоритетов** — критические параметры можно тестировать с покрытием троек (`3-wise`).
- Интегрировать в **CI/CD pipeline** для автоматического генерирования и запуска тестов.

## Расширения метода

- `N-wise Testing` — обобщение метода для N параметров (например, 3-wise, 4-wise).
- `Orthogonal Arrays` (Ортогональные массивы) — математический подход к построению сбалансированных наборов комбинаций.
- `Risk-Based Pairwise Testing` — фокус на парах параметров с высоким риском.

</details>

- `Pairwise Testing` - `PT` (Попарное / Парное тестирование): Метод оптимизации: создание наборов тестовых данных, где каждое значение каждого параметра хотя бы раз сочетается с каждым значением всех других параметров. Эффективно для снижения количества тестовых комбинаций.
- `Exhaustive Testing` (Исчерпывающее Тестирование): Теоретическая техника, предполагающая проверку ВСЕХ возможных комбинаций входных данных. На практике неприменима для нетривиальных систем.

</details>

<details>
  <summary>
    <b>Risk-based Testing (Тестирование на основе рисков)</b>
  </summary>

## Основные понятия

- `Risk-based Testing` (`RBT`) (Тестирование на основе рисков) - Методология, при которой объем, глубина и приоритеты тестирования определяются на основе анализа потенциальных рисков для продукта и проекта.
- `Risk Assessment` / `Risk Analysis` (Оценка / Анализ рисков) - Процесс идентификации, анализа и приоритизации рисков для определения их потенциального воздействия и вероятности возникновения.

## Основные категории рисков

- `Product Risks` / `Quality Risks` (Риски продукта / Риски качества) - Риски, связанные непосредственно с качеством и характеристиками разрабатываемого продукта (например, дефекты, уязвимости, низкая производительность).
- `Project Risks` (Риски проекта) - Риски, связанные с управлением и реализацией проекта (например, срывы сроков, превышение бюджета, нехватка квалифицированных ресурсов).

## Ключевые виды рисков продукта (Product Risks)

- `Functional Risks` (Функциональные риски) - Риск некорректной реализации или невыполнения ключевых функций продукта, что делает его непригодным для использования.
- `Security Risks` (Риски безопасности) - Риск наличия уязвимостей, которые могут привести к утечке данных, несанкционированному доступу или атакам на систему.
- `Performance Risks` (Риски производительности) - Риск, что система не будет соответствовать требованиям по скорости, времени отклика, стабильности или масштабируемости под нагрузкой.
- `Technical Risks` / `Architectural Risks` (Технические / Архитектурные риски) - Риски, вызванные сложностью, новизной технологий, ошибками в проектировании или интеграцией со сторонними системами.
- `Usability & UX Risks` (Риски удобства использования) - Риск создания продукта с плохим пользовательским интерфейсом, что приведет к неудовлетворенности и оттоку пользователей.
- `Compliance & Legal Risks` (Риски соответствия / Правовые риски) - Риск несоответствия продукта законодательным нормам, отраслевым стандартам или лицензионным соглашениям.

## Ключевые виды рисков проекта (Project Risks)

- `Schedule & Time Risks` (Риски графика) - Риск срыва сроков релиза из-за переоценки возможностей, изменения требований или технических сложностей.
- `Budget & Financial Risks` (Бюджетные / Финансовые риски) - Риск превышения бюджета проекта из-за доработок, увеличения команды или внешних факторов.
- `Resource & People Risks` (Ресурсные / Кадровые риски) - Риск, связанный с нехваткой, недостаточной квалификацией или текучестью членов команды (тестировщиков, разработчиков).
- `Requirements & Scope Risks` (Риски требований / Объема работ) - Риск нечетких, постоянно меняющихся или противоречивых требований, ведущих к непониманию и ошибкам.

## Процесс и практики

- `Risk Priority Number` (`RPN`) (Приоритетное число риска) - Числовая оценка риска, часто рассчитываемая как произведение его Вероятности (Probability) и Влияния (Impact).
- `Risk Mitigation` (Смягчение рисков) - Действия, направленные на снижение вероятности возникновения риска или минимизацию его негативных последствий.
- `Test Prioritization` (Приоритизация тестирования) - Распределение усилий по тестированию: высокоприоритетные тесты покрывают области с наибольшим уровнем риска.
- `Residual Risk` (Остаточный риск) - Риск, который остается после применения всех запланированных мер по его смягчению. Осознанное решение, принимаемое заинтересованными сторонами.

</details>

<details>
  <summary>
    <b>Root Cause Analysis (RCA) (Анализ первопричин)</b>
  </summary>

## Основные понятия

- `Root Cause Analysis` (`RCA`) (Анализ первопричин) - Систематический подход к выявлению фундаментальных (корневых) причин инцидентов, дефектов или сбоев с целью их устранения и предотвращения повторного возникновения.
- `Incident` (Инцидент) - Любое нежелательное событие, нарушающее нормальное функционирование системы (например, сбой в production, утечка данных, критический баг).

## Цели и значение RCA

- `Prevent Recurrence` (Предотвращение повторения) - Главная цель — не просто исправить проявление проблемы, а устранить её источник, чтобы она больше не возникала.
- `Improve Quality` (Повышение качества) - Устранение системных недостатков напрямую ведет к повышению надежности и стабильности продукта.
- `Enhance Processes` (Совершенствование процессов) - Выявленные причины часто указывают на слабые места в процессах разработки, тестирования или эксплуатации, что дает возможность их улучшить.
- `Reduce Costs` (Снижение затрат) - Решение проблемы на корню гораздо дешевле, чем постоянная борьба с её последствиями.

## Процесс проведения RCA (5 этапов)

1. **Определение проблемы и её влияния**  
   Четко сформулируйте, что пошло не так, и оцените воздействие на бизнес-цели (финансы, репутация, пользователи).

2. **Поиск вероятных причин**  
   Проведите мозговой штурм или используйте структурированные методы (например, диаграмму Исикавы) для генерации списка потенциальных причин.

3. **Сбор информации и анализ**  
   Соберите данные (логи, метрики, отчеты, свидетельства), чтобы подтвердить или опровергнуть каждую из вероятных причин.

4. **Причинно-следственный анализ**  
   Используйте техники вроде «5 Почему» или FMEA, чтобы углубиться от симптомов к истинной первопричине.

5. **Разработка и внедрение решений**  
   Выберите наиболее эффективные корректирующие и превентивные действия, назначьте ответственных и сроки, а затем отслеживайте их эффективность.

## Преимущества RCA

- Создает культуру ответственности и непрерывного улучшения.
- Повышает прозрачность и предсказуемость процессов разработки.
- Снижает количество инцидентов в production-среде.
- Повышает доверие клиентов и заинтересованных сторон к продукту и команде.

## Когда проводить RCA

- После критических сбоев в production.
- При обнаружении повторяющихся или хронических дефектов.
- В рамках ретроспективы спринта или завершения проекта.
- При значительном отклонении от плановых показателей качества или сроков.

</details>

<details>
  <summary>
    <b>State Transition Testing (Тестирование перехода состояний)</b>
  </summary>

## Основные понятия

- `State Transition Testing` (Тестирование перехода состояний) - Техника чёрного ящика, используемая для тестирования систем, поведение которых зависит от текущего состояния и изменяется в ответ на события или входные данные.
- `State` (Состояние) - Условие или ситуация, в которой система находится в определённый момент времени.
- `Transition` (Переход) - Изменение состояния системы в ответ на событие или входное воздействие.
- `State Transition Diagram` (`STD`) (Диаграмма переходов состояний) - Визуальное представление всех возможных состояний системы и допустимых переходов между ними.
- `Event` (Событие) - Внешний или внутренний триггер, вызывающий переход между состояниями.

## Когда применять

- Система имеет **конечное число чётко определённых состояний**.
- Поведение системы **зависит от последовательности событий**, а не только от текущего ввода.
- Требования описывают **реакцию на события** в зависимости от текущего состояния.
- Примеры: авторизация (логин/логаут), заказ (создан → оплачен → отправлен → доставлен), лифт, игровой персонаж, конечные автоматы.

## Ключевые элементы диаграммы

- **Состояния** - Обозначаются прямоугольниками или закруглёнными блоками.
- **Начальное состояние** - Указывается стрелкой без источника.
- **Конечное состояние** - Может быть обозначено двойным кругом или специальным маркером.
- **Переходы** - Стрелки между состояниями, подписанные событием и/или действием (например, «Ввести пароль → Проверить»).
- **Условия перехода** - Логические выражения, определяющие, при каких условиях происходит переход.

## Подходы к тестированию

- **Покрытие всех состояний** - Убедиться, что каждое состояние может быть достигнуто.
- **Покрытие всех переходов** - Проверить каждый допустимый переход между состояниями.
- **Покрытие всех путей** - Протестировать все возможные последовательности переходов (часто ограничивают длину из-за комбинаторного взрыва).
- **Тестирование недопустимых переходов** - Попытаться выполнить переход, который не разрешён в текущем состоянии (например, повторный вход без выхода).

## Алгоритм создания тестов

1. **Анализ требований** для выявления состояний и событий.
2. **Построение диаграммы состояний** с указанием всех переходов.
3. **Создание таблицы состояний** (State Table) для формализации модели.
4. **Генерация тест-кейсов**:
   - Для каждого допустимого перехода
   - Для недопустимых переходов (негативные тесты)
   - Для граничных условий и исключительных ситуаций
5. **Оптимизация набора тестов** путем объединения в цепочки переходов.

## Преимущества

- **Наглядность** - Сложная логика состояний легко визуализируется.
- **Полнота** - Помогает выявить пропущенные или некорректные переходы.
- **Фокус на поведении** - Соответствует реальному пользовательскому опыту, где действия выполняются последовательно.
- **Раннее выявление дефектов** - Многие ошибки логики состояний обнаруживаются ещё на этапе проектирования диаграммы.

## Недостатки

- **Сложность при большом числе состояний** - Диаграмма становится громоздкой и трудной для анализа.
- **Не подходит для статических систем** - Неэффективна для систем, где состояние не играет ключевой роли.
- **Требует точных требований** - Необходимо чёткое понимание всех возможных состояний и событий.

## Лучшие практики

- Создавать диаграмму **совместно с аналитиками и разработчиками**.
- Использовать **стандартные нотации** (например, UML State Machine Diagrams).
- Интегрировать диаграммы в **спецификации требований** как живую документацию.
- Автоматизировать тесты на основе диаграммы, особенно для критических бизнес-процессов.
- Регулярно **обновлять диаграмму** при изменении бизнес-логики.

</details>